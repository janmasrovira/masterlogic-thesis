#+latex_compiler: xelatex
#+latex_class: article
#+title: Interpretability logics
#+author: Jan Mas Rovira
#+subtitle: Master's thesis

#+latex_header: \usepackage{hyperref}
#+latex_header: \usepackage{graphicx}
#+latex_header: \usepackage{unicode-math}
#+latex_header: \usepackage{fontspec}
#+latex_header: \usepackage[x11names, table]{xcolor}
#+latex_header: \usepackage[margin=2.5cm]{geometry}
#+latex_header: \usepackage{lmodern}
#+latex_header: \setmonofont{FreeMono}
#+latex_header: \usepackage{cancel}
#+latex_header: \usepackage{amsthm}
#+latex_header: \usepackage{float}
#+latex_header: \usepackage{newunicodechar}
#+latex_header: \usepackage[toc,indexonlyfirst,docdef=restricted]{glossaries-extra}
#+latex_header: \usepackage[style=ieee]{biblatex}
#+latex_header: \usepackage{multicol}

#+latex_header: \bibliography{refs}
#+latex_header: \makeglossaries

#+latex_header: \hypersetup{colorlinks=true,urlcolor=DodgerBlue4,linkcolor=Firebrick4,citecolor=Green4}
#+latex_header: \newcommand{\ie}[0]{i.e.\ }
#+latex_header: \newcommand{\todo}[0]{\textcolor{red}{pending}}
#+latex_header: \newcommand{\pend}[0]{\textcolor{Tomato3}{pending }}
#+latex_header: \newcommand{\red}[1]{\textcolor{red}{#1 }}
#+macro: jan @@latex:{\color{red}@@Jan: $1@@latex:}@@

#+macro: begindef @@latex:\begin{definition}@@
#+macro: enddef @@latex:\end{definition}@@

#+macro: begincoro @@latex:\begin{corollary}@@
#+macro: endcoro @@latex:\end{corollary}@@

#+macro: beginremark @@latex:\begin{remark}@@
#+macro: endremark @@latex:\end{remark}@@

#+macro: begintheorem @@latex:\begin{theorem}@@
#+macro: endtheorem @@latex:\end{theorem}@@

#+macro: beginlemma @@latex:\begin{lemma}@@
#+macro: endlemma @@latex:\end{lemma}@@

#+macro: beginproof @@latex:\begin{proof}@@
#+macro: endproof @@latex:\end{proof}@@


#+macro: defglossary @@latex:\newglossaryentry{$1}{name=$2,description={$3}}@@
#+macro: defacronym @@latex:\newacronym{$1}{$2}{$3}@@


#+latex_header: \newtheorem{theorem}{Theorem}
#+latex_header: \theoremstyle{definition}
#+latex_header: \newtheorem{corollary}[theorem]{Corollary}
#+latex_header: \theoremstyle{definition}
#+latex_header: \newtheorem{lemma}[theorem]{Lemma}
#+latex_header: \theoremstyle{definition}
#+latex_header: \newtheorem{definition}[theorem]{Definition}
#+latex_header: \theoremstyle{definition}
#+latex_header: \newtheorem{remark}[theorem]{Remark}

#+latex_header: \newglossaryentry{agdaprf}{name={\includegraphics[height=\baselineskip]{img/agda}},description={A proof formalized in Agda}}

#+macro: beginmulticols @@latex:\begin{multicols}{$1}@@
#+macro: endmulticols @@latex:\end{multicols}@@
#+macro: joost @@latex:\joost{$1}@@
#+macro: luka @@latex:\luka{$1}@@

{{{defglossary(gvm,model,Generalized Veltman model)}}}
{{{defglossary(gvf,frame,Generalized Veltman frame)}}}
{{{defglossary(ovf,frame,Ordinary Veltman frame)}}}
{{{defglossary(ovm,model,Ordinary Veltman model)}}}
{{{defglossary(forcing-gen,{\ensuremath{âŠ©^{gen}_M}},Forcing relation for generalized semantics)}}}
{{{defglossary(forcing-ord,{\ensuremath{âŠ©^{ord}_M}},Forcing relation for ordinary semantics)}}}
{{{defglossary(choice-set,choice set,Choice set)}}}
{{{defglossary(noetherian,Noetherian,Conversely well-founded relation)}}}
#+latex_header: \newglossaryentry{dependent-pair}{name={dependent pair},description={A pair in which the type of the second component is indexed by the first component}}
#+latex_header: \newglossaryentry{sum type}{name={sum type},description={A disjunction of two ore more types}}
#+latex_header: \newglossaryentry{decidable model}{name={decidable model},description={A model whose forcing relation is decidable}}
#+latex_header: \newglossaryentry{Rel}{name={\texttt{Rel}},description={Homogeneous relation}}
#+latex_header: \newglossaryentry{REL}{name={\texttt{REL}},description={Heterogeneous relation}}
#+latex_header: \newglossaryentry{Pred}{name={\texttt{Pred}},description={A predicate or a subset}}

#+macro: agda @@latex:\gls{agdaprf}\glsadd{agdaprf}@@
#+latex_header: \newcommand{\prin}[1]{\text{$\mathsf{#1}$}}
#+latex_header: \newcommand{\kgen}[1]{\text{($\mathsf{#1}$)\textsubscript{gen}}}
#+latex_header: \newcommand{\kord}[1]{\text{($\mathsf{#1}$)\textsubscript{ord}}}

#+latex_header: \newcommand{\joost}[1]{\textcolor{purple}{\bf Joost: #1}}
#+latex_header: \newcommand{\jan}[1]{\textcolor{orange}{\bf Jan: #1}}
#+latex_header: \newcommand{\luka}[1]{\textcolor{blue}{\bf Luka: #1}}

# Missing monospaced characters
#+latex_header: \setmathfont{XITS Math}
#+latex_header: \newfontfamily{\myfont}{XITS Math}
#+latex_header: \newunicodechar{ğ•}{\makebox[1em]{\myfontğ•}}
#+latex_header: \newunicodechar{â‚–}{\makebox[0.5em]{\textsubscript{k}}}
#+latex_header: \newunicodechar{â‚™}{\makebox[0.5em]{\textsubscript{n}}}
#+latex_header: \newunicodechar{â‚—}{\makebox[0.5em]{\textsubscript{l}}}
#+latex_header: \newunicodechar{ï½›}{\ensuremath{\{}}
#+latex_header: \newunicodechar{ï½}{\ensuremath{\}}}
#+latex_header: \setmathfont{Latin Modern Math}

* Introduction
** Overview of interpretability logics
** Original contributions
   This work includes the following original contributions:
   1. Generalized frame condition for $Râ‚$ (in collaboration with Luka). [[theorem:Râ‚][Link]];
   2. generalized frame condition for $Râ¿$. [[theorem:Râ¿][Link]];
   3. analysis of transitivity. [[theorem:trans][Link]];
   4. every Agda proof.

** Language
   <<sec:language>> The symbols of interpretability logics are $âŠ¥,â†’,â–·$.
   Formulas are defined recursively thus:
   \[Fmâ‰”Var\ |\ âŠ¥\ |\ Fmâ†’Fm \ |\  Fmâ–·Fm.\]

   We define $Varâ‰”â„•$. However, we use non-capital letters $a,b,c,x,y,zâ€¦$ to
   refer to variables.

   We define the usual operators and constants in the following way:

   1. $Â¬ A â‰” A â†’ âŠ¥$;
   2. $âŠ¤ â‰” Â¬ âŠ¥$;
   3. $A âˆ¨ B â‰” Â¬ A â†’ B$;
   4. $A âˆ§ B â‰” Â¬ (A â†’ Â¬ B)$;
   5. $A â†” B â‰” (A â†’ B) âˆ§ (B â†’ A)$;
   6. $â–¡ A â‰” Â¬ A â–· âŠ¥$;
   7. $â™¢ A â‰” Â¬ â–¡ Â¬ A$.

   The precedence of the operators is in the following order: $âˆ§,â–·,âˆ¨,â†’$.
** Notation
   Some notation that we use throughout the report:
   1. If $A$ and $B$ are binary relations, then $wAuBv$ means $wAu$ and $uBv$.
      For instance $wRuS_xv$ means $wRu$ and $uS_xv$. Another example: $wRuâŠ©A$
      means $wRu$ and $uâŠ©A$;
   2. $YâŠ©A$ iff for all $yâˆˆY$ we have $yâŠ©A$;
   3. $YâŠ®A$ iff there is some $yâˆˆY$ such that $yâŠ®A$;
   4. $âŸ¦AâŸ§â‰”\{w:wâŠ©A\}$;
   5. {{{agda}}} this is Agda's logo. Each proof that is formalized in Agda
      has been tagged with it;
   6. When we write a dot after the quantification of some variables, the scope of
      the variables extends to the rightmost part of what follows. Hence the
      formula  $âˆ€xâˆƒy.Pxyâˆ§âˆ€z.Pyz$ is equivalent to $âˆ€xâˆƒy(Pxyâˆ§âˆ€z(Pyz))$.


   In Section [[sec:trans]] and [[sec:frame-condition]] we present some diagrams. We use
   straight arrows to represent the $R$ relation and curvy arrows to represent
   some $S_w$ relation. We sometimes use red ink when an arrow is in a positive
   position in the formula to emphasize its role. We use discontinuous arrows
   when it is quantified universally.

   We believe that diagrams can help the reader have a better understanding of
   the underlying formula, however, they are not meant to be a replacement as
   they cannot unambiguously convey all the information in the formula.

** Logic $IL$
   The logic $IL$ encompasses all classical tautologies in the new language plus
   the following axiom schemes:
   - K: $â–¡ (A â†’ B) â†’ â–¡ A â†’ â–¡ B$;
   - L: $â–¡ (â–¡ A â†’ A) â†’ â–¡ A$;
   - J1: $â–¡ (A â†’ B) â†’ A â–· B$;
   - J2: $A â–· B âˆ§ B â–· C â†’ A â–· C$;
   - J3: $(A â–· C âˆ§ B â–· C) â†’ (A âˆ¨ B) â–· C$;
   - J4: $A â–· B â†’ â™¢ A â†’ â™¢ B$;
   - J5: $â™¢ A â–· A$.
   If $A$ is an instantiation of any of the previous axiom schemes, then
   $âŠ¢_{IL}A$. Additionally it has the following rules:
   - Necessitation: if $âŠ¢_{IL}A$ then $âŠ¢_{IL}â–¡A$.
   - Modus ponens: if $Î âŠ¢_{IL}Aâ†’B$ and $Î âŠ¢_{IL}A$ then $Î âŠ¢_{IL}B$.
   - Identity: If $AâˆˆÎ $ then $Î âŠ¢_{IL}A$.

   While it is acceptable to have infinite sets of assumptions, when verifying
   properties in Agda we have restricted ourselves to finite sets. This
   restriction is not meaningful in the context of this project.

   {{{begintheorem}}} *Local soundness for ordinary semantics*. That is, if
   $Î âŠ¢_{IL}A$ and $M$ is an ordinary model with a world $w$ such that $wâŠ©Î $,
   then $wâŠ©A$. {{{endtheorem}}} {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} <<theorem:il-sound>> *Local soundness for generalized
   semantics*. That is, if $Î âŠ¢_{IL}A$ and $M$ is a generalized model with a world
   $w$ such that $wâŠ©Î $, then $wâŠ©A$. {{{endtheorem}}}

   {{{beginproof}}} {{{agda}}} We have verified this in Agda for all the presented
   quasi-transitivity conditions in Table [[fig:table-trans]]. {{{endproof}}}

   {{{begintheorem}}} *Weakening*. If
   $Î âŠ¢_{IL}A$ then $B,Î âŠ¢_{IL}A$. {{{endtheorem}}}
   {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} *Deduction*.
   $Î âŠ¢_{IL}Aâ†’B$ iff $A,Î âŠ¢_{IL}B$. {{{endtheorem}}}
   {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} *Cut*. If
   $Î âŠ¢_{IL}B$ and $B,Î âŠ¢_{IL}A$ then $Î âŠ¢_{IL}A$. {{{endtheorem}}}
   {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} *Structurality*. If $Î âŠ¢_{IL}B$ and $Ïƒ$ is a
   substitution then $Ïƒ[Î ]âŠ¢_{IL}Ïƒ(A)$. {{{endtheorem}}} {{{beginproof}}}
   {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} *Conjunction*. $Î âŠ¢_{IL}Aâˆ§B$ iff $Î âŠ¢_{IL}A$ and $Î âŠ¢_{IL}B$.
   {{{endtheorem}}} {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} The following holds:
    1. $âŠ¢_{IL} A â†’ A$;
    2. $âŠ¢_{IL} A â–· A$;
    3. $âŠ¢_{IL} (A â†’ B) â†’ (B â†’ C) â†’ A â†’ C$;
    4. $âŠ¢_{IL} A â†’ Â¬ Â¬ A$;
    5. $âŠ¢_{IL} (Â¬ Â¬ A) â†’ A$;
    6. $âŠ¢_{IL} (A â†’ B) â†’ Â¬ B â†’ Â¬ A$;
    7. $âŠ¢_{IL} A â†’ âŠ¤$;
    8. $âŠ¢_{IL} âŠ¥ â†’ A$;
    9. $âŠ¢_{IL} Â¬ A â†’ A â†’ B$;
    10. $âŠ¢_{IL} A âˆ§ B â†’ A$;
    11. $âŠ¢_{IL} A âˆ§ B â†’ B$;
    12. $âŠ¢_{IL} (A â†’ B â†’ C) â†’ B â†’ A â†’ C$;
    13. $âŠ¢_{IL} A â†’ B â†’ A âˆ§ B$;
    14. $âŠ¢_{IL} A â†’ A âˆ¨ B$;
    15. $âŠ¢_{IL} B â†’ A âˆ¨ B$;
    16. $âŠ¢_{IL} A â–· (A âˆ¨ â™¢ A)$;
    17. $âŠ¢_{IL} (A âˆ¨ â™¢ A) â–· A$;
    18. $âŠ¢_{IL} A â†’ B â‡’ âŠ¢_{IL} â–¡ A â†’ â–¡ B$;
    19. $âŠ¢_{IL} A â†” B â‡’ âŠ¢_{IL} â–¡ A â†” â–¡ B$;
    20. $âŠ¢_{IL} â–¡ (A âˆ§ B) â†” (â–¡ A âˆ§ â–¡ B)$;
    21. $âŠ¢_{IL} A â†’ B â‡’ âŠ¢_{IL} â™¢ A â†’ â™¢ B$;
    22. $âŠ¢_{IL} A â†” B â‡’ âŠ¢_{IL} â™¢ A â†” â™¢ B$;
    23. $âŠ¢_{IL} Â¬ (A âˆ§ B) â†” Â¬ A âˆ¨ Â¬ B$;
    24. $âŠ¢_{IL} (A âˆ¨ Â¬ B) â†’ (A âˆ§ B âˆ¨ Â¬ B)$.
   {{{endtheorem}}}
   {{{beginproof}}} {{{agda}}}
   {{{endproof}}}

** Semantics
   In this document we consider two variants of relational semantics for
   interpretability logics similar to Kripke semantics for other modal logics.

*** Ordinary Veltman semantics
    {{{begindef}}} <<def:ordinary-frames>> cite:modal-matters An ordinary
    Veltman \gls{ovf} $F=âŸ¨W,R,SâŸ©$ is a structure constituted by a non-empty set
    of worlds $W$, a binary relation $RâŠ†WÂ²$ and a ternary relation $SâŠ†WÃ—WÃ—W$. We
    write $wRu$ instead of $âŸ¨w,uâŸ©âˆˆR$ and $uS_wv$ instead of $âŸ¨w,u,vâŸ©âˆˆS$. The
    structure must satisfy the following conditions:

    1. $R$ is a transitive;
    2. $R$ is conversely well-founded. That is, there is no infinite ascending
       chain $wâ‚Rwâ‚‚Râ€¦$;
    3. if $uS_wv$ then $wRu$ and $wRv$;
    4. if $wRu$ then $uS_wu$;
    5. if $wRu$ and $uRv$ then $uS_wv$.
    6. for every $w$, $S_w$ is transitive;
    {{{enddef}}}


    {{{begindef}}} An ordinary Veltman \gls{ovm} $M=âŸ¨F,VâŸ©$ is a structure
    constituted by an ordinary Veltman frame $F$ and a valuation $VâŠ†WÃ—Var$. If
    $F=âŸ¨W,R,SâŸ©$ we will write $M=âŸ¨W,R,S,VâŸ©$ instead of $M=âŸ¨âŸ¨W,R,SâŸ©,VâŸ©$. {{{enddef}}}

    {{{begindef}}} <<def:ord-forcing>> Given a model $M$, we define a forcing
    relation $\gls{forcing-ord}âŠ†W Ã— Fm$. We write $M,wâŠ©A$ instead of
    $âŸ¨w,AâŸ©âˆˆ\gls*{forcing-ord}$ or simply $wâŠ©A$ when the model is clear from the
    context. We write $wâŠ®A$ when $âŸ¨w,AâŸ©âˆ‰âŠ©_M$.
    1. $wâŠ®âŠ¥$;
    2. if $pâˆˆVar$, then $wâŠ©p$ iff $âŸ¨w,pâŸ©âˆˆV$;
    3. if $A,BâˆˆFm$, then $wâŠ©Aâ†’B$ iff if $wâŠ©A$ then $wâŠ©B$;
    4. if $A,BâˆˆFm$, then $wâŠ©Aâ–·B$ iff if $wRu$ and $uâŠ©A$ then there exists $v$ such
       that $vâŠ©B$ and $uS_wv$.
    {{{enddef}}}

    If $F$ is an ordinary Veltman frame and $A$ a formula, we write $FâŠ©A$ to
    denote that for every valuation we have $âŸ¨F,VâŸ©âŠ©A$.

    {{{begincoro}}}
    <<coro:ord-semantics>>
    It can be shown that:
    1. If $A,BâˆˆFm$, then $wâŠ©Aâˆ§B$ iff $wâŠ©A$ and $wâŠ©B$;
    1. If $A,BâˆˆFm$, then $wâŠ©Aâˆ¨B$ iff $wâŠ©A$ or $wâŠ©B$;
    2. if $AâˆˆFm$, then $wâŠ©Â¬A$ iff $wâŠ®A$;
    3. if $AâˆˆFm$, then $wâŠ©â™¢A$ iff there exists $u$ such that $wRu$ and $uâŠ©A$;
    4. if $AâˆˆFm$, then $wâŠ©â–¡A$ iff for every $u$ such that $wRu$ we have $uâŠ©A$.
    {{{endcoro}}}
    {{{beginproof}}}
    {{{agda}}}
    {{{endproof}}}

    {{{begintheorem}}} *Decidability* If $W$ is finite and $R,S,V$ are decidable relations,
    then the forcing relation associated to the model $Mâ‰”âŸ¨W,R,S,VâŸ©$ is decidable.
    {{{endtheorem}}} {{{beginproof}}} {{{agda}}} We have implemented a verified
    algorithm that given the mentioned conditions, a world $w$ and a formula
    $A$, constructs either a proof of $M,wâŠ©A$ or a proof of $M,wâŠ®A$. {{{endproof}}}

*** Generalized Veltman semantics
    {{{begindef}}} cite:mikec2019interpretability A generalized Veltman \gls{gvf}
    $F=âŸ¨W,R,SâŸ©$ is a structure constituted by a non-empty set of worlds $W$, a binary
    relation $RâŠ†WÂ²$ and a ternary relation $SâŠ†WÃ—WÃ—(ğ’«(W)âˆ–\{âˆ…\})$. We write $wRu$
    instead of $âŸ¨w,uâŸ©âˆˆR$ and $uS_wY$ instead of $âŸ¨w,u,YâŸ©âˆˆS$. The structure must
    satisfy the following conditions :

    1. $R$ is transitive; <<R-trans>>
    2. $R$ is conversely well-founded. That is, there is no infinite ascending
       chain $wâ‚Rwâ‚‚Râ€¦$;
    3. if $uS_wY$ then $wRu$ and for all $yâˆˆY$ we have $wRy$;
    4. /quasi-reflexivity/: if $wRu$ then $uS_w\{u\}$;
    5. if $wRu$ and $uRv$ then $uS_w\{v\}$;
    6. /quasi-transitivity/: if $uS_wY$ and $yS_wZ_y$ for all $yâˆˆY$, then
       $uS_w\left(â‹ƒ_{yâˆˆY}Z_y\right)$. This is a particular notion of
       quasi-transitivity, throughout this document we explore a total of eight
       notions, see Section [[sec:trans]].
    # 7. $S$ is monotone in the following sense: if $uS_wVâŠ†ZâŠ†\{u:wRu\}$ then
    #    $uS_wZ$.
    {{{enddef}}}

    {{{begindef}}}
    <<def:gen-frame>>
    A generalized Veltman \gls{gvm} $M=âŸ¨F,VâŸ©$ is a structure
    constituted by a generalized Veltman \gls{gvf} $F$ and a valuation $VâŠ†WÃ—Var$.
    {{{enddef}}}
    {{{begindef}}}
    Given a model $M$, we define a forcing relation $\gls{forcing-gen}âŠ†W Ã—
    Fm$. We use the same notational conventions as in the ordinary semantics.
    1. $wâŠ®âŠ¥$;
    2. if $pâˆˆVar$, then $wâŠ©p$ iff $âŸ¨w,pâŸ©âˆˆV$;
    3. if $A,BâˆˆFm$, then $wâŠ©Aâ†’B$ iff if $wâŠ©A$ then $wâŠ©B$;
    4. if $A,BâˆˆFm$, then $wâŠ©Aâ–·B$ iff if $wRu$ and $uâŠ©A$ then there exists $Y$ such
       that $YâŠ©B$ and $uS_wY$. When we write $YâŠ©B$ we mean that for all $yâˆˆY$ we
       have $yâŠ©B$;
    {{{enddef}}}

    If $F$ is a generalized Veltman frame and $A$ a formula, we write $FâŠ©A$ to
    denote that for every valuation we have $âŸ¨F,VâŸ©âŠ©A$.

    {{{begincoro}}} We can show the same results in Corollary [[coro:ord-semantics]]
    for generalized semantics:
    1. If $A,BâˆˆFm$, then $wâŠ©Aâˆ§B$ iff $wâŠ©A$ and $wâŠ©B$;
    1. If $A,BâˆˆFm$, then $wâŠ©Aâˆ¨B$ iff $wâŠ©A$ or $wâŠ©B$;
    2. If $AâˆˆFm$, then $wâŠ©Â¬A$ iff $wâŠ®A$;
    3. If $AâˆˆFm$, then $wâŠ©â™¢A$ iff there exists $u$ such that $wRu$ and $uâŠ©A$;
    4. If $AâˆˆFm$, then $wâŠ©â–¡A$ iff for every $u$ such that $wRu$ we have $uâŠ©A$.
    {{{endcoro}}}
    {{{beginproof}}}
    {{{agda}}}
    {{{endproof}}}

** Transitivity
   <<sec:trans>> In the literature one can find several semantic requirements
   for the quasi-transitivity condition. Theorem [[theorem:trans]] presents the
   some direct implications between them. Theorems [[theorem:il-sound]] and
   [[theorem:trans-extend]] are sufficient to argue that all of them are appropriate
   for proving completeness of IL.


#+name: fig:table-trans
#+caption: Semantic requirements for quasi-transitivity mentioned in the literature.
#+attr_latex: :align c|l|l :float t :center t :placement [H] :font \small
| Nr. | Semantic requirement for transitivity                                                  | Mentioned in                              |
|-----+----------------------------------------------------------------------------------------+-------------------------------------------|
| (1) | $uS_xY â‡’ âˆ€ \, \{ Y_y\}_{yâˆˆ Y} \Big((âˆ€\, yâˆˆY\ yS_xY_y) â‡’ âˆƒ ZâŠ† â‹ƒ_{yâˆˆ Y}Y_y âˆ§ uS_xZ\Big)$ | This paper                                |
| (2) | $uS_xY â‡’ âˆ€ \, \{ Y_y\}_{yâˆˆ Y} \Big((âˆ€\, yâˆˆY\ yS_xY_y) â‡’ uS_xâ‹ƒ_{yâˆˆ Y}Y_y\Big)$          | Verbrugge '92 \cite{Verbrugge}            |
| (3) | $uS_xY â‡’ âˆƒ\, yâˆˆY\, âˆ€ Y'(yS_xY' â‡’ âˆƒ \, Y''{âŠ†}Y' âˆ§ uS_xY'')$                             | This paper                                |
| (4) | $uS_xY â‡’ âˆƒ\, yâˆˆY\, âˆ€ Y'(yS_xY' â‡’ uS_xY')$                                              | Joosten '98 \cite{joosten-master}         |
| (5) | $uS_xY â‡’ âˆ€\, yâˆˆY\, âˆ€ Y'(yS_xY' â‡’ âˆƒ \, Y''{âŠ†}Y' âˆ§ uS_xY'')$                             | This paper                                |
| (6) | $uS_xY â‡’ âˆ€\, yâˆˆY\, âˆ€ Y'(yS_xY' â‡’ uS_xY')$                                              | Verbrugge '92 \cite{Verbrugge}            |
| (7) | $uS_xY â‡’ âˆ€\, yâˆˆY\, âˆ€ Y'(yS_xY'\wedge yâˆ‰Y' â‡’ âˆƒ \, Y''{âŠ†}Y'\ uS_xY'')$                   | This paper                                |
| (8) | $uS_xY â‡’ âˆ€\, yâˆˆY\, âˆ€ Y'(yS_xY'\wedge yâˆ‰Y' â‡’ uS_xY')$                                   | Goris, Joosten '09 \cite{a-new-principle} |

   #+caption: Diagrams for conditions 2, 4 and 6.
   #+name: fig:diagrams-transitivity
   #+attr_latex: :float t :width 0.9\textwidth :placement [H]
   [[file:img/trans-2-4-6.pdf]]

# I NOW SEE THAT THE TABLE IN YOUR SECTION 1.6 HAS BEEN UPDATED IN OUR PAPER

# OF COURSE, YOU SHOULD ADAPT IT TO YOUR THESIS.
# SHORTLY WE WILL PUT IT ON THE ARXIV SO THAT YOU CAN INCLUDE A REFERENCE



 # All of the presented quasi-transitivity requirements are adequate for proving
 # IL soundness and completeness. For soundness it is routine to check that every
 # instantiation of $J2$ holds. For the completeness part it is enough to see that
 # any ordinary Veltman model $M=âŸ¨W,R,S,VâŸ©$ can be transformed into a generalized
 # Veltman model $M'=âŸ¨W,R,S',VâŸ©$ where $S'â‰”\{âŸ¨w,x,\{y\}âŸ©:âŸ¨w,x,yâŸ©âˆˆS\}$ and see that
 # $M'$ has the same truth value as $M$. This has been verified in Agda.

 {{{begintheorem}}} <<theorem:trans>> Let $F$ be a generalized Veltman frame. Let
 $Mâ‰”âˆ€w,u,V,Z(uS_wVâŠ†ZâŠ†\{u:wRu\}â‡’uS_wZ)$ represent the monotonicity condition. The
 following implications hold.

 The first item should be read as $FâŠ¨Mâˆ§(1)â†’(2)$.

 {{{beginmulticols(3)}}}

   1. $M âˆ§ (1) â‡’ (2)$
   2. $(2) â‡’ (1)$
   3. $M âˆ§ (3) â‡’ (4)$
   4. $(4) â‡’ (3)$
   5. $(5) â‡’ (1)$
   6. $M âˆ§ (5) â‡’ (2)$
   7. $(5) â‡’ (3)$
   8. $M âˆ§ (5) â‡’ (4)$
   9. $M âˆ§ (5) â‡’ (6)$
   10. $(5) â‡’ (7)$
   11. $M âˆ§ (5) â‡’ (8)$
   12. $(6) â‡’ (1)$
   13. $M âˆ§ (6) â‡’ (2)$
   14. $(6) â‡’ (3)$
   15. $(6) â‡’ (4)$
   16. $(6) â‡’ (5)$
   17. $(6) â‡’ (7)$
   18. $(6) â‡’ (8)$
   19. $M âˆ§ (7) â‡’ (8)$
   20. $(8) â‡’ (7)$

 {{{endmulticols}}} {{{endtheorem}}}

 {{{beginproof}}}
 {{{agda}}}
 {{{endproof}}}

 {{{begintheorem}}}
 <<theorem:trans-extend>>
 Given an ordinary Veltman model $M=âŸ¨W,R,S,VâŸ©$ we can find some
 generalized Veltman model $M'=âŸ¨W,R,S',VâŸ©$ satisfying transitivity
 $(i)âˆˆ\{1â€¦8\}$ such that for every world $w$ and formula $A$: \[M,wâŠ©Aâ‡”M',wâŠ©A.\]
 {{{endtheorem}}}

 {{{beginproof}}} We prove it for the transitivity condition (2) (the rest can
 be proven in the same way). Let $M=âŸ¨W,R,S,VâŸ©$ be an ordinary model. Let
 $M'â‰”âŸ¨W,R,S',VâŸ©$ with $S'$ defined thus: \[S'â‰”\{âŸ¨w,x,\{y\}âŸ©:âŸ¨w,x,yâŸ©âˆˆS\}.\] It is
 easy to observe that $M'$ satisfies conditions $1,â€¦,5$ from definition
 [[def:gen-frame]]. It is also easy to see that it satisfies transitivity 2. We show
 that they force the same formulas by induction on the complexity of the
 formula. The only interesting case is $Aâ–·B$.
   - Assume $M,wâŠ©Aâ–·B$ and that for some $x$ we have $wRxâŠ©A$. It follows that
     there exists some $y$ such that $xS_wyâŠ©B$. By definition of $M'$ we have
     $xS'_w\{y\}$ and also $\{y\}âŠ©B$, therefore $M',wâŠ©Aâ–·B$.
   - Assume $M,wâŠ®Aâ–·B$, then there exists some $x$ such that $wRxâŠ©A$ and
     $âˆ€y(xS_wyâ‡’yâŠ®B)$. It is obvious that for $M'$ we have $âˆ€y(xS'_w\{y\}â‡’yâŠ®B)$
     and also $âˆ€Y(xS'_wYâ‡’YâŠ®B)$, which is the required property.
 {{{endproof}}}

** Monotonicity
   Consider the following monotonicity condition:

  #+begin_center
    if $uS_wVâŠ†ZâŠ†\{v:wRv\}$ then $uS_wZ$.
  #+end_center

  {{{begintheorem}}} <<theorem:mono>> Let $F=âŸ¨W,R,SâŸ©$ be a generalized Veltman
  frame with quasi-transitivity $(i)âˆˆ\{1,â€¦,8\}$.
  Let $F'=âŸ¨W,R,S'âŸ©$ where $S'$ is the monotone closure of $S$:

  \[S'â‰”\{âŸ¨w,x,Y'âŸ© : âŸ¨w,x,YâŸ©âˆˆS, YâŠ†Y'âŠ†\{u:wRu\}\}.\]

  Then $F'$ is a generalized Veltman frame satisfying quasi-transitivity
  Condition (2). Furthermore, let $V$ be an arbitrary valuation and $A$ an
  arbitrary formula. Let $Mâ‰”âŸ¨F,VâŸ©$ and $M'â‰”âŸ¨F',VâŸ©$. We have that for every world
  $w$: \[M,wâŠ©Aâ‡”M',wâŠ©A.\] {{{endtheorem}}}


  {{{beginproof}}} {{{agda}}}

  We check conditions listed in definition [[def:gen-frame]].
  - Conditions 1 and 2 are clear since $R$ is unchanged;
  - condition 3 follows from the fact that in the definition of $S'$ we require
    $Y'âŠ†\{u:wRu\}$;
  - for conditions 4 and 5 observe that $SâŠ†S'$. Then, since these conditions hold for
    $F$ they also hold for $F'$;
  - for quasi-transitivity Condition (2) assume that $uS'_xY'$ and that for
    every $y'âˆˆY'$ we have $y'S'_xÎ¥_{y'}$. We need to show that
    $uS'_xâ‹ƒ_{y'âˆˆY'}Î¥_{y'}$. By definition of $S'$ it follows that there exists
    $YâŠ†Y'$ such that $uS_xY$, furthermore, for every $y'âˆˆY'$ we have that there
    exists $f(Î¥_{y'})âŠ†Î¥_{y'}$ such that $y'S_xf(Î¥_{y'})$. From $YâŠ†Y'$ it follows
    that for all $yâˆˆY$ there exists $f(Î¥_{y})âŠ†Î¥_{y}$ such that $yS_xf(Î¥_{y})$.
    Then by (2) for $F$ it follows that $uS_xâ‹ƒ_{yâˆˆY}f(Î¥_{y})$. Then see that
    $â‹ƒ_{yâˆˆY}f(Î¥_{y})âŠ†â‹ƒ_{y'âˆˆY'}Î¥_{y'}$. It remains to show
    $â‹ƒ_{y'âˆˆY'}Î¥_{y'}âŠ†xR\{u:xRu\}$. Consider some $u$ such that there is some
    $y'âˆˆY'$ with $uâˆˆÎ¥_{y'}$. By assumption we have $y'S'_xÎ¥_{y'}$ and thus
    $xRu$.
  To show $M,wâŠ©Aâ‡”M',wâŠ©A$ we proceed by induction on $A$. The only
  interesting case is $Aâ–·B$.
  - Assume that $M,wâŠ©Aâ–·B$ and that there is some world $x$ such that $wRx$ and
    $M',xâŠ©A$. By IH we have $M,xâŠ©A$, so there exists some $Y$ such that $xS_wY$
    and $M,YâŠ©B$. By IH we have $M',YâŠ©B$ and by definition of $S'$ it follows
    that $xS'_wY$, therefore $M',wâŠ©Aâ–·B$.
  - Assume that $M,wâŠ®Aâ–·B$. It follows that there is some $x$ such that $wRx$,
    $M,xâŠ©A$ and $(â‹†)\ âˆ€Y(xS_wYâ‡’M,YâŠ®B)$. We want to prove that
    $âˆ€Y'(xS'_wY'â‡’M',Y'âŠ®B)$. Assume that for some $Y'$ we have $xS'_wY'$. By
    definition of $S'$ it follows there exists some $Y$ such that $YâŠ†Y'$ and
    $xS_wY$. Hence by $(â‹†)$ we have that $M,YâŠ®B$ and thus there exists $yâˆˆY$
    such that $M,yâŠ®B$. By IH we get that $M',yâŠ®B$ and since $yâˆˆYâŠ†Y'$ we have
    $Y'âŠ®B$, so $M',wâŠ®Aâ–·B$.
  {{{endproof}}}

  As we see in Theorem [[theorem:mono]] taking the monotone closure of each $S_w$ does not
  change the forcing relation and the resulting frame satisfies quasi-transitivity
  Condition (2).

  # The previous lemma allows us to safely assume that monotonicity is a condition
  # for a Veltman frame with quasi-transitivity (2).

  {{{beginremark}}} Taking the monotone closure of each $S_w$ is essentially
  different than assuming that each $S_w$ is monotone by definition of the
  frame, as then the forcing relation may change. In the following example we
  present a generalized Veltman model with Condition (8) that showcases such
  behaviour.

   #+caption: Example frame: $wRv_0,wRv_1,wRv_2,wRv_3$, $v_0S_w\{v_1\}$, $v_2S_w\{v_3\}$.
   #+name: fig:example-trans
   #+attr_latex: :float t :width 0.28\textwidth :placement [H]
   [[file:img/example.pdf]]

  Let $M$ be a model based on the frame displayed[fn::In the figure we do not
  show the $S_w$ relations required by quasi-reflexivity for clarity.] in figure
  [[fig:example-trans]] such that $âŸ¦pâŸ§ = \{v_0\}$, $âŸ¦qâŸ§ = \{v_2\}$. We see that
  $wâŠ©Â¬(p â–· q)$ as $p$ is only true in $v_0$ and we only have $v_0S_w\{v_1\}$ and
  $v_0S_w\{v_0\}$ with $v_0âŠ®q$ and $v_1âŠ®q$. If we take the monotonic closure of
  $S$ we have $v_0S_w \{v_1, v_2\}$ and by quasi-transitivity (8) we get $v_0S_w
  \{v_3\}$ and consequently $wâŠ©Â¬(p â–· q)$ is no longer true.

  {{{endremark}}}

* Frame conditions
  <<sec:frame-condition>> An interpretability principle is a schema of modal
  formulas that carries some special significance.

  {{{joost(OF COURSE\, YOU WILL NEED SOME GENERAL BACKGROUND. WHAT DOES FRAME
  VALIDITY MEAN\, WHAT ARE FRAME CONDITIONS\, ETC.)}}}

  In this section we present a series of principles in conjunction with their
  respective frame conditions for ordinary semantics as well as generalized
  semantics.
** The principle \prin{M}
   The \prin{M} principle reads as follows:
   \[A â–· B â†’ (A âˆ§ â–¡ C) â–· (B âˆ§ â–¡ C).\]

   {{{joost(AT SOME STAGE YOU SHOULD BE GIVING CONTEXT HERE. WHEN WAS THE
   PRINCIPLE INTRODUCED AND BY WHOM. ALSO\, WHY IS IT IMPORTANT\, ETC.)}}}

*** Ordinary semantics
   The frame condition for \prin{M} for ordinary semantics, we write $\kord{M}$,
   reads as follows:
   \[âˆ€w,x,y,z(xS_w yRz â‡’ xRz).\]

   #+caption: Ordinary frame condition for \prin{M}.
   #+name: fig:ord-M-condition
   #+attr_latex: :float t :width 0.20\textwidth :placement [H]
   [[file:img/M-ord.pdf]]

   {{{begintheorem}}} For any ordinary frame $F$, we have that $F$ satisfies the
   $\kord{M}$ condition iff any model based on $F$ forces every instantiation of the \prin{M}
   principle. In symbols:

   \[F âŠ¨ \kord{M} â‡” F âŠ© M.\] {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   - \boxed{â‡’} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $wâŠ©Aâ–·B$ and that there is a world $x$ such that $wRx$ and $xâŠ©Aâˆ§â–¡C$.
     Our aim is to find a world $z$ such that $xS_wzâŠ©Bâˆ§â–¡C$. Since $wRxâŠ©A$ and
     $wâŠ©Aâ–·B$ there is a world $z$ such that $xS_wzâŠ©B$. We now show that $zâŠ©â–¡C$.
     Consider an arbitrary $u$ such that $zRu$. By the frame condition it
     follows that $xRu$ and we know $xâŠ©â–¡C$ hence $uâŠ©C$ and thus $zâŠ©â–¡C$. Hence
     $z$ is the desired world.

   - \boxed{â‡} Let $a,b,câˆˆVar$, assume $FâŠ©aâ–·bâ†’(aâˆ§â–¡c)â–·(bâˆ§â–¡c)$. Assume also that
     for some $x,w,u$ we have $xS_wzRu$. Our goal is to prove $xRu$. Consider a
     model such that the following holds.
     \begin{flalign*}
     âŸ¦aâŸ§ &= \{x\}; \\
     âŸ¦bâŸ§ &= \{z\}; \\
     âŸ¦câŸ§ &= \{v:xRv\}.
     \end{flalign*}
     We observe that $wâŠ©aâ–·b$ because $a$ is only forced in $x$ and we have
     $xS_wzâŠ©b$. Then it follows that $wâŠ©(aâˆ§â–¡c)â–·(bâˆ§â–¡c)$. It is easy to observe
     that $xâŠ©aâˆ§â–¡c$, furthermore we have that by the definition of an ordinary frame
     $xS_wzâ‡’wRx$, hence $wRx$ and thus there must exist some $v$ such that
     $xS_wvâŠ©bâˆ§â–¡c$. Since $b$ is only true in $z$ it must be $zâŠ©bâˆ§â–¡c$. Then,
     because $zRu$ we have $uâŠ©c$, therefore $xRu$.
   {{{endproof}}}

*** Generalized semantics
   The frame condition for \prin{M} for generalized semantics, we write $\kgen{M}$,
   reads as follows:

   \[ âˆ€w,x,V(xS_wVâ‡’ âˆƒV'âŠ†V(xS_wV',âˆ€v'âˆˆV'âˆ€z(v'Rzâ‡’xRz))).\]


   #+caption: Generalized frame condition for \prin{M}.
   #+name: fig:gen-M-condition
   #+attr_latex: :float t :width 0.20\textwidth :placement [H]
   [[file:img/wip.png]]

   {{{begintheorem}}} For any generalized frame $F$, we have that $F$ satisfies the
   $\kgen{M}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{M} principle. In symbols:

   \[F âŠ¨ \kgen{M} â‡” F âŠ© M.\] {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   - \boxed{â‡’} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $wâŠ©Aâ–·B$ and that there is a world $x$ such that $wRx$ and $xâŠ©Aâˆ§â–¡C$.
     Our aim is to find a set $Z$ such that $xS_wZâŠ©Bâˆ§â–¡C$. Since $wRxâŠ©A$ and
     $wâŠ©Aâ–·B$ there is set $Z$ such that $xS_wZâŠ©B$. Then by the $\kgen{M}$
     condition it follows that there is a set $Z'âŠ†Z$ such that $xS_wZ'$ and
     $âˆ€vâˆˆZ'âˆ€z(vRzâ‡’xRz)$. Now we show $Z'âŠ©â–¡C$. Let $vâˆˆZ'$ and $u$ such that
     $vRu$, by the condition above it follows $xRu$ and since $xâŠ©â–¡C$ we have
     $uâŠ©C$. Hence $Z'$ is the desired set.
   - \boxed{â‡} Let $a,b,câˆˆVar$ and assume $FâŠ©a â–· b â†’ (a âˆ§ â–¡ c) â–· (b âˆ§ â–¡ c)$ and
     $uS_wV$. Consider a model satisfying the following
     \begin{flalign*}
     âŸ¦aâŸ§ &= \{u\}; \\
     âŸ¦bâŸ§ &= V; \\
     âŸ¦câŸ§ &= \{v:uRv\}.
     \end{flalign*}
     We see that $wâŠ©aâ–·b$ since $a$ is only true in $u$ and we have $uS_wVâŠ©b$. It
     follows that ${wâŠ©(a âˆ§ â–¡ c)â–·(bâˆ§â–¡c)}$. It is easy to see that $uâŠ©aâˆ§â–¡c$, hence
     there must exist $V'$ such that $uS_wV'âŠ©bâˆ§â–¡c$. Clearly $V'âŠ†V$ since $b$ is
     forced exactly in $V$. Now let $v',z$ such that $v'âˆˆV'$ and $v'Rz$. Since
     $v'âŠ©â–¡c$, then $zâŠ©c$ and thus $uRz$. Therefore $V'$ is the desired set.
   {{{endproof}}}
** The principle \prin{Mâ‚€}
   The \prin{Mâ‚€} principle reads as follows:
   \[A â–· B â†’ â™¢ A âˆ§ â–¡ C â–· B âˆ§ â–¡ C.\]

*** Ordinary semantics
    The $\kord{Mâ‚€}$ condition reads as follows:
    \[âˆ€w,x,y,z(wRxRyS_wzâ‡’xS_wz,âˆ€u(zRuâ‡’xRu)).\]

   #+caption: Ordinary frame condition for \prin{Mâ‚€}.
   #+name: fig:M_0-ord
   #+attr_latex: :float t :width 0.25\textwidth :placement [H]
   [[file:img/M_0-ord.pdf]]

    {{{begintheorem}}} For any ordinary frame $F$, we have that $F$ satisfies the
    $\kord{Mâ‚€}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{Mâ‚€} principle. In symbols:

    \[F âŠ¨ \kord{Mâ‚€} â‡” F âŠ© Mâ‚€.\] {{{endtheorem}}}

    {{{beginproof}}}
    {{{agda}}}
    - \boxed{â‡’} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
      that $wâŠ©Aâ–·B$ and that there exists some $x$ such that $wRxâŠ© â™¢ A âˆ§ â–¡ C$. It
      follows that there exists some world $y$ such that $xRyâŠ©A$, then since
      $wRy$ and $wâŠ©Aâ–·B$ there exists a world $z$ such that $yS_wzâŠ©B$. By the
      $\kord{Mâ‚€}$ condition we have that $xS_wz$ and $(â‹†)\ âˆ€u(zRuâ‡’xRu)$. Hence,
      it remains to show $zâŠ©â–¡C$. Consider some world $u$ such that $zRu$, by
      $(â‹†)$ it follows that $xRu$ and since $xâŠ©â–¡C$ we also have $uâŠ©C$.
    - \boxed{â‡} Let $a,b,câˆˆVar$ and assume $FâŠ©a â–· b â†’ (â™¢ a âˆ§ â–¡ c) â–· (b âˆ§ â–¡ c)$ and
      assume that for some $w,x,y,z$ we have $wRxRyS_wz$. Consider a model based
      on $F$ such that the following holds:
      \begin{flalign*}
      âŸ¦aâŸ§ &= \{y\}; \\
      âŸ¦bâŸ§ &= \{z\}; \\
      âŸ¦câŸ§ &= \{w:xRw\}.
      \end{flalign*}
      Observe that $wâŠ©aâ–·b$ since $a$ is forced only in $y$ and we have $yS_wzâŠ©b$.
      It follows that $wâŠ©(â™¢ a âˆ§ â–¡ c) â–· (b âˆ§ â–¡ c)$. Clearly $xâŠ©â™¢aâˆ§â–¡c$, hence there
      must exist some world $v$ such that $xS_wvâŠ©bâˆ§â–¡c$ but since $b$ is only
      forced in $z$ we have $z=v$ and thus $xS_wz$. To prove the remaining
      implication let $u$ such that $zRu$, then $uâŠ©c$ and thus $xRu$.
    {{{endproof}}}

*** Generalized semantics
    The $\kgen{Mâ‚€}$ condition reads as follows:
    \[âˆ€w,x,y,Y(wRxRyS_wYâ‡’âˆƒY'âŠ†Y(xS_wY',âˆ€y'âˆˆY'âˆ€z(y'Rzâ‡’xRz))).\]

   #+caption: Generalized frame condition for \prin{Mâ‚€}.
   #+name: fig:M_0-gen
   #+attr_latex: :float t :width 0.30\textwidth :placement [H]
   [[file:img/M_0-gen.pdf]]


    {{{begintheorem}}} For any ordinary frame $F$, we have that $F$ satisfies the
    $\kgen{Mâ‚€}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{Mâ‚€} principle. In symbols:

    \[F âŠ¨ \kgen{Mâ‚€} â‡” F âŠ© Mâ‚€.\] {{{endtheorem}}}

    {{{beginproof}}}
    {{{agda}}}
    - \boxed{â‡’} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
      that $wâŠ©Aâ–·B$ and that there is a world $x$ such that $wRxâŠ©â™¢Aâˆ§â–¡C$. Then
      there must exist some world $y$ such that $xRyâŠ©A$. Since $wRy$ and $wâŠ©Aâ–·B$
      there exists some set $Y$ such that $yS_wYâŠ©B$. Then by the $\kgen{Mâ‚€}$
      condition we have that there exists some $Y'âŠ†Y$ such that $xS_wY'$ and
      $(â‹†)\ âˆ€y'âˆˆY'âˆ€z(y'Rzâ‡’xRz)$. Clearly $Y'âŠ©B$ since $Y'âŠ†Y$. To show that
      $Y'âŠ©â–¡C$ consider some $y'âˆˆY'$ and some $z$ such that $y'Rz$. Then, by
      $(â‹†)$ it follows that $xRz$ and since $xâŠ©â–¡C$ we also have $xâŠ©C$.
    - \boxed{â‡} Let $a,b,câˆˆVar$ and assume $FâŠ©a â–· b â†’ (â™¢ a âˆ§ â–¡ c) â–· (b âˆ§ â–¡ c)$
      and assume that for some $w,x,y,Y$ we have $wRxRyS_wY$. Then consider a
      model based on $F$ such that.
      \begin{flalign*}
      âŸ¦aâŸ§ &= \{y\}; \\
      âŸ¦bâŸ§ &= Y; \\
      âŸ¦câŸ§ &= \{v:xRv\}.
      \end{flalign*}
      Observe that $wâŠ©aâ–·b$ as $a$ is only forced in $y$ and we have $yS_wYâŠ©b$.
      Consequently it holds that $wâŠ©(â™¢ a âˆ§ â–¡ c) â–· (b âˆ§ â–¡ c)$. See also that
      $xâŠ©â™¢a$ since $xRyâŠ©a$ and also $xâŠ©â–¡c$ by definition of the model. Then
      there must exist some set $Y'$ such that $xS_wY'âŠ©bâˆ§â–¡c$. Clearly $Y'âŠ†Y$ since
      $Y'âŠ©b$. To show the remaining condition pick some $y'âˆˆY'$ and some $z$
      such that $y'Rz$. Since $Y'âŠ©â–¡c$ then $zâŠ©c$ and thus $xRz$.
    {{{endproof}}}

** The principle \prin{Pâ‚€}

   The \prin{Pâ‚€} principle reads as follows:
   \[A â–· â™¢ B â†’ â–¡ (A â–· B).\]
*** Ordinary semantics
    The $(Pâ‚€)_{ord}$ condition reads as follows:
    \[âˆ€w,x,y,z,u(wRxRyS_wzRuâ‡’yS_xu).\]

   #+caption: Ordinary frame condition for \prin{Pâ‚€}.
   #+name: fig:P_0-ord
   #+attr_latex: :float t :width 0.15\textwidth :placement [H]
   [[file:img/P_0-ord.pdf]]

   {{{begintheorem}}} For any ordinary frame $F$, we have that $F$ satisfies the
   $(Pâ‚€)_{ord}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{Pâ‚€} principle. In symbols:

   \[F âŠ¨ (Pâ‚€)_{ord} â‡” F âŠ© Pâ‚€.\] {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   - \boxed{â‡’} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $wâŠ©Aâ–·â™¢B$ and that there is a world $x$ such that $wRx$. Our goal is to
     show that $xâŠ©Aâ–·B$. Consider a world $y$ such that $xRyâŠ©A$. As $wRy$ and
     $wâŠ©Aâ–·â™¢B$ then there exist some worlds $z,u$ such that $yS_wzRuâŠ©B$. By the
     $(Pâ‚€)_{ord}$ condition it follows that $yS_xu$ and thus $xâŠ©Aâ–·B$.
   - \boxed{â‡} Let $a,bâˆˆVar$ and assume $FâŠ©a â–· â™¢ b â†’ â–¡ (a â–· b)$ and assume that
     $wRxRyS_wzRu$. We want to show $yS_xu$. Consider a model based on $F$ such
     that:
     \begin{flalign*}
     âŸ¦aâŸ§ = \{y \}; \\
     âŸ¦bâŸ§ = \{u \}.
     \end{flalign*}
     Observe that $wâŠ©aâ–·â™¢b$ as the only world that forces $a$ is $y$ and we have
     $yS_wzâŠ©â™¢b$, because $zRuâŠ©b$. Consequently we have $wâŠ©â–¡(aâ–·b)$ and therefore
     $xâŠ©aâ–·b$. Then, since $xRyâŠ©a$ it follows that there exist some $v$ such that
     $yS_xvâŠ©b$, but since $b$ is only forced in $u$, it must be $u=v$ and so
     $yS_xu$.
   {{{endproof}}}

*** Generalized semantics
    The $(P_0)_{gen}$ condition reads as follows:
    \[âˆ€w,x,y,Y,Z((wRxRyS_wY,âˆ€yâˆˆYâˆƒzâˆˆZ(yRz))â‡’âˆƒZ'âŠ†Z(yS_xZ')).\]

   #+caption: Generalized frame condition for \prin{Pâ‚€}.
   #+name: fig:P_0-gen
   #+attr_latex: :float t :width 0.31\textwidth :placement [H]
   [[file:img/P_0-gen.pdf]]


   {{{begintheorem}}} For any generalized frame $F$, we have that $F$ satisfies the
   $(Pâ‚€)_{gen}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{Pâ‚€} principle. In symbols:

   \[F âŠ¨ (Pâ‚€)_{gen} â‡” F âŠ© Pâ‚€.\] {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   - \boxed{â‡’} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $wâŠ©Aâ–·â™¢B$ and that there is a world $x$ such that $wRx$. We aim to show
     that $xâŠ©Aâ–·B$. Assume there is a world $u$ such that $xRuâŠ©A$ and as $wRu$
     and $wâŠ©Aâ–·â™¢B$ then there exists a set $Y$ $uS_xYâŠ©â™¢B$. Let $ğ”¹=\{w:wâŠ©B\}$.
     Then observe that $âˆ€yâˆˆY$ there exists some $zâˆˆğ”¹$ since $YâŠ©â™¢B$. Hence by the
     $(Pâ‚€)_{gen}$ condition there exists some $ğ”¹'âŠ†ğ”¹$ such that $yS_xğ”¹'$. Clearly
     $ğ”¹'âŠ©B$, therefore $xâŠ©Aâ–·B$.
   - \boxed{â‡} Let $a,bâˆˆVar$ and assume $FâŠ©a â–· â™¢ b â†’ â–¡ (a â–· b)$ and assume
     that for some $w,x,y,Y,Z$ we have $wRxRyS_wY$ and $(â‹†)\ âˆ€yâˆˆYâˆƒzâˆˆZ(yRz)$.
     Consider a model based on $F$ such that:
     \begin{flalign*}
    âŸ¦aâŸ§ &= \{y\}; \\
    âŸ¦bâŸ§ &= Z.
     \end{flalign*}
     See that $wâŠ©aâ–·â™¢b$ as the only world that forces $a$ is $y$ and we have
     $yS_wY$ and by $(â‹†)$ it follows that $YâŠ©â™¢b$. Consequently it holds that
     $wâŠ©â–¡(aâ–·b)$ and since $wRx$ then $xâŠ©aâ–·b$. Also, since $xRyâŠ©a$ then there
     exists $Z'$ such that $yS_xZ'âŠ©b$. Clearly $Z'âŠ©b$ implies $Z'âŠ†Z$ so we are
     done.
   {{{endproof}}}

** The principle \prin{R}
   The \prin{R} principle reads as follows:

   \[A â–· B â†’ Â¬ (A â–· Â¬C) â–· (B âˆ§ â–¡ C)\ .\]

   IT WOULD BE NICE IF EACH PRINCIPLE HAS A SHORT DESCRIPTION: WHEN INTRODUCED,
   WHY, BY WHOM, WHY INTERESTING, CURRENT STATUS. WE CAN THINK IF WE DO THIS IN
   ONE SECTION FOR ALL OR EACH TIME WHEN THE PRINCIPLE IS INTRODUCED. OR
   POSSIBLY EVEN A MIXTURE OF BOTH

*** Ordinary semantics
    The $\kord{R}$ condition reads as follows:
    \[âˆ€w,x,y,z\left(wRxRyS_wzâ‡’âˆ€v(zRvâ‡’yS_xv)\right)\ .\]

   #+caption: Ordinary frame condition for \prin{R}.
   #+name: fig:ord-R-condition
   #+attr_latex: :float t :width 0.15\textwidth :placement [H]
   [[file:img/R-ord.pdf]]

   {{{joost(TO NOT OVERLOAD WRITING\, SHALL WE SPEAK OF FRAMES WHEN SPEAKING OF
   REGULAR/ORDINARY FRAMES AND ONLY INDICATE GENERALISED WHERE NEEDED? LUKA\, WHAT
   DO YOU THINK?)}}}

\luka{ I agree, that's what Croatian authors do}


   {{{begintheorem}}}
   For any ordinary frame $F$, we have that $F$ satisfies the
   $\kord{R}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{R} principle. In symbols:

   \[F âŠ¨ \kord{R} â‡” F âŠ© R\ .\]
   {{{endtheorem}}}

{{{joost(HERE AND IN THE THESIS IN GENERAL\, I MISS A DISCUSSION ABOUT
ASSURINGNESS. THIS SHOULD BE ADDED AND USED. AT THIS PARTICULAR POINT IN YOUR
PROOF YOU SHOULD MENTION THAT y IS A C-assuring SUCCESSOR OF x SO THAT YOU
OBTAIN (*).)}}}

{{{luka(Joost\, would you use assuringness/criticality even in semantic
context? I would add a note\, something along the lines of "of course\, we can
associate a MCS with every world of a model\, if we suppose e.g. that all
propositional variables $p_i$ for $i > ...$ are evaluated as false and let $mcs(w) =
\{A : w \Vdash A\}$".)}}}

a world \(y\) such that \(xRyâŠ©A\) and \((â‹†)\ âˆ€v(yS_xvâ‡’vâŠ©C)\).

{{{joost(MAKE THIS FORMULA DISPLAYED. MOREOVER\, IT IS BETTER TO GENERATE A
LABEL. FOR EXAMPLE:)}}}


   {{{beginproof}}}
   {{{agda}}}
   - \boxed{â‡’} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $wâŠ©Aâ–·B$ and that there is a world $x$ such that $wRxâŠ©Â¬(Aâ–·Â¬C)$. We need
     to see that there is some world $v$ such that $xS_wvâŠ©Bâˆ§â–¡C$. From
     $xâŠ©Â¬(Aâ–·Â¬C)$ we get a world $y$ such that $xRyâŠ©A$ and $(â‹†)\ âˆ€v(yS_xvâ‡’vâŠ©C)$.
     Since $wâŠ©Aâ–·B$, and by transitivity we have $wRy$, it follows that there
     exists a world $z$ such that $yS_wzâŠ©B$. To see that $z$ is the desired
     world we first see that $zâŠ©â–¡C$. Let $u$ be such that $zRu$, then by
     $\kord{R}$ it follows that $yS_xu$ and by $(â‹†)$ we get $uâŠ©C$. Finally, we
     have to see that $xS_wz$. Since $wRxRy$ we have that $xS_wy$ and we have
     $yS_wz$ from before, hence by transitivity of $S_w$ we get $xS_wz$.

   To see that \(z\) is the desired world.

   {{{joost(I WOULD SAY HERE: "WE HAVE TO VERIFY
   TWO THINGS". THEN YOU MENTION THE TWO THINGS AND THEN YOU PROVE THEM ONE BY ONE.
   LIKE THIS\, YOU HELP THE NON-EXPERIENCED READER REMIND WHAT IS IT THAT YOU ARE
   AFTER)}}}


   - \boxed{â‡} Let $a,b,câˆˆVar$ and assume that for some $w,x,y,z$ we have
     $wRxRyS_wz$ . Consider a model
     based on $F$ that satisfies the following.
    \begin{flalign*}
     âŸ¦aâŸ§ &= \{y\}; \\
     âŸ¦bâŸ§ &= \{z\}; \\
     âŸ¦câŸ§ &= \{u:yS_xu\}.
    \end{flalign*}
     By assumption we have that $wâŠ©a â–· b â†’ (Â¬ (a â–· Â¬c) â–· (b âˆ§ â–¡ c))$. Clearly
     $wâŠ©aâ–·b$ as we have $yS_wzâŠ©b$. Consequently it holds that $wâŠ©Â¬ (a â–· Â¬c) â–· (b
     âˆ§ â–¡ c)$. In order to show that $xâŠ©Â¬ (a â–· Â¬c)$, considering that $a$ is only
     forced in $y$, it suffices to observe that $âˆ€z(yS_xzâ‡’zâŠ©c)$, which clearly
     holds. Then there must exist some world $v$ such that $xS_wvâŠ©bâˆ§â–¡c$ but
     $v=z$ since $z$ is the only world that forces $b$, hence $xS_wzâŠ©â–¡c$. Now to
     show $âˆ€v(zRvâ‡’yS_xv)$ consider some $v$ such that $zRv$. From $zâŠ©â–¡c$ we get
     $vâŠ©c$ and thus $yS_xv$.
   {{{endproof}}}

*** Generalized semantics

    We first introduce the concept of choice set

   {{{begindef}}} If $xRy$ we say that a set of worlds $K$ is a \gls{choice-set} for
   $âŸ¨x,yâŸ©$ iff for any $V$ such that $yS_xV$ we have $Vâˆ©Kâ‰ âˆ…$. We denote the
   family of choice sets for $âŸ¨x,yâŸ©$ by $ğ’(x,y)$. Note that this definition
   depends on the frame, but it should always be clear from context.
   {{{enddef}}}

    The $R_{gen}$ condition reads as follows:
    \begin{flalign*}
    &âˆ€w,x,y,Y,K(wRxRyS_wY,Kâˆˆğ’(x,y)   \\
    â‡’& âˆƒY'âŠ†Y(xS_wY',âˆ€y'âˆˆY'âˆ€z(y'Rzâ†’zâˆˆK))).
    \end{flalign*}

   #+caption: Generalized frame condition for \prin{R}.
   #+name: fig:gen-R-condition
   #+attr_latex: :float t :width 0.35\textwidth :placement [H]
   [[file:img/R-gen.pdf]]

   {{{begintheorem}}}
   <<theorem:Râ°>>
   For any generalized frame $F$, we have that $F$ satisfies the
   $R_{gen}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{R} principle. In symbols:

   \[F âŠ¨ R_{gen} â‡” F âŠ© R.\]
   {{{endtheorem}}}
   {{{beginproof}}}
   {{{agda}}}
   - \boxed{â‡’} Let $M$ be a model based on $F$ assume there is a world $w$ such
     that $wâŠ©Aâ–·B$ and a world $x$ such that $wRx$ and $xâŠ©Â¬(Aâ–·Â¬C)$. We need to
     show that there is a set $Z$ such that $xS_wZâŠ©Bâˆ§â–¡C$. From $xâŠ©Â¬(Aâ–·Â¬C)$ it
     follows that there is a world $y$ such that $xRyâŠ©A$ and $(â‹†)\
     âˆ€V(yS_xVâ‡’âˆƒcâˆˆV(câŠ©C))$. Consider the set $Kâ‰”\{c:câŠ©C,âˆƒV(câˆˆV,yS_xV)\}$. Clearly
     by $(â‹†)$ it follows that $K$ is a choice set for $âŸ¨x,yâŸ©$. By transitivity
     of $R$ we get $wRy$ and since $wâŠ©Aâ–·B$ then there must exist some $Y$ such
     that $yS_wYâŠ©B$. We can now apply the $R_{gen}$ condition and get a $Y'âŠ†Y$
     such that $xS_wY'$ and $(â€ )\ âˆ€y'âˆˆY'âˆ€z(y'Rzâ†’zâˆˆK)$. To show that $Y'$ is the
     desired set it remains to see that $Y'âŠ©Bâˆ§â–¡C$. From the fact that $Y'âŠ†YâŠ©B$
     it easily follows that $Y'âŠ©B$. Now, let $y'âˆˆY'$ and $u$ such that $y'Ru$,
     from $(â€ )$ we get $uâˆˆK$ and by definition of $K$ we have $uâŠ©C$.
   - \boxed{â‡} Let $a,b,câˆˆVar$ and assume $FâŠ© a â–· b â†’ (Â¬ (a â–· Â¬c) â–· (b âˆ§ â–¡ c))$.
     Assume also that for some $w,x,y,Y,K$ we have $wRxRyS_wY,Kâˆˆğ’(x,y)$. Now
     consider a model based on $F$ that satisfies the following:
    \begin{flalign*}
    âŸ¦aâŸ§ &=\{y\}; \\
    âŸ¦bâŸ§ &=Y; \\
    âŸ¦câŸ§ &= K. \\
    \end{flalign*}
    By assumption we have $wâŠ©a â–· b â†’ (Â¬ (a â–· Â¬c) â–· (b âˆ§ â–¡ c))$. Observe that
     that $wâŠ©aâ–·b$ since $yS_wYâŠ©b$. Thus $wâŠ©Â¬ (a â–· Â¬c) â–· (b âˆ§ â–¡ c)$. Being $y$
     the only world that forces $a$, in order to show $xâŠ©Â¬(aâ–·Â¬c)$ we need to see
     that $âˆ€V(yS_xVâ‡’âˆƒzâˆˆV(zâŠ©c))$, which is equivalent to $âˆ€V(yS_xVâ‡’âˆƒzâˆˆVâˆ©K)$ and
     this holds since $Kâˆˆğ’(x,y)$. As a consequence of $xâŠ©Â¬(aâ–·Â¬c)$ we have that
     there exists a $Y'$ such that $xS_wY'âŠ©bâˆ§â–¡c$. From $Y'âŠ©b$ we get $Y'âŠ†Y$ and
     from $Y'âŠ©â–¡c$ we get $âˆ€y'âˆˆY'(âˆ€z(y'Rzâ†’zâˆˆK))$, hence $Y'$ is the desired set.
   {{{endproof}}}

** The principle \prin{Râ‚}
  The $R_1$ principle reads as follows:
  \[A â–· B â†’ (Â¬(A â–· Â¬C)âˆ§ (Dâ–·â™¢E))â–·(Bâˆ§â–¡Câˆ§(Dâ–·E)).\]

*** Ordinary semantics

    The $\kord{R_1}$ frame condition reads as follows:
    \[âˆ€w,x,y,z(wRxRyS_wzâ‡’âˆ€u(zRuâ‡’yS_xu,âˆ€v(uS_xvâ‡’âˆ€m(vRmâ‡’uS_zm))))\]

    # #+caption: Ordinary frame condition for \prin{Râ‚}
    # #+name: fig:ord-Râ‚-condition
    # #+attr_latex: :float t :width 0.20\textwidth :placement [H]
    # [[file:img/wip.png]]

    {{{begintheorem}}}
    For any ordinary frame $F$, we have that $F$ satisfies the
    $\kord{R_1}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{Râ‚} principle. In symbols:

    \[F âŠ¨ \kord{R_1} â‡” F âŠ© Râ‚.\]
    {{{endtheorem}}}

    {{{beginproof}}}
    The details of the proof can be found in cite:two-new-series.
    # - \boxed{â‡} Let $a,b,c,d,eâˆˆVar$ and assume $FâŠ© a â–· b â†’ ((Â¬ (a â–· Â¬c) âˆ§(dâ–·â™¢e))
    #   â–· (b âˆ§ â–¡ c âˆ§ (dâ–·e)))$. Consider some worlds $w,x,y,z,u,v,m$ and assume for
    #   a contradiction that $wRxRyS_wzRu,yS_xuâ‡’(uS_xv,vRm,u\cancel{S}_zm)$. Now
    #   consider a model based on $F$ that satisfies the following:
    #   \begin{flalign*}
    #   âŸ¦aâŸ§ &= \{y\} \\
    #   âŸ¦bâŸ§ &= \{z\} \\
    #   âŸ¦câŸ§ &= \{w:yS_xw\} \\
    #   âŸ¦dâŸ§ &= \{?\} \\
    #   âŸ¦eâŸ§ &= \{?\} \\
    #   \end{flalign*}
    #   First observe that $wâŠ©aâ–·b$ since $a$ is only forced in $y$ and we have
    #   $yS_wzâŠ©b$. Therefore $wâŠ©Â¬ (a â–· Â¬c) âˆ§(dâ–·â™¢e) â–· (b âˆ§ â–¡ c âˆ§ (dâ–·e))$. Now we
    #   show that $xâŠ©Â¬ (a â–· Â¬c)$. Since $a$ is only forced in $y$ and $xRy$, we
    #   need to show that $âˆ€u(yS_xuâ‡’uâŠ©c)$, which clearly holds. We proceed by
    #   showing $xâŠ©dâ–·â™¢e$ (????).
    # - \boxed{â‡’} Let $M$ be a model based on $F$ assume there is a world $w$ such
    #   that $wâŠ©Aâ–·B$ and a world $x$ such that $wRx$ and $xâŠ©Â¬(Aâ–·Â¬C)âˆ§(Dâ–·â™¢E)$. Then
    #   there exists world $y$ such that $xRyâŠ©A$ and $(â‹†)\ âˆ€v(yS_xvâ‡’vâŠ©C)$. As
    #   $wRyâŠ©A$ and $wâŠ©Aâ–·B$ there exists a world $z$ such that $yS_wzâŠ©B$. It
    #   remains to show that $zâŠ©â–¡Câˆ§(Dâ–·E)$. We first see that $zâŠ©â–¡C$. Consider
    #   $v$ such that $zRv$, by $\kord{R_1}$ it follows that $yS_xv$ and by $(â‹†)$
    #   we get $vâŠ©C$. Now we show $zâŠ©Dâ–·E$. Let $u$ be such that $zRuâŠ©D$, we need
    #   to find some $m$ such that $uS_zmâŠ©E$. By $\kord{R_1}$ we get $yS_xu$ and
    #   $(â€ )\ âˆ€v,m((uS_xv,vRm)â‡’uS_zm)$. See that $yS_xu$ implies $xRu$ and since
    #   $xâŠ©Dâ–·â™¢E$ and $uâŠ©D$ we get that there is some $n$ such that $uS_xnâŠ©â™¢E$.
    #   Hence there is a world $m$ such that $nRmâŠ©E$. Finally by $(â€ )$ and $uS_xn$
    #   and $nRm$ we get $uS_zm$ and thus we have the desired $m$ and we conclude
    #   $zâŠ©Dâ–·E$.
    {{{endproof}}}

*** Generalized semantics
    Some definitions:
    1. $R^{-1}[E] â‰” \{x : âˆƒyâˆˆE. xRy\}$. $E$ denotes a set.
    2. $Râ‚“^{-1}[E]â‰”R^{-1}[E]âˆ©R[x]$. $E$ denotes a set.


    The $(R_1)_{gen}$ condition reads as follows:
    \begin{flalign*}
    &âˆ€w,x,u,ğ”¹,â„‚,ğ”¼(wRxRuS_wğ”¹, â„‚âˆˆğ’(x,u) \\
    â‡’\ & (âˆƒğ”¹'âŠ†ğ”¹)(xS_wğ”¹',R[ğ”¹']âŠ†â„‚,(âˆ€vâˆˆğ”¹')(âˆ€câˆˆâ„‚)(vRcSâ‚“Râ‚“^{-1}[ğ”¼]â‡’(âˆƒğ”¼'âŠ†ğ”¼)cS_vğ”¼')))
    \end{flalign*}
    \begin{flalign*}
    &âˆ€w,x,u,ğ”¹,â„‚,ğ”¼(wRxRuS_wğ”¹, â„‚âˆˆğ’(x,u) \\
    â‡’\ & (âˆƒğ”¹'âŠ†ğ”¹)(xS_wğ”¹',R[ğ”¹']âŠ†â„‚,(âˆ€vâˆˆğ”¹')(âˆ€câˆˆâ„‚)(âˆƒUâŠ†Râ‚“^{-1}[ğ”¼],vRcSâ‚“U)â‡’(âˆƒğ”¼'âŠ†ğ”¼)cS_vğ”¼')))
    \end{flalign*}

    {{{begintheorem}}}
    <<theorem:Râ‚>>
    For any generalized frame $F$, we have that $F$ satisfies the
    $(Râ‚)_{gen}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{Râ‚} principle. In symbols:

    \[FâŠ¨(Râ‚)_{gen}â‡”FâŠ©Râ‚.\]
    {{{endtheorem}}}

    {{{beginproof}}}
    {{{agda}}}
    - \boxed{â‡’} Let's fix the model and let $w âˆˆ W$ be arbitrary. Suppose $wâŠ© A
      â–·B$, and let $x$ be such that $wRx$ and $xâŠ© Â¬(A â–· Â¬C) âˆ§ (D â–· â™¢E)$. It
      follows from $x âŠ©Â¬(A â–·Â¬C)$ that there exists $u$ such that $xRu$, such
      that $uâŠ©A$, and for every $Z$ such that $uS_x Z$ there is some $c_Z âˆˆ Z$
      such that $c_Z âŠ©C$. From $wRu$, $wâŠ© Aâ–· B$ and $uâŠ© A$ follows in particular
      that there is a $ğ”¹$, $uS_w ğ”¹ âŠ©B$. Let $â„‚ â‰” \{c_Z: uS_x Z\}$. It is easy to
      check that $â„‚ âˆˆ ğ’(x, u)$. Let $ğ”¼ â‰” [âŠ©E]$ (set of worlds that force $E$).
      For the selected $w, x, u, ğ”¹, â„‚, ğ”¼$ the property $(R 1)_{gen}$ implies
      that there exists $ğ”¹' âŠ† ğ”¹$ such that:

      \[xS_wğ”¹',R[ğ”¹']âŠ†â„‚ ,(âˆ€vâˆˆğ”¹')(âˆ€câˆˆâ„‚)(vRcS_xR_x^{-1}[ğ”¼]â‡’(âˆƒğ”¼'âŠ†ğ”¼)cS_vğ”¼').\]

      We have that $ğ”¹' âŠ©B$ since $ğ”¹'âŠ†ğ”¹$ and $ğ”¹'âŠ©â–¡ C$ since $R[ğ”¹']âŠ†â„‚$. We now show
      that $ğ”¹'âŠ© Dâ–· E$. Assume that for some $c âˆˆ R [ğ”¹']$ we have $câŠ© D$. From
      earlier we have $xâŠ© D â–· â™¢E$. Since $c âˆˆ R [ğ”¹ '] âŠ† C âŠ† R [x]$, then $xRc$ so
      it follows that there exists $U$ such that $cS_x U$ and $UâŠ©â™¢E$. Clearly
      $UâŠ†[â™¢E]_x$ and also $[â™¢E]_xâŠ†R[x]$, hence by monotonicity we have
      $cS_x[â™¢E]_x$ which is the same as $cS_x R_x^{âˆ’1}[ğ”¼]$ so by the above
      property there exists $ğ”¼'âŠ†ğ”¼$ such that $cS_v ğ”¼'$. Because $ğ”¼'âŠ†ğ”¼$ we have
      $ğ”¼'âŠ©E$.
    - \boxed{â‡} Assume for a contradiction that $FâŠ­(Râ‚)_{gen}$. It follows that
      there exist $w,x,u,ğ”¹,â„‚,ğ”¼$ such that $wRxRuS_wğ”¹$, $â„‚âˆˆğ’(x,u)$ and:
      \[(âˆ€ğ”¹'âŠ†ğ”¹)\left(xS_wğ”¹', R[ğ”¹']âŠ†â„‚â‡’ (âˆƒvâˆˆğ”¹')(âˆƒcâˆˆâ„‚)(âˆƒZâŠ†R_x^{-1}[ğ”¼].vRcS_xZ,âˆ€ğ”¼'âŠ†ğ”¼.
      c\cancel{S}_v ğ”¼')\right).\]

      Let $ğ’±$ be a family of sets defined thus:
      \[ğ’±â‰” \{U : UâŠ†ğ”¹, xS_wU,R[U]âŠ†â„‚\}.\]

      From the condition it follows that for every $Uâˆˆğ’±$ the following is valid:
      \[(âˆƒv_UâˆˆU)(âˆƒc_Uâˆˆâ„‚)(âˆƒZ_UâŠ†R_x^{-1}[ğ”¼](v_URc_US_xZ_U,(âˆ€ğ”¼'âŠ†ğ”¼) c_U\cancel{S}_{v_U} ğ”¼')).\]

      Let us fix such $v_U$ and $c_U$ and $Z_U$ for all $Uâˆˆğ’±$.

      Define a valuation such that the following applies:
      \begin{flalign*}
      âŸ¦aâŸ§ &= \{u\}; \\
      âŸ¦bâŸ§ &= ğ”¹; \\
      âŸ¦câŸ§ &= â„‚; \\
      âŸ¦dâŸ§ &= \{c_U:Uâˆˆğ’±\}; \\
      âŸ¦eâŸ§ &= ğ”¼.
      \end{flalign*}

      By assumption we have $w âŠ© a â–· b â†’ (Â¬(aâ–·Â¬c)âˆ§(dâ–·â™¢e))â–·(bâˆ§â–¡câˆ§(dâ–·e))$.

      It is easy to see that $w âŠ© a â–· b$ and $x âŠ© Â¬(a â–· Â¬c)$.

      Let us prove $x âŠ© dâ–·â™¢e$. Let $xRcâŠ© D$. Then $c = c_U$ for some $U âˆˆ ğ’±$.
      From the definition of $c_U$ we have $c_U S_x Z_U$, a forcing is defined
      such that $e$ is true exactly on the set $ğ”¼$. Hence $R_x^{-1}[ğ”¼]âŠ©â™¢e$ and
      since $Z_UâŠ†R_x^{-1}[ğ”¼]$ it follows that $x âŠ© dâ–·â™¢e$.

      We can also check that for $U âˆˆ ğ’±$ we have $UâŠ© b âˆ§ â–¡c$ and the following
      following condition holds for any set $U$:
      \begin{flalign*}
        (â‹†)\ xS_wU ,UâŠ© b âˆ§ â–¡câ‡’Uâˆˆ ğ’±.
      \end{flalign*}
      Then since $wâŠ©aâ–·b$ and $wRxâŠ©(aâ—c)âˆ§(dâ–·â™¢e)$ there must exist some set $U$
      such that $xS_wUâŠ©bâˆ§â–¡câˆ§(dâ–·e)$. From $(â‹†)$ follows that that $Uâˆˆğ’±$ hence
      there exist $v_U,c_U,Z_U$ such that $Z_UâŠ†R_x^{-1}[ğ”¼]$ and
      $v_URc_US_xZ_U,(âˆ€ğ”¼'âŠ†ğ”¼) c_U\cancel{S}_{v_U} ğ”¼'$. Since $c_UâŠ©d$ there must
      exist some $Y$ such that $c_US_{v_U}YâŠ©e$, however, by the definition of
      the valuation it follows that $YâŠ†ğ”¼$ and thus $c_U\cancel{S}_{v_U} Y$,
      which is a contradiction.

    {{{endproof}}}

# \newpage
** The principle \prin{R_2} :noexport:
  The \prin{R_2} principle reads as follows:
  \[Aâ‚€ â–· (Bâ‚€ âˆ§ (Aâ‚ â–· Bâ‚)) â†’ Â¬(Aâ‚€ â–· Â¬Câ‚€)âˆ§ (Eâ‚â–·Â¬(Aâ‚â–·Â¬Câ‚))â–· Bâ‚€âˆ§(Aâ‚â–·Bâ‚)âˆ§â–¡Câ‚€âˆ§(Eâ‚â–·Aâ‚)âˆ§(Eâ‚â–·Bâ‚âˆ§â–¡Câ‚)\]

*** Generalized semantics
    Some definitions:

    The $(R_2)_{gen}$ condition reads as follows:
    \begin{flalign*}
    &âˆ€w,x,u,ğ”¹,â„‚,ğ”¼(wRxRuS_wğ”¹, â„‚âˆˆğ’(x,u) \\
    â‡’\ & (âˆƒğ”¹'âŠ†ğ”¹)(xS_wğ”¹',R[ğ”¹']âŠ†â„‚,(âˆ€vâˆˆğ”¹')(âˆ€câˆˆâ„‚)(vRcSâ‚“Râ‚“^{-1}[ğ”¼]â‡’(âˆƒğ”¼'âŠ†ğ”¼)cS_vğ”¼')))
    \end{flalign*}
    \begin{flalign*}
    &âˆ€w,x,u,ğ”¹,â„‚,ğ”¼(wRxRuS_wğ”¹, â„‚âˆˆğ’(x,u) \\
    â‡’\ & (âˆƒğ”¹'âŠ†ğ”¹)(xS_wğ”¹',R[ğ”¹']âŠ†â„‚,(âˆ€vâˆˆğ”¹')(âˆ€câˆˆâ„‚)(âˆƒUâŠ†Râ‚“^{-1}[ğ”¼],vRcSâ‚“U)â‡’(âˆƒğ”¼'âŠ†ğ”¼)cS_vğ”¼')))
    \end{flalign*}

    {{{begintheorem}}}
    <<theorem:Râ‚‚>>
    For any generalized frame $F$, we have that $F$ satisfies the
    $(Râ‚‚)_{gen}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{R_2} principle. In symbols:

    \[FâŠ¨(Râ‚‚)_{gen}â‡”FâŠ©Râ‚‚\]
    {{{endtheorem}}}

    {{{beginproof}}}
    {{{endproof}}}

# \newpage

** The principle \prin{RÂ¹}

   The \prin{RÂ¹} principle reads as follows:
   \[A â–· B â†’ (â™¢Â¬(D â–· Â¬C)âˆ§ (Dâ–·A))â–·(Bâˆ§â–¡C).\]

*** Generalized semantics
    The $\kgen{RÂ¹}$ condition reads as follows:
    \begin{flalign*}
    &âˆ€w,x,y,z,ğ”¸,ğ”¹,â„‚,ğ”». \\
    &wRxRyRz, \\
    & (âˆ€u.wRu,uâˆˆğ”¸â‡’âˆƒV.uS_wV,VâŠ†ğ”¹), \\
    & (âˆ€u.xRu,uâˆˆğ”»â‡’âˆƒV.uS_xV,VâŠ†ğ”¸), \\
    & (âˆ€V.zS_yVâ‡’âˆƒvâˆˆV.vâˆˆâ„‚),      \\
    & zâˆˆğ”» \\
    â‡’\ & âˆƒVâŠ†ğ”¹(xS_wV,R[V]âŠ†â„‚).
    \end{flalign*}

    {{{begintheorem}}}
    For any generalized frame $F$, we have that $F$ satisfies the
    $\kgen{RÂ¹}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{RÂ¹} principle. In symbols:

    \[FâŠ¨\kgen{RÂ¹}â‡”FâŠ©RÂ¹.\]
    {{{endtheorem}}}


    {{{beginproof}}}
    {{{agda}}}
    - \boxed{â‡’} Fix a model $M$ and a world $w$, we are to prove that $wâŠ©A â–· B â†’
      (â™¢Â¬(D â–· Â¬C)âˆ§ (Dâ–·A))â–·(Bâˆ§â–¡C)$. For that assume that $wâŠ©Aâ–·B$ and that for some
      $x,y,z$ we have $wRxRyRz$ and $xâŠ©Dâ–·A$, $yâŠ©Â¬(Dâ–·Â¬C)$, $zâŠ©D$. Now let
      $ğ”¸â‰”\{w:wâŠ©A\}$. We define $ğ”¹,â„‚,ğ”»$ likewise for formulas $B,C,D$ respectively.
      It is routine to check that the left part of the implication of $\kgen{RÂ¹}$
      is met. Hence there exist a set $VâŠ†ğ”¹$ such that $xS_wV$ and $R[V]âŠ†â„‚$. By the
      definition of the sets $ğ”¹$ and $â„‚$ it follows that $VâŠ©Bâˆ§â–¡C$.
    - \boxed{â‡} Fix a frame $F$ and let $a,b,c,d$ be propositional variables and
      assume $FâŠ©a â–· b â†’ (â™¢Â¬(d â–· Â¬c)âˆ§ (dâ–·a))â–·(bâˆ§â–¡c)$. Assume that the left part
      of the implication of $\kgen{RÂ¹}$ holds. Now consider a model extending
      $F$ such that:
      \begin{flalign*}
       âŸ¦aâŸ§ &= ğ”¸; \\
       âŸ¦bâŸ§ &= ğ”¹; \\
       âŸ¦câŸ§ &= â„‚; \\
       âŸ¦dâŸ§ &= ğ”».
      \end{flalign*}
      Now one can easily check that $wâŠ©Aâ–·B$, $xâŠ©â™¢Â¬(Dâ–·Â¬C)âˆ§(Dâ–·A)$, hence there exists $U$
      such that $xS_wU$ and $UâŠ©Bâˆ§â–¡C$. From that we derive that $UâŠ†ğ”¹$ and $R[U]âŠ†â„‚$.
    {{{endproof}}}

** The principle $\prin{RÂ²}$ :noexport:

   The $RÂ²$ principle reads as follows:
   \[A â–· B â†’ (â™¢ [(E â–· D) âˆ§ â™¢ Â¬ (E â–· Â¬ C)] âˆ§ (D â–· A)) â–· (B âˆ§ â–¡ C) \]

*** Generalized semantics
    The $(RÂ²)_{gen}$ condition reads as follows:
    \begin{flalign*}
    &âˆ€w,x,y,z,s,ğ”¸,ğ”¹,â„‚,ğ”»,ğ”¼.\\
    &wRxRyRzRs, \\
    & (âˆ€u.wRuâˆˆğ”¸â‡’âˆƒV.uS_wVâŠ†ğ”¹), \\
    & (âˆ€u.xRuâˆˆğ”»â‡’âˆƒV.uS_xVâŠ†ğ”¸), \\
    & (âˆ€u.yRuâˆˆğ”¼â‡’âˆƒV.uS_yVâŠ†ğ”»), \\
    & (âˆ€V.sS_zVâ‡’Vâˆ©â„‚â‰ 0),      \\
    & sâˆˆğ”» \\
    â‡’\ & âˆƒVâŠ†ğ”¹.xS_wV,R[V]âŠ†â„‚
    \end{flalign*}

    {{{begintheorem}}}
    For any generalized frame $F$, we have that $F$ satisfies the
    $(RÂ²)_{gen}$ condition iff any model based on $F$ forces every instantiation of
    the $RÂ²$ principle. In symbols:

    \[FâŠ¨(RÂ²)_{gen}â‡”FâŠ©RÂ²\]
    {{{endtheorem}}}

    {{{beginproof}}}
    - \boxed{â‡’} Fix a model and assume that for some world $w$ we have $wâŠ©Aâ–·B$.
      Consider some $x$ such that $wRxâŠ©â™¢ [(E â–· D) âˆ§ â™¢ Â¬ (E â–· Â¬ C)] âˆ§ (D â–· A)$.
      Hence there exists some $y$ such that $xRyâŠ©(E â–· D) âˆ§ â™¢ Â¬ (E â–· Â¬ C)$. It
      follows that there exists some $z$ such that $yRzâŠ© Â¬ (E â–· Â¬ C)$ and thus
      there exists some $s$ such that $zRsâŠ©E$ and $(â‹†)\ âˆ€V(sS_zVâ‡’âˆƒcâˆˆV(câŠ©C))$.
    - \boxed{â‡}
    {{{endproof}}}

** The principle \prin{Râ¿}
   The \prin{R^n} principle is defined thus cite:two-new-series:
   \begin{flalign*}
   U_0 &â‰” â™¢Â¬(D_0â–·Â¬C) \\
   U_{r+1} &â‰” â™¢((Dáµ£â–·D_{r+1}) âˆ§ Uáµ£) \\
   \\
   Râ°& â‰” A â–· B â†’ Â¬ (A â–· Â¬ C) â–· B âˆ§ â–¡ C \\
   R^{n+1}& â‰” A â–· B â†’ ((D_{n}â–·A) âˆ§ U_{n}) â–· B âˆ§ â–¡ C
   \end{flalign*}
*** Ordinary semantics
    The frame condition for ordinary semantics $\kord{R^n}$ can be found in
    cite:two-new-series.

*** Generalized semantics
    The $\kgen{Râ¿}$ condition reads as follows:
    \begin{flalign*}
    &âˆ€w,xâ‚€,â€¦,x_{n-1},y,z,ğ”¸,ğ”¹,â„‚,ğ”»â‚€,â€¦,ğ”»_{n-1}.\\
    &wRx_{n-1}Râ€¦Rx_0RyRz, \\
    & (âˆ€u.wRu,uâˆˆğ”¸â‡’âˆƒV.uS_wVâŠ†ğ”¹), \\
    & (âˆ€u.x_{n-1}Ruâˆˆğ”»_{n-1}â‡’âˆƒV.uS_{x_{n-1}}VâŠ†ğ”¸), \\
    & (âˆ€iâˆˆ\{1â€¦n-1\}âˆ€u.xáµ¢Ruâˆˆğ”»_iâ‡’âˆƒV.uS_{x_i}VâŠ†ğ”»_{i+1}), \\
    & (âˆ€V.zS_yVâ‡’Vâˆ©â„‚â‰ 0),      \\
    & zâˆˆğ”»â‚€ \\
    â‡’\ & âˆƒVâŠ†ğ”¹.x_{n-1}S_wV,R[V]âŠ†â„‚.
    \end{flalign*}
    {{{beginlemma}}}
    <<lemma:Râ¿>>
    Let $M$ be a model, let $x$ be a world of $M$ and let $nâˆˆâ„•$. For any $iâ‰¤n$ we have
    that if $M , x âŠ© U_i$ then there exist some worlds $y,z,xâ‚€,â€¦,x_{i}$ such that:
    1. $xáµ¢=x$;
    2. $x_iRâ€¦Rxâ‚€RyRz$;
    3. for all $jâ‰¤i$ we have that $M,x_jâŠ©U_j$;
    4. for all $j<i$ we have that $M,x_jâŠ©D_jâ–·D_{j+1}$;
    5. for all $V$ we have that if $zS_yV$ then $Vâˆ©\{w:M,wâŠ©C\}â‰ âˆ…$;
    6. $M,zâŠ©Dâ‚€$.
    {{{beginproof}}}
    {{{agda}}}

    By induction on $i$.
    - For $i=0$ we have that $xâŠ©â™¢Â¬(Dâ‚€â–·Â¬C)$. It follows that there exists some
      $y$ such that $xRyâŠ©Â¬(Dâ‚€â–·Â¬C)$ and therefore there exists some $z$ such that
      $yRzâŠ©Dâ‚€$ and for any $V$, if $zS_yV$, then $Vâˆ©\{w:M,wâŠ©C\}â‰ âˆ…$. It is clear
      that all claims are met.
    - For $i+1$ we have that $xâŠ©â™¢(D_iâ–·D_{i+1}âˆ§U_i)$. It follows that there
      exists some $x_{i}$ such that $x_iâŠ©D_iâ–·D_{i+1}âˆ§U_i$. By IH there exist
      $y,z,xâ‚€,â€¦,x_{i}$ such that satisfy claims $1â€¦6$. We set $x_{i+1}â‰”x$. It is
      trivial to observe that by using the IH all conditions are met for $i+1$.
    {{{endproof}}}
    {{{endlemma}}}
    {{{begintheorem}}}
    <<theorem:Râ¿>>
    For any generalized frame $F$, we have that $F$ satisfies
    the $\kgen{Râ¿}$ condition iff any model based on $F$ forces every
    instantiation of the \prin{Râ¿} principle. In symbols:

    \[FâŠ¨\kgen{Râ¿}â‡”FâŠ©Râ¿.\]
    {{{endtheorem}}}

    {{{beginproof}}}
    {{{agda}}}

    If $n=0$ we refer to theorem [[theorem:Râ°]]. For $n+1$ proceed as follows.
    - \boxed{â‡’} Fix a model and assume that for some world $w$ we have $wâŠ©Aâ–·B$.
      Then assume also that $wRxâŠ©((Dâ‚™â–·A)âˆ§U_n)$. By lemma [[lemma:Râ¿]] it follows
      that there exist $y,z,xâ‚€,â€¦,x_{n}$ satisfying $1â€¦6$. Then let $ğ”¸â‰”âŸ¦AâŸ§$,
      $ğ”¹â‰”âŸ¦BâŸ§$, $â„‚â‰”âŸ¦CâŸ§$ and for $iâ‰¤n$ let $ğ”»áµ¢â‰”âŸ¦Dáµ¢âŸ§$. It is routine to check that
      the left part of the $(R^{n+1})_{gen}$ holds and thus we get that there exists
      some $VâŠ†ğ”¹$ such that $x_{n}S_wV$ and $R[V]âŠ†â„‚$. Since $VâŠ†ğ”¹$ we have that
      $x_{n}âŠ©B$ and since $R[V]âŠ†â„‚$ we have $x_{n}âŠ©â–¡C$. Finally, since
      $x_{n}=x$ we conclude $xâŠ©Bâˆ§â–¡C$.
    - \boxed{â‡} Fix a frame $F$ and let $a,b,c,dâ‚€,â€¦,dâ‚™$ be propositional
      variables and assume $FâŠ©R^{n+1}$. Assume that the left part of the
      implication of $(R^{n+1})_{gen}$ holds. Now consider a model based on $F$
      that satisfies the following:
      \begin{flalign*}
       âŸ¦aâŸ§ &= ğ”¸; \\
       âŸ¦bâŸ§ &= ğ”¹; \\
       âŸ¦câŸ§ &= â„‚; \\
       âŸ¦dáµ¢âŸ§ &= ğ”»áµ¢, \text{ for all } iâˆˆ\{0â€¦n\}.
      \end{flalign*}
      Now one can routinely check that $wâŠ©Aâ–·B$ and $xâŠ©((D_nâ–·A)âˆ§U_n)$, hence there
      exists $U$ such that $xS_wU$ and $UâŠ©Bâˆ§â–¡C$. From that we derive that $UâŠ†ğ”¹$
      and $R[U]âŠ†â„‚$.
    {{{endproof}}}

** The principle \prin{Râ‚™}
   The $R_n$ principle is defined thus cite:two-new-series:
   \begin{flalign*}
   wip
   \end{flalign*}

   \newpage
** Generic generalized frame condition
   In this section we present a method that given a formula $A$, builds a (second
   order?) formula that is a generalized frame condition for $A$.

   {{{begindef}}} Given a generalized frame $F=âŸ¨W,R,SâŸ©$ and a formula $A$ with
   $Var(A)=xâ‚,â€¦,xâ‚™$. Let $â„±$ be defined by (we write $ğ•_*$ instead of $ğ•â‚,â€¦,ğ•â‚™$).
 \begin{flalign*}
   â„±&:\underbrace{ğ’«(W)Ã—â‹¯Ã—ğ’«(W)}_nÃ—Fmâ†’ğ’«(W) \\
   â„±(ğ•_*,xáµ¢) &â‰”  ğ•áµ¢;\\
   â„±(ğ•_*,âŠ¥) &â‰” âˆ…; \\
   â„±(ğ•_*,Aâ†’B) &â‰” \{w:w âˆˆ â„±(ğ•_*,A) â‡’ w âˆˆ â„±(ğ•_*,B)\}; \\
   â„±(ğ•_*,Aâ–·B) &â‰” \{w:âˆ€ u.(wRu,uâˆˆâ„±(ğ•_*,A))â‡’âˆƒY.uS_wYâŠ†â„±(ğ•_*,B))\}. \\
 \end{flalign*}

   Then define
   \[(A)^*_{gen}â‰”âˆ€ğ•_*âˆ€wâˆˆW.wâˆˆâ„±(ğ•_*,A). \]

   {{{enddef}}}

   {{{begintheorem}}}

   Let $A$ be a formula. For any generalized frame $F$, we have that $F$
   satisfies the $(A)^*_{gen}$ condition iff any model based on $F$ forces $A$.
   In symbols:

     \[FâŠ¨(A)^*_{gen}â‡”FâŠ©A.\]
   {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   {{{endproof}}}

   {{{beginremark}}}
   For instance, if we want the frame condition for \prin{Pâ‚€} we look at
    \[(a â–· â™¢ b â†’ â–¡ (a â–· b))^*_{gen}.\]
    where $a,b$ are different variables.
   {{{endremark}}}
* The logic of Agda
  # Adapted from cite:norell:thesis (Section 1.3).

  In this section we give an informal overview of the basic constructions on
  Agda that will hopefully help the reader get an intuition of how dependent
  types can be used to proof mathematical properties. We will also highlight
  some intricacies of the language that are relevant to our project. This is not
  meant to be an exhaustive analysis on the inner workings of Agda, as this
  falls out of the scope of this project. The original author of Agda, Ulf
  Norell, has suggested cite:cockx2018elaborating as a good reference for that
  matter.

** BHK interpretation of propositional logic
  As Agda is based on an intuitionistic type theory we believe that a good way
  to start the introduction is through the BHK interpretation
  (cite:sep-intuitionistic-logic-development) of intuitionistic logic. We start
  with propositional logic and later on (Section [[sec:bhk-fol]]) we introduce first
  order logic.

  The BHK interpretation states that:
  1. A proof of $Aâ†’B$ is an algorithm that transforms a proof of $A$ into a proof
     of $B$;
  2. A proof of $Aâˆ§B$ is a proof of $A$ and a proof of $B$;
  3. A proof of $Aâˆ¨B$ is a proof of $A$ or a proof of $B$;
  4. Nothing is a proof of $âŠ¥$.
  5. $âŠ¤$ is always true.

  According to the interpretation a proof of $Aâ†’A$ is just the identity
  function. We can express this in Agda by writing the identity lambda term:
  #+begin_src text
  (Î» a â†’ a)
  #+end_src
  The previous term is valid. However, in Agda we must give a name to all the
  terms that we define so we can refer to them in other parts of our code.
  We will name our term =id=:
  #+begin_src text
  id = Î» a â†’ a
  #+end_src
  When the term that we are defining is a function, we are allowed to move the
  arguments to the left of the === sign. Furthermore, we should write the type of
  the function using the =:= symbol. We use the symbol =â†’= for functions.
  #+begin_src text
  id : A â†’ A
  id a = a
  #+end_src
  The previous function is only valid if the type =A= has been defined. Since
  our intention is that it should work for any type, we should rewrite it to be
  polymorphic. We can do that by declaring a type variable =A=.
  #+begin_src text
  id : (A : Set) â†’ A â†’ A
  id A a = a
  #+end_src
  Since the value of =A= will always be the type of the second argument, we can
  infer its value and thus it is recommended to use an implicit argument (see
  Section [[sec:agda-implicit-args]]).
  #+begin_src text
  id : {A : Set} â†’ A â†’ A
  id a = a
  #+end_src
  With the technicalities out of the way, we can finally say that we have
  completed our first Agda proof according to the BHK interpretation. Let us see
  another example involving functions[fn::The =â†’= function symbol has right
  associativity.].
  #+begin_src text
  commute : {A B C : Set} â†’ (A â†’ B â†’ C) â†’ B â†’ A â†’ C
  commute f b a = f a b
  #+end_src

  Let us now put our attention on proofs that revolve around conjunction. For
  instance, let us prove that $Aâˆ§ B â†’ B âˆ§ A$. In order to represent $Aâˆ§B$ in
  Agda we need to define a so called /product type/. A product type is in rough
  terms a tuple. Consider the following pair definition:
  #+begin_src text
data _Ã—_ (A B : Set) : Set where
  _,_ : A â†’ B â†’ A Ã— B
  #+end_src
  This definition defines a new type called =_Ã—_= with parameters =(A B : Set)=.
  Datatypes with parameters are called parameterized datatypes. Parameters are
  shared among all constructors. It has a single constructor named =_,_=.
  Underscores are used to denote infix operators. We see that the type of the
  constructor =_,_= is =A â†’ B â†’ A Ã— B=. This tells us that =_,_= is a function
  that takes an argument of type =A= (or a proof of =A=), an argument of type
  =B= and then returns a term of type =A Ã— B=. Constructors are a special kind
  of functions that are used to build terms of their corresponding datatype.
  When we /pattern match/ (or deconstruct) a term we will have a case for each
  possible constructor of the type of that term.

  Let us give a proof of the theorem $Aâˆ§ B â†’ B âˆ§ A$:
  #+begin_src text
  swap : {A B : Set} â†’ A Ã— B â†’ B Ã— A
  swap (a , b) = b , a
  #+end_src
  Note that we used pattern matching deconstruct the term and access the
  components of the pair. For the =_Ã—_= type we only have one constructor so we
  only need one case.
  # Refer to Section [[sec:agda-datatype]] for more details on data type definition
  # and pattern matching.

  Let us show some more examples[fn::The =_= characters means that these
  definitions are not named and thus cannot be referred to from other parts of
  the code. This is not relevant here as they are just examples.][fn::Notice
  that for function application in Agda we write =f a b=.]:
  #+begin_src text
  p1 : {A B : Set} â†’ A â†’ B â†’ A Ã— B
  p1 a b = a , b

  p2 : {A B : Set} â†’ A Ã— B â†’ A
  p2 (a , b) = a

  p3 : {A B C : Set} â†’ (A â†’ B â†’ C) â†’ A Ã— B â†’ C
  p3 f (a , b) = f a b
  #+end_src
  Now that we are familiarized with conjunction and product types we can proceed
  by exploring disjunction. In order to express options we can define a new data
  type called sum type/ thus:
  #+begin_src text
data _âŠ_ (A B : Set) : Set where
  injâ‚ : A â†’ A âŠ B
  injâ‚‚ : B â†’ A âŠ B
  #+end_src
  We see that the main difference with respect to the pair type is that now we
  have two constructors named =injâ‚= and =injâ‚‚=. The constructor =injâ‚= is used
  to build a proof of =A âŠ B= by providing a proof of =A=. The constructor
  =injâ‚‚= has the analogous functionality for =B=.

  Since we have two constructors, when pattern matching against an argument of
  this type we will need to define two cases (if we want to access its
  contents). See as an example the following theorems:
  #+begin_src text
  p1: {A B : Set} â†’ A âŠ B â†’ B âŠ A
  p1 (injâ‚ a) = injâ‚‚ a
  p1 (injâ‚‚ b) = injâ‚ b

  p2 : {A B : Set} â†’ A âŠ B â†’ (A â†’ C) â†’ (B â†’ C) â†’ C
  p2 (injâ‚ a) f g = f a
  p2 (injâ‚‚ b) f g = g b
  #+end_src

  The reader may have raised the following question in their mind: what if we
  leave out a case for the sum type? In other words, is the following
  definition acceptable?
  #+begin_src text
  wrong : {A B : Set} â†’ A âŠ B â†’ A
  wrong : (injâ‚ a) = a
  #+end_src
  The answer is no. Agda rejects it as it requires all of the definitions to be
  exhaustive, otherwise it would not be a sound system.

  We proceed with $âŠ¥$. We can define a datatype which we call /bottom type/ or
  /empty type/.
  #+begin_src text
  data âŠ¥ : Set where
  #+end_src
  Notice that =âŠ¥= has no constructors and hence it is impossible to construct a term
  with type =âŠ¥=. The bottom type is specially useful to define negation:
  #+begin_src text
  Â¬ : Set â†’ Set
  Â¬ A = A â†’ âŠ¥
  #+end_src
  The principle of explosion can be trivially proved as shown below. Agda uses
  =()= to denote the empty or impossible pattern.
  #+begin_src text
  explosion : {A : Set} â†’ âŠ¥ â†’ A
  explosion ()
  #+end_src
  As we are in an intuitionistic logic the following properties are not provable:
  #+begin_src text
  Â¬Â¬elim : {A : Set} â†’ Â¬ (Â¬ A) â†’ A
  Â¬Â¬elim = ?             -- not provable

  excluded-middle : {A : Set} â†’ A âŠ (Â¬ A)
  excluded-middle = ?    -- not provable
  #+end_src
  However, we can show the following:
  #+begin_src text
  Â¬Â¬Â¬elim : {A : Set} â†’ Â¬ (Â¬ (Â¬ A)) â†’ Â¬ A
  Â¬Â¬Â¬elim Â¬Â¬Â¬a a = Â¬Â¬Â¬a (Î» Â¬a â†’ Â¬a a)
  #+end_src
  It might help the reader to see that =Â¬ (Â¬ (Â¬ A)) â†’ Â¬ A = (((A â†’ âŠ¥) â†’ âŠ¥) â†’ âŠ¥)
  â†’ A â†’ âŠ¥=.

  Some more examples:
  #+begin_src text
  p1 : {A B : Set} A â†’ Â¬ A â†’ B
  p1 a Â¬a = explosion (Â¬a a)
  #+end_src

  We finally climb to the $âŠ¤$. We shall define a datatype which we call the
  /unit type/ or /singleton type/.
  #+begin_src text
  data âŠ¤ : Set where
    tt : âŠ¤
  #+end_src
  We see that this type has a single constructor with no parameters, hence there
  only exists one term with this type, namely =tt=. An example:
  #+begin_src text
  âŠ¤âŠ¤ : âŠ¤ Ã— âŠ¤
  âŠ¤âŠ¤ = tt , tt
  #+end_src
  This concludes the first part of the introduction.

** Booleans and case analysis
   The /true or false/ concept is ubiquitous in computer science and in logic.
   In Agda we can define the =Bool= type in a similar fashion to the disjunction
   type we defined before.
   #+begin_src text
   data Bool : Set where
     true : Bool
     false : Bool
   #+end_src
   Let us define the =not= and =and= Boolean operators using pattern matching:
   #+begin_src text
   not : Bool â†’ Bool
   not false = true
   not true = false

   and : Bool â†’ Bool â†’ Bool
   and false b = false
   and true b = b
   #+end_src
   We proceed by defining equality for the =Bool= type[fn::This definition is
   just for illustrative purposes. It is possible to define polymorphic equality
   but it falls out of the scope of this short introduction.]. We use the symbol
   =â‰¡= because === is reserved for Agda.
   #+begin_src text
data _â‰¡_ : Bool â†’ Bool â†’ Set where
  tâ‰¡t : true â‰¡ true
  fâ‰¡f : false â‰¡ false
   #+end_src
   We see that the type of =_â‰¡_= is =Bool â†’ Bool â†’ Set=. We say that =_â‰¡_= is an
   /indexed datatype/, in this case with two =Bool= indices. In contrast to
   parameters (recall the definitions of =_Ã—_= and =_âŠ_=) which are shared among
   all constructors, indices are specified on a constructor basis.

   Let us prove the following property:
   #+begin_src text
   notnot : (b : Bool) â†’ not (not b) â‰¡ b
   notnot true = tâ‰¡t
   notnot false = fâ‰¡f
   #+end_src
   There are a number of things that are worth mentioning. First, we see that we
   refer to =b= on the returning result =not (not b) â‰¡ b=, which is possible in
   virtue of dependent types. Then we see that we pattern match on =b= and thus
   we need to fill out two cases. We could make an analogy with a hand written
   proof by cases. The case split with pattern matching allows Agda to know via
   /normalization/ that in the =true= case we must provide a term (proof) of
   type =true â‰¡ true=, which we can provide using the =tâ‰¡t= constructor. We
   proceed analogously in the =false= case. Agda normalizes the terms when
   possible, for instance the term =not (not b)= is already normalized because
   we cannot apply any rule. On the other hand the term =not (not true)= can be
   normalized to =not false= and further normalized to =true= by using the
   definition of =not=. For further information on normalization refer to
   cite:norell:thesis. Another thing to notice is that we use the same
   construction (i.e. an Agda function definition) to provide function definitions,
   like =not=, and theorems, like =notnot=.

   Pattern matching (case analysis) is ubiquitous is Agda, be it in definitions
   or in proofs. We show some more examples below:
   #+begin_src text
   p1 : (b : Bool) â†’ and false b â‰¡ false
   p1 b = fâ‰¡f

   p2 : (b : Bool) â†’ and b false â‰¡ false
   p2 true = fâ‰¡f
   p2 false = fâ‰¡f
   #+end_src
   See that in the first case we did not need to do pattern matching while in
   the second we had to. This is due to how the definition of =and= is written
   which in our case performs pattern matching on the first argument.
** Naturals and induction
   In this section we will have a look at the simplest possible recursive
   structure, the natural numbers. In Agda natural numbers can be defined in the
   following way:
   #+begin_src
   data Nat : Set where
     zero : Nat
     suc : Nat â†’ Nat
   #+end_src
   The definition should be intuitive enough for the reader at this point. We
   can represent the number $1$ with the term =suc zero=, the number $2$ with
   =suc (suc zero)= and so on.

   Let us continue by defining the equality relation for natural
   numbers[fn::Agda does not allow overloading of symbols so we would need to
   use a different name other than =_â‰¡_= to avoid the clash with the equality relation
   of Booleans that we defined before.].
   #+begin_src text
   data _â‰¡_ : Nat â†’ Nat â†’ Set where
     zâ‰¡z : zero â‰¡ zero
     sâ‰¡s : {a b : Nat} â†’ a â‰¡ b â†’ suc a â‰¡ suc b
   #+end_src
   We see that it has a similar structure to the datatype for Boolean equality.
   The only difference is that the =sâ‰¡s= constructor requires a proof of =a â‰¡ b=
   as an argument. Let us show that every natural number is equal to itself.
   #+begin_src text
   refl : (n : Nat) â†’ n â‰¡ n
   refl zero = zâ‰¡z
   refl (suc n) = sâ‰¡s (refl n)
   #+end_src
   We see that we pattern match on =n=, for the =zero= case we give the =zâ‰¡z=
   constructor. For the =suc= case we need to provide a proof of =suc n â‰¡ suc
   n=. By performing a recursive call with =n= as argument we get a proof of =n
   â‰¡ n=, then we can use the constructor =sâ‰¡s= to build a term of type =suc n â‰¡
   suc n=. It can be enlightening to observe that in a proof by induction, such
   as the previous one, a recursive call plays the role of the induction
   hypothesis.

   An inexperienced Agda user might try the following:
   #+begin_src text
   refl' : (n : Nat) â†’ n â‰¡ n
   refl' zero = zâ‰¡z
   refl' (suc n) = refl (suc n)
   #+end_src
   While the types match we see that in the inductive case we perform a
   recursive call on the same argument and thus we get an infinite loop. Agda
   has a termination checker that rejects proofs where termination cannot be
   assured and thus rejects the previous definition. We know that termination is
   an undecidable problem hence it is inevitable that Agda will reject some
   programs that in fact would always terminate. For more information on Agda's
   termination checker refer to cite:norell:thesis,agda-doc.

   We now define addition on natural numbers:
   #+begin_src text
   _+_ : Nat â†’ Nat â†’ Nat
   zero + b = b
   (suc a) + b = suc (a + b)
   #+end_src

   Proving associativity can be achieved by means of an inductive proof
   following a similar structure as before. For the base case we use the =refl=
   property proved above.
   #+begin_src text
assoc : (a b c : Nat) â†’ (a + b) + c â‰¡ a + (b + c)
assoc zero b c = refl (b + c)
assoc (suc a) b c = sâ‰¡s (assoc a b c)
   #+end_src

   Consider the following example involving negation. Keep in mind that =Â¬ (n â‰¡
   suc n) = n â‰¡ suc n â†’ âŠ¥=.
   #+begin_src text
   p1 : (n : Nat) â†’ Â¬ (n â‰¡ suc n)
   p1 zero ()
   p1 (suc n) (sâ‰¡s x) = p1 n x
   #+end_src
   For the base case we have the impossible pattern because when =n = zero= the
   second argument is supposed to have the type =zero â‰¡ suc zero= which is not
   unifiable with any type of a constructor and thus we get the empty pattern.
   For more information on Agda unification refer to cite:norell:thesis.

   Finally, let us focus on proving commutativity of addition, which is a more
   involved example. We first prove transitivity of equality, which is proved by
   an easy induction.
   #+begin_src text
trans : {a b c : Nat} â†’ a â‰¡ b â†’ b â‰¡ c â†’ a â‰¡ c
trans zâ‰¡z zâ‰¡z = zâ‰¡z
trans (sâ‰¡s x) (sâ‰¡s y) = sâ‰¡s (trans x y)
   #+end_src
   Notice how there are two missing cases, that is, =zâ‰¡z= with =sâ‰¡s= and vice
   versa. We are allowed to do that because Agda was able to
   detect the empty pattern. We could have also omitted the =p1 zero ()= case in
   the theorem above.

   We proceed by proving two lemmas by an easy induction:
   #+begin_src text
zero-r : (a : Nat) â†’ a â‰¡ (a + zero)
zero-r zero = zâ‰¡z
zero-r (suc a) = sâ‰¡s (zero-r a)

suc-r : (a b : Nat) â†’ suc (a + b) â‰¡ (a + suc b)
suc-r zero b = refl (suc b)
suc-r (suc a) b = sâ‰¡s (suc-r a  b)
   #+end_src

   At last, we put all the pieces together to prove our theorem:
   #+begin_src text
+commut : (a b : Nat) â†’ (a + b) â‰¡ (b + a)
+commut zero b = zero-r b
+commut (suc a) b = trans (sâ‰¡s (+commut a b)) (suc-r b a)
   #+end_src
   For the base case we must prove =0 + b â‰¡ b + 0= which normalizes to =b â‰¡ b +
   0= and then we can use our =zero-r= lemma. For the inductive case we must
   prove =suc a + b â‰¡ b + suc a= which normalizes to =suc (a + b) â‰¡ b + suc a=.
   By IH we know that =a + b â‰¡ b + a= so by =sâ‰¡s= we get =suc (a + b) â‰¡ suc (b +
   a)=. Then by our lemma =suc-r= we get =suc (b + a) â‰¡ b + suc a=. Finally by
   transitivity we get the desired =suc (a + b) â‰¡ b + suc a=.
** Universe hierarchy
   <<sec:universe-hierarchy>> In Agda every well-typed term is assigned a type.
   For instance, the type of =true= is =Bool= and the type of =0= is =Nat=. As
   we have mentioned before, in a dependent type theory we are allowed to mix
   types and terms, hence =Nat= is a term in itself and must be assigned a type.
   Agda calls the type of (small) types =Set=, hence we have that =Nat= has type
   =Set=. But then =Set= is also a term an must be assigned a type as well.
   Could we have that the type of =Set= is =Set=? The first version of
   Martin-LÃ¶fâ€™s type theory (cite:martin-lof-1971a) had an
   axiom stating that there is a type of all types and thus we would have that
   the type of =Set= is =Set=. However Girard showed
   (cite:sep-type-theory-intuitionistic) that having =Set : Set= allowed the
   Burali-Forti paradox[fn::The assumption that there is a set of all ordinal
   numbers leads to a contradiction.] to be encoded in the theory. In order to
   avoid such inconsistency Agda builds a hierarchy of universes where small
   types such as =Nat= and =Bool= are assigned the type =Set 0= and then for
   every $iâˆˆÏ‰$ we have that =Set i : Set i+1=. Notice however, that =Set i : Set
   i+1= is true while =Set i : Set i+n= it is not for $n>1$. In Agda we write
   =Set= instead of =Set 0=. When the level is a constant natural number we can
   also write =Setâ‚=, =Setâ‚‚=, etc. instead of =Set 1=, =Set 2=, etc.

   It is possible to combine types of different universe levels. The bigger type
   is the one that counts. For instance:
   #+begin_src text
   to : Setâ‚ƒ â†’ Setâ‚ â†’ Setâ‚ƒ
   to A B = A â†’ B
   #+end_src
   The typing rule is analogous for product and sum types.

   Agda provides a primitive[fn::/primitive/ means that it is built in the
   language and it cannot be user defined.] type for universe levels called
   =Level=. Essentially it is the same as =Nat=, but it only works as a universe
   index. Having the =Level= type allows us to write universe polymorphic functions.
   See the same function as before, but now with universe polymorphism.
   #+begin_src text
   to' : {a b : Level} â†’ Set a â†’ Set b â†’ Set (a âŠ” b)
   to' A B = A â†’ B
   #+end_src
   The =_âŠ”_= operator is a primitive operator of type =Level â†’ Level â†’ Level=
   that returns the maximum of its two operands.

   Most of the functions that we have defined before should be rewritten to be
   universe polymorphic if possible. For instance, we can now rewrite the
   identity function thus:
   #+begin_src text
   id : {a : Level} {A : Set a} â†’ A â†’ A
   id a = a
   #+end_src

   In the most recent version of Agda (2.6.1) there is an option to enable
   /universe cumulativity/ (cite:agda-doc). This extension adds the typing rule
   $Setáµ¢:Setâ±¼$ for $i<j$. Hence it allows us to write the following:
   #+begin_src text
   a : Set              -- always allowed
   a = Nat
   b : Setâ‚             -- only with cumulativity
   b = Nat
   c : {i : Level} â†’ Set i    -- only with cumulativity
   c = Nat
   #+end_src

   In our project we have not used this extension.
** BHK interpretation of first order logic
   <<sec:bhk-fol>>
** Agda syntax
   This section is meant to be a summary of some of the important parts of the
   language reference. I am not sure if this section should be in the report or
   should just link to the online doc.

*** Pattern matching
*** Implicit arguments and ifnerence
   <<sec:agda-implicit-args>>
*** datatype definitions and constructors
    <<sec:agda-datatype>>
        #+begin_src text
  data D (xâ‚ : Pâ‚) ... (xâ‚– : Pâ‚–) : (yâ‚ : Qâ‚) â†’ ... â†’ (yâ‚— : Qâ‚—) â†’ Set â„“ where
    câ‚ : Aâ‚
    ...
    câ‚™ : Aâ‚™
        #+end_src
** old :noexport:
  #   What sets dependent type theory apart from other type theories is that types
  #   can depend on terms. In a non-dependent theory types and terms live in
  #   separate worlds and they only meet to decide what terms have which types. In a
  #   dependent theory, on the other hand, types can talk about terms and so it is
  #   possible to express things like the precise characterisation of the sorting
  #   function mentioned above.

  #   In this section we present a dependent type theory
  #   which can serve as basis for the extensions discussed in later chapters. The
  #   particular choice of type theory is not crucial and the theory we choose is
  #   roughly Luoâ€™s UTT [Luo94] extended with Î£-types and Î·-laws. In the following
  #   we will refer to this theory as UTT Î£ . The syntax of UTT Î£ is presented in
  #   Figure 1.1. A telescope [dB91b] âˆ† = (x 1 : A 1 ) . . . (x n : A n ) is a
  #   sequence of types where later types may depend on elements of previous types.
  #   W

  # #+name: fig:agda-syntax
  # #+caption: The syntax of $\sf{UTT}_Î£$.
  # #+attr_latex: :align llll :float t :center t :placement [H]
  # | $s,t,A,B$ | $â‰”$   | $x$                   | variable                     |
  # |           | \vert | $(x:A)â†’B$             | dependent function type      |
  # |           | \vert | $Î»x.t$                | lambda abstraction           |
  # |           | \vert | $s\ t$                | function application         |
  # |           | \vert | $(x:A)Ã—B$             | dependent pair  type         |
  # |           | \vert | $âŸ¨s,tâŸ©$               | dependent pairs              |
  # |           | \vert | $Ï€â‚\ t$ \vert $Ï€â‚‚\ t$ | projections                  |
  # |           | \vert | $\sf{Set}_i$          | universes $(iâˆˆÏ‰)$            |
  # |           | \vert | $ğŸ$                   | the unit type                |
  # |           | \vert | $âŸ¨âŸ©$                  | the element of the unit type |
  # | $Î“,Î”$     | $â‰”$   | $Îµ$                   |                              |
  # |           | \vert | $(x:A)Î“$              | telescopes                   |

** Positivity
   <<sec:positivity>>

   See cite:agda-doc.

* Agda in the project
  The goal of this section is to guide the reader through a brief practical
  introduction to the language while explaining some key parts of code that we
  have implemented.

  It is worth noting that we have started from scratch as we believe that no
  other previous work in interpretability logics has been done in Agda.

  The implementation relies on the Agda standard library cite:agda-stdlib.

** Naming conventions
   1. If we have =f : T= we say that =f= has type =T= or that =f= is a proof of =T=.
   2. If we have =f : A â†’ B â†’ C= we say =f= has arguments =A= and =B= and it has
      return type =C=.
** Modal formulas
   Here we present the Agda type that represents a formula as defined in section
   [[sec:language]]. It is a very simple type yet an insightful introductory example.

   First we define variables to be natural numbers:
   #+begin_src text
Var : Set
Var = Nat
   #+end_src

   We proceed by inductively defining the formula type: =Fm=. We add a
   constructor for variables and one for each primitive operator.
   #+begin_src text
data Fm : Set where
  var : Var â†’ Fm
  âŠ¥' : Fm
  _â†_ : Fm â†’ Fm â†’ Fm
  _â–·_ : Fm â†’ Fm â†’ Fm
   #+end_src
   There are a number of things to take notice:
   1. The =data= keyword is used to introduce the definition of a new type;
   2. the newly introduced =Fm= type is not indexed by any other type, hence it
      has type =Set= as indicated by =Fm : Set=;
   3. take the constructor =var=, which has type =Var â†’ Fm=. This means that if
      we apply =var= to a variable (i.e. a natural number) we get a term of type
      =Fm=. For instance, =var 3= has type =Fm=.
   4. we have named the bottom constructor =âŠ¥'= since the symbol =âŠ¥= is commonly
      used in Agda. We have used the =â†= to denote an implication since =â†’= is a
      reserved symbol;
   5. the underscores in =_â†_= and =_â–·_= mean that these constructors are infix
      operators. Thus, the following formula is syntactically valid: =(var 1 â–·
      var 0) â† âŠ¥'=.

      It is often the case that we define priority for our infix operators. The
      following code defines the /infixity/ of =_â†_= and =_â–·_=
        #+begin_src text
      infixr 20 _â†_
      infixr 50 _â–·_
        #+end_src
      The higher the number the more priority, hence we can drop the parentheses
      from the previous formula =var 1 â–· var 0 â† âŠ¥'=. The $r$ in =infixr= stands
      for right associativity.

   We finally add definable operators as Agda functions. For instance, we define
   negation thus:
  #+begin_src text
infix 60 Â¬'_
Â¬'_ : Fm â†’ Fm
Â¬' a = a â† âŠ¥'
  #+end_src
  We use the symbol =Â¬'= instead of =Â¬= for the same reason we used =âŠ¥'= instead
  of =âŠ¥=.

** Predicates and relations
   <<sec:predicates>>
   In this section we give a short description on how to represent predicates
   and relations in Agda.

   We define a predicate to have the following type[fn::We leave universe
   polymorphism out for simplicity.]:\glsadd{Pred}
   #+begin_src text
   Pred : Set â†’ Setâ‚
   Pred A = A â†’ Set
   #+end_src
   Hence, a predicate on the elements of some type =A= is a function from =A= to
   =Set=.

   Relations follow the same pattern:\glsadd{REL}
   #+begin_src text
   REL : Set â†’ Set â†’ Setâ‚
   REL A B = A â†’ B â†’ Set
   #+end_src
   For homogeneous relations we use the name =Rel=:\glsadd{Rel}
   #+begin_src text
   Rel : Set â†’ Set â†’ Setâ‚
   Rel A = REL A A
   #+end_src

   Now consider as an example the natural numbers and the =â‰¤= relation, which is
   defined inductively according to the following definition.
   1. For all $aâˆˆâ„•$ we have $0â‰¤a$;
   2. for all $a,bâˆˆâ„•$ we have that if $aâ‰¤b$ then also $a+1â‰¤b+1$.
   #+begin_src text
   data Nat : Set where
     zero : Nat
     suc : Nat â†’ Nat

   data _â‰¤_ : Rel Nat where
     zâ‰¤n : (a : Nat) â†’ zero â‰¤ a
     sâ‰¤s : {a b : Nat} â†’ a â‰¤ b â†’ suc a â‰¤ suc b
   #+end_src
   Note that =â‰¤= is the first indexed type that we present as it is indexed by
   two natural numbers. Keep in mind that =Rel Nat = Nat â†’ Nat â†’ Set=.
   If =t : a â‰¤ b= we say that =t= is a proof that =a= is less or equal than =b=.

   Let us prove that $1â‰¤2$; hence we need to build a term of type =suc zero â‰¤
   suc (suc zero)=.
   #+begin_src text
   1â‰¤2 : suc zero â‰¤ suc (suc zero)
   1â‰¤2 = sâ‰¤s (zâ‰¤n (suc zero))
   #+end_src
   Note that we did not explicitly give parameters =a, b= for the =sâ‰¤s=
   constructor as they are declared in curly braces[fn::Arguments defined in
   curly braces do not need to be given explicitly so long as Agda can infer its
   values.] and can be inferred by the type =a â‰¤ b=. Note that we could have
   done the same with the argument =a= of =zâ‰¤n= but we keep it explicit for
   illustrating the difference.

   We can also build proofs recursively. Let us prove that =_â‰¤_= is reflexive by
   induction:
   #+begin_src text
   â‰¤-refl : (a : Nat) â†’ a â‰¤ a
   â‰¤-refl zero = zâ‰¤n zero
   â‰¤-refl (suc a) = sâ‰¤s (â‰¤-refl a)
   #+end_src
   A key feature to notice is that we can name arguments and refer to them in
   subsequent arguments and in the return type. For instance here we have named
   =a= the first argument, which is a natural number. We use the syntax =(a :
   Nat)=. And then we use the name =a= to build the return type, that is: =a â‰¤ a=.

   We can also define the property of transitivity.
   #+begin_src text
   Transitive : {A : Set} â†’ Rel A â†’ Set
   Transitive R = âˆ€ {a b c} â†’ R a b â†’ R b c â†’ R a c
   #+end_src
   We see that a proof that some relation is transitive is a function that given
   proofs of =R a b= and =R b c= constructs a proof of =R a c=. Notice that the
   arguments =a b c= are declared implicit as they can be inferred from the types
   =a â‰¤ b= and =b â‰¤ c=. Let us prove that =â‰¤= is transitive:
   #+begin_src text
   â‰¤-trans : Transitive _â‰¤_
   â‰¤-trans {a} {b} {c} (zâ‰¤n b) bâ‰¤c = zâ‰¤n c
   â‰¤-trans {suc a} {suc b} {suc c} (sâ‰¤s aâ‰¤b) (sâ‰¤s bâ‰¤c) = sâ‰¤s (â‰¤-trans aâ‰¤b bâ‰¤c)
   #+end_src
   The previous proof works as follows. We perform induction on the proof of =a
   â‰¤ b=, that is, the first explicit argument.
   - Case =zâ‰¤n=; we know that =a = zero= and we can easily build a proof of
     =a â‰¤ c= by using the =zâ‰¤n= constructor.
   - Case =sâ‰¤s aâ‰¤b=; then is must be that the second proof is built using the
     =sâ‰¤s= constructor since we have =suc b=. Hence we have =aâ‰¤b : a â‰¤ b= and
     =bâ‰¤c : b â‰¤ c=. By using a recursive call (induction hypothesis) to
     =â‰¤-trans= we can build a proof of =a â‰¤ c=. Finally we can apply the
     constructor =sâ‰¤s= to obtain a proof of =suc a â‰¤ suc c=.
** Dependent pairs
    Consider the following non-dependent pair definition (again, we present a non universe
    polymorphic version for simplicity):
    #+begin_src text
data _Ã—_ (A B : Set) : Set where
  _,_ : A â†’ B â†’ A Ã— B
    #+end_src
    Notice that =_Ã—_= is a parameterized type as it has parameters =(A B :
    Set)=, which are the types of each component of the pair. Parameters are
    shared parameters by all constructors (in this case there is only one
    constructor).

    See that we can easily build a pair $âŸ¨0,1âŸ©$ thus:
    #+begin_src text
    p : Nat Ã— Nat
    p = zero , (suc zero)
    #+end_src

    We now introduce the notion of \glspl*{dependent-pair}, also called
    \(Î£\)-pairs. Consider the following definition.
    #+begin_src text
data Î£ {a b : Level} (A : Seta a) (B : A â†’ Set b) : Set (a âŠ” b) where
  _,_ : (a : A) â†’ (b : B a) â†’ Î£ A B
    #+end_src
    The only, although essential, difference, is that the type of the second
    parameter is indexed by the value of the first. This is specially useful to
    represent existential quantification. For instance, we can design a type
    that asserts that some predicate is satisfiable[fn::we could simply write
    =P= instead of =(Î» a â†’ P a)= since eta-reductions are valid in Agda.]:
    #+begin_src text
    Satisfiable : {A : Set} â†’ Pred A â†’ Set
    Satisfiable {A} P = Î£ A (Î» a â†’ P a)
    #+end_src
    For instance:
    #+begin_src text
    TODO: show meaningful example of dependent pair
    #+end_src

    It useful to define the projection of each component:
    #+begin_src text
    projâ‚ : {A : Set} {B : A â†’ Set} â†’ Î£ A B â†’ A
    projâ‚ (a , b) = a

    projâ‚‚ : {A : Set} {B : A â†’ Set} â†’ (p : Î£ A B) â†’ B (projâ‚ p)
    projâ‚‚ (a , b) = b
    #+end_src
** Noetherian relations
    We say that a relation is \gls*{noetherian} if it is conversely
    well-founded. We begin by formalizing the concept of infinite ascending
    chain in Agda. In order to do that, we define a coinductive record datatype
    (cite:agda-doc) (cite:norell:thesis). A coinductive record is allowed to be
    infinite.

    #+begin_src text
record InfiniteChain {â„“W â„“R} {W : Set â„“W} (_<_ : Rel W â„“R) (a : W)
  : Set (â„“R âŠ” â„“W)where
  coinductive
  field
    b : W
    a<b : a < b
    tail : InfiniteChain _<_ b
    #+end_src

    We see that the previous record datatype represents an infinite ascending
    chain starting at =a= of some relation =<=. It has three fields. =b=: The
    next element in the chain. =a<b=: A proof that $a < b$ and =tail=: an
    infinite chain starting at =b=.

    Then we can define being Noetherian as the negation of the existence of an
    infinite chain:
    #+begin_src text
Noetherian : âˆ€ {â„“R â„“W} {W : Set â„“W} â†’ Rel W â„“R â†’ Set (â„“R âŠ” â„“W)
Noetherian _<_ = âˆ€ {a} â†’ Â¬ (InfiniteChain _<_ a)
    #+end_src

    For instance, we can prove that a Noetherian relation is irreflexive. First
    we show that from a proof that $xRx$ we can build an infinite chain:
    #+begin_src text
infiniteRefl : âˆ€ {â„“} {R : Rel A â„“} {x} â†’ R x x â†’ InfiniteChain R x
InfiniteChain.b (infiniteRefl {x = x} Rxx) = x
InfiniteChain.a<b (infiniteRefl {x = x} Rxx) = Rxx
InfiniteChain.tail (infiniteRefl {x = x} Rxx) = infiniteRefl Rxx
    #+end_src

    And then we can apply the Noetherian definition.
    #+begin_src text
Noetherianâ‡’Irreflexive : âˆ€ {â„“R â„“W} {W : Set â„“W} {R : Rel W â„“R}
     â†’ Noetherian R â†’ âˆ€ {x} â†’ Â¬ R x x
Noetherianâ‡’Irreflexive noetherian Rxx = noetherian (infiniteRefl Rxx)
    #+end_src

    To see another example refer to the proof of soundness for J5 (pending).
** Ordinary semantics
   In this section we explain how we have represented ordinary Veltman semantics
   in Agda.

   To represent ordinary Veltman semantics in Agda, the first step is to
   define the type of an ordinary Veltman frame:
   #+begin_src text
record Frame : Setâ‚ where
  constructor frame
  field
    W : Set
    witness : W
    R : Rel W lzero
    S : Relâ‚ƒ W lzero
    R-trans : Transitive R
    R-noetherian : Noetherian R
    SwâŠ†R[w]Â² : âˆ€ {w u v} â†’ S w u v â†’ R w u Ã— R w v
    Sw-refl : âˆ€ {w u} â†’ R w u â†’ S w u u
    Sw-trans : âˆ€ {w} â†’ Transitive (S w)
    R-Sw-trans : âˆ€ {w u v} â†’ R w u â†’ R u v â†’ S w u v
   #+end_src
   The keyword =record= is used to define a new product type (a tuple) in which
   each component (or field) has a name.

   The first component, =W=, corresponds to the type of the worlds in the frame.
   The second component, =witness= is required to make sure that the set of
   worlds is not empty. The =R= and =S= components are the relations. The
   remaining components are the properties that must be satisfied according to
   definition [[def:ordinary-frames]]. Notice the =lzero= in the type of =R= and =S=
   which restricts this relations to be in the 0 level of the universe hierarchy
   (i.e. =R= has type =W â†’ W â†’ Setâ‚€=, see [[sec:universe-hierarchy]]) as making them
   universe polymorphic has no gains for the purposes of this work and it would
   make code harder to read.

   We define a valuation on a frame thus:
   #+begin_src text
Valuation : Frame â†’ Setâ‚
Valuation F = REL W Var lzero
  where open Frame F
   #+end_src

   And then we define a model to be a tuple of a frame and a valuation on that
   frame.
   #+begin_src text
record Model : Setâ‚ where
  constructor model
  field
    F : Frame
    V : Valuation F
   #+end_src

   Our next step is to define the forcing relation.
   #+begin_src text
data _,_âŠ©_ (M : Model) (w : MW M) : Fm â†’ Set where
   ...
   #+end_src
   We set a model and a world of that model as parameters as they should be
   shared by all constructors. We leave the formula as an index as it may vary
   depending on the constructor. We should introduce a constructor for each case
   in definition [[def:ord-forcing]]:[fn::we have slightly
   simplified the types of the constructors below to make them more readable.]
   1. We do not need a constructor for =âŠ¥'= as its absence implicitly implies that
      we can never build an instance of =M , w âŠ© âŠ¥'= regardless of =M= and =w=.
   2. if $xâˆˆVar$, then $wâŠ©x$ iff $âŸ¨w,xâŸ©âˆˆV$;
      #+begin_src text
  var : {x : Var} â†’ V w x â†’ M , w âŠ© var x
      #+end_src
   3. if $A,BâˆˆFm$, then $wâŠ©Aâ†’B$ iff if $wâŠ©A$ then $wâŠ©B$;
      #+begin_src text
  impl : {A B : Fm} â†’ ((M , w âŠ© A) â†’ (M , w âŠ© B)) â†’ M , w âŠ© (A â† B)
      #+end_src
   4. if $A,BâˆˆFm$, then $wâŠ©Aâ–·B$ iff if $wRu$ and $uâŠ©A$ then there exists $v$ such
      that $vâŠ©B$ and $uS_wv$.
      #+begin_src text
   rhd : {A B : Fm} â†’
     ({u : W} â†’ R w u â†’ M , u âŠ© A â†’ (Î£ W Î» v â†’ S w u v Ã— (M , v âŠ© B)))
     â†’ M , w âŠ© A â–· B
      #+end_src

   Unfortunately the definition above is not valid in Agda. The reason is that
   constructors =rhd= and =impl= both fail the positivity check (see
   [[sec:positivity]]). For instance, see that in the =impl= constructor we have
   =(M , w âŠ© A)= on the left of an arrow =â†’=.

   We have circumvented this problem by providing mutually recursive definitions
   for /forcing/ (=_,_âŠ©_=) and /not forcing/ (=_,_âŠ®_=).

   The type definition without the constructors is as follows.
   #+begin_src text
   data _,_âŠ®_ (M : Model) (w : MW M) : Fm â†’ Set
   data _,_âŠ©_ (M : Model) (w : MW M) : Fm â†’ Set
   #+end_src

   Next we provide the strictly positive types of each constructor of the
   =_,_âŠ©_= and =_,_âŠ®_= relations.
   1. For the =âŠ¥'= constant.
      1. Forcing (=_,_âŠ©_=). No constructor is required.
      2. Not forcing (=_,_âŠ®_=).
        #+begin_example
        bot : M , w âŠ® âŠ¥'
        #+end_example
   2. For variables.
    1. Forcing (=_,_âŠ©_=).
       #+begin_src text
  var : {x : Var} â†’ V w x â†’ M , w âŠ© var x
       #+end_src
    2. Not forcing (=_,_âŠ®_=).
       #+begin_example
  var : {x : Var} â†’ Â¬ (V w x) â†’ M , w âŠ® var x
       #+end_example

   3. For implication (=â†=).
    1. Forcing (=_,_âŠ©_=).
       #+begin_src text
  impl : {A B : Fm} â†’ M , w âŠ® A âŠ M , w âŠ© B â†’ M , w âŠ© A â† B
       #+end_src
    2. Not forcing (=_,_âŠ®_=).
       #+begin_src text
  impl : {A B : Fm} â†’ M , w âŠ© A â†’ M , w âŠ® B â†’ M , w âŠ® A â† B
       #+end_src
   4. For interpretability (=â–·=).
    1. Forcing (=_,_âŠ©_=).
       #+begin_src text
  rhd : {A B : Fm} â†’
    (âˆ€ {u} â†’ R w u â†’ M , u âŠ® A âŠ (Î£ W Î» v â†’ S w u v Ã— M , v âŠ© B))
    â†’ M , w âŠ© A â–· B
       #+end_src
    2. Not forcing (=_,_âŠ®_=).
       #+begin_src text
  rhd : {A B : Fm} â†’
    Î£ W (Î» u â†’ R w u Ã— M , u âŠ© A Ã— ((v : W) â†’ (Â¬ S w u v) âŠ M , v âŠ® B))
    â†’ M , w âŠ® A â–· B
       #+end_src

   Putting it all together results in the following definitions:
   #+begin_src text
data _,_âŠ©_ M w where
  var : {x : Var} â†’ V w x â†’ M , w âŠ© var x
  impl : {A B : Fm} â†’ M , w âŠ® A âŠ M , w âŠ© B â†’ M , w âŠ© A â† B
  rhd : {A B : Fm} â†’
    (âˆ€ {u} â†’ R w u â†’ M , u âŠ® A âŠ (Î£ W Î» v â†’ S w u v Ã— M , v âŠ© B))
    â†’ M , w âŠ© A â–· B
   #+end_src
   #+begin_src text
data _,_âŠ®_ M w where
  var : {x : Var} â†’ Â¬ (V w x) â†’ M , w âŠ® var a
  impl : {A B : Fm} â†’ M , w âŠ© A â†’ M , w âŠ® B â†’ M , w âŠ® A â† B
  rhd : {A B : Fm} â†’
    Î£ W (Î» u â†’ R w u Ã— M , u âŠ© A Ã— ((v : W) â†’ (Â¬ S w u v) âŠ M , v âŠ® B))
    â†’ M , w âŠ® A â–· B
  bot : M , w âŠ® âŠ¥'
   #+end_src

   To prove that =_,_âŠ©= and =_,_âŠ®= are indeed the negation of each other
   we should prove two lemmas; in Agda types[fn::=A â‡” B â‰” A â†’ B Ã— B â†’ A=]:
   {{{beginlemma}}}
   <<lemma:forcing-neg>>
   \hfill
   1. =âˆ€ {M w A} â†’ M , w âŠ© A â‡” Â¬ (M , w âŠ® A)=.
   2. =âˆ€ {M w A} â†’ Â¬ (M , w âŠ© A) â‡” M , w âŠ® A=.
   {{{endlemma}}} For lemma 1 we can prove $â‡’$ and for lemma 2 we can prove $â‡$
   (see lemma [[lemma:equiv]]). However, it is not possible to prove the remaining
   directions. In general terms, this is due to the fact that in Agda (and in
   intuitionistic logic in general) we can prove that =(Â¬ A âŠ B) â†’ A â†’ B= but we
   cannot prove =A â†’ B â†’ (Â¬ A âŠ B)=. The reason being that we lack the law of
   excluded middle, as it is a non-constructive axiom. In order to prove the
   remaining directions we need to assume that the forcing relation is
   decidable.

   {{{begindef}}} We say that =M= is \gls*{decidable model} if for any world =w= and
   formula =A= we have that either =M , w âŠ© A= or =M , w âŠ® A=.

   In Agda terms:
   #+begin_src text
DecidableModel : Model â†’ Set
DecidableModel M = âˆ€ w A â†’ M , w âŠ© A âŠ M , w âŠ® A
   #+end_src
   {{{enddef}}}

   {{{beginproof}}}
   {{{agda}}}

   Under the assumption that we restrict ourselves to decidable models we can
   prove lemma [[lemma:forcing-neg]].
   {{{endproof}}}

   {{{beginlemma}}} <<lemma:equiv>> The following is true[fn::Note that =MR M=
   is the =R= of the frame on which the model =M= is based. We give analogous
   definitions to =MW= and =MS=.]:

   1. =âŠ©âŠ¥ : âˆ€ {M w} â†’ Â¬ (M , w âŠ© âŠ¥')=;
   2. =âŠ®â†’Â¬âŠ© : âˆ€ {M w A} â†’ M , w âŠ® A â†’ Â¬ (M , w âŠ© A)=;
   3. =âŠ©â†’Â¬âŠ® : âˆ€ {M w A} â†’ M , w âŠ© A â†’ Â¬ (M , w âŠ® A)=;
   4. =âŠ©MP : âˆ€ {M w A B} â†’ M , w âŠ© A â† B â†’ M , w âŠ© A â†’ M , w âŠ© B=;
   5. =âŠ©Â¬ : âˆ€ {M w A} â†’ (M , w âŠ© Â¬' A) â‡” (M , w âŠ® A)=;
   6. =âŠ®Â¬ : âˆ€ {M w A} â†’ M , w âŠ® Â¬' A â‡” M , w âŠ© A=;
   7. =âŠ©Â¬Â¬ : âˆ€ {M w A} â†’ M , w âŠ© Â¬' Â¬' A â‡” M , w âŠ© A=;
   8. =âŠ®Â¬Â¬ : âˆ€ {M w A} â†’ M , w âŠ® Â¬' Â¬' A â‡” M , w âŠ® A=;
   9. =âŠ©âˆ§ : âˆ€ {M w A B} â†’ M , w âŠ© A âˆ§ B â‡” (M , w âŠ© A Ã— M , w âŠ© B)=;
   10. =âŠ®âˆ§ : âˆ€ {M w A B} â†’ M , w âŠ® A âˆ§ B â‡” (M , w âŠ® A âŠ M , w âŠ® B)=;
   11. =âŠ©âˆ¨ : âˆ€ {M w A B} â†’ M , w âŠ© A âˆ¨ B â‡” (M , w âŠ© A âŠ M , w âŠ© B)=;
   12. =âŠ©â–¡ : âˆ€ {M w A} â†’ M , w âŠ© â–¡ A â‡” (âˆ€ {v} â†’ MR M w v â†’ M , v âŠ© A)=;
   13. =âŠ®â–¡ : âˆ€ {M w A} â†’ M , w âŠ® â–¡ A â‡” (Î£ (MW M) Î» u â†’ MR M w u Ã— M , u âŠ® A)=;
   14. =âŠ©â™¢ : âˆ€ {M w A} â†’ M , w âŠ© â™¢ A â‡” (Î£ (MW M) Î» u â†’ MR M w u Ã— M , u âŠ© A)=;
   15. =âŠ®â™¢ : âˆ€ {M w A} â†’ M , w âŠ® â™¢ A â‡” (âˆ€ {u} â†’ MR M w u â†’ M , u âŠ® A)=;
   16. =âŠ©â†â‡¨ : âˆ€ {M w A B} â†’ M , w âŠ© A â† B â†’ M , w âŠ© A â†’ M , w âŠ© B=;
   17. =âŠ©â–·â‡¨ : âˆ€ {M w A B} â†’ M , w âŠ© A â–· B â†’ (âˆ€ {u} â†’ MR M w u â†’ M , u âŠ© A â†’ Î£ (MW M) Î» v â†’ (MS M) w u v Ã— M , v âŠ© B)=.
   {{{endlemma}}}
   {{{beginproof}}} {{{agda}}} All of the above has been proven
   in Agda without assuming that the model is decidable. {{{endproof}}}


   {{{beginlemma}}} <<lemma:ord-equiv-dec>> A series of equivalences that can be proven for decidable
   models.

   1. =âŠ©â† : âˆ€ {w A B} â†’ M , w âŠ© A â† B â‡” (M , w âŠ© A â†’ M , w âŠ© B)=;
   2. =âŠ©â–· : âˆ€ {w A B} â†’ M , w âŠ© A â–· B â‡”
      (âˆ€ {u} â†’ MR M w u â†’ M , u âŠ© A â†’ Î£ (MW M) Î» v â†’ (MS M) w u v Ã— M , v âŠ© B)=;
   3. =âŠ©â‡”Â¬âŠ® : âˆ€ {w A} â†’ M , w âŠ© A â‡” (Â¬ M , w âŠ® A)=;
   4. =âŠ®â‡”Â¬âŠ© : âˆ€ {w A} â†’ M , w âŠ® A â‡” (Â¬ M , w âŠ© A)=.
   {{{endlemma}}} {{{beginproof}}} {{{agda}}} Note that we only need the
   decidability assumption for 1 ($â‡$), 2 ($â‡$), 3 ($â‡$) and 4 ($â‡$). {{{endproof}}}

   From now on, we always restrict ourselves to decidable models as the usage of
   lemma [[lemma:ord-equiv-dec]] is ubiquitous. If we were to assume that we are
   outside of Agda and that we accept the law of excluded middle as part of our
   metalogic, the mentioned assumption could be dropped.

** Subsets (predicates revisited)
   \glsadd{Pred}
   In Agda, the keyword =Set= refers to an Agda type (insert ref to previous
   section), which is the closest concept to regular mathematics /set/. In this
   section when we say /set/ we refer to a subset of an Agda type. The most
   natural way to represent subsets in Agda is to use predicates. See
   [[sec:predicates]] for an introduction. A predicate represents the characteristic
   function of the associated subset. For instance consider the predicate:
   #+begin_src text
   even : Pred Nat
   even = ...
   #+end_src
   Then =even= represents the subset of natural numbers that are even. It is
   important to note that predicates are always restricted to a specific type,
   in this case =Nat=, and for that reason the term /subset/ may be more adequate.

   Next we present how we represent in Agda common operations on sets.
   Assume for the below definitions that we have some =A : Set= in scope.
   1. \boxed{âˆˆ} A proof of membership is a simple function application.
      #+begin_src text
      _âˆˆ_ : REL A (Pred A)
      a âˆˆ X = X a
      #+end_src
      This definition is mostly superfluous but it helps to have a syntax closer
      to regular mathematics.
   2. \boxed{âˆ‰} A proof of non membership is function from a proof of membership to =âŠ¥=.
      #+begin_src text
      _âˆ‰_ : REL A (Pred A)
      a âˆ‰ X = Â¬ (a âˆˆ X)
      #+end_src
   3. \boxed{âŠ†} A proof of inclusion =X âŠ† Y= is a function that maps a proof of
      membership to =X= to a proof of membership to =Y=.
      #+begin_example
      _âŠ†_ : Rel (Pred A)
      X âŠ† Y = âˆ€ {x} â†’ x âˆˆ X â†’ x âˆˆ Y
      #+end_example
   4. \boxed{âˆ©} We use pairs to represent the intersection. Each component is a
      proof of membership to =X= and =Y= respectively.
      #+begin_src text
      _âˆ©_ : Pred A â†’ Pred A â†’ Pred A
      X âˆ© Y = Î» x â†’ x âˆˆ X Ã— x âˆˆ Y
      #+end_src
   5. \boxed{âˆª} We use a sum type to represent the union.
      #+begin_src text
      _âˆª_ : Pred A â†’ Pred A â†’ Pred A
      X âˆª Y = Î» x â†’ x âˆˆ X âŠ x âˆˆ Y
      #+end_src
   6. \boxed{âˆ…}
      The empty set is represented by a characteristic constant function to =âŠ¥=.
      #+begin_src text
      âˆ… : Pred A
      âˆ… = Î» x â†’ âŠ¥
      #+end_src
   7. \boxed{ğŸ}
      Similarly, the universe set is represented by a characteristic constant function to =âŠ¤=.
      #+begin_src text
      U : Pred A
      U = Î» x â†’ âŠ¤
      #+end_src
   8. \(\boxed{\{x\}}\) A singleton set is defined using equality (TODO: define
      equality in Agda).
      #+begin_example
      ï½›_ï½ : A â†’ Pred A
      ï½› x ï½ = Î» y â†’ x â‰¡ y
      #+end_example
** Generalized semantics
   In this section we explain how we have represented generalized Veltman
   semantics in Agda.

   Analogously to ordinary semantics we start by defining a frame:

   #+begin_src text
record Frame {â„“} : Set (lsuc â„“) where
  constructor frame
  field
    W : Set
  ğ• : Setâ‚
  ğ• = Pred W lzero
  field
    witness : W
    R : Rel W lzero
    S : RELâ‚ƒ W W ğ• lzero
    Swu-sat : âˆ€ {w u Y} â†’ S w u Y â†’ Satisfiable Y
    R-trans : Transitive R
    R-noetherian : Noetherian {â„“} R
    SwâŠ†R[w] : âˆ€ {w u Y} â†’ S w u Y â†’ R w u
    SwuYâŠ†R[w] : âˆ€ {w u Y} â†’ S w u Y â†’ âˆ€ {y} â†’ y âˆˆ Y â†’ R w y
    S-quasirefl : âˆ€ {w u} â†’ R w u â†’ S w u ï½› u ï½
    S-quasitrans : âˆ€ {w u V} â†’ S w u V â†’ (f : âˆ€ {v} â†’ v âˆˆ V â†’ Î£ ğ• Î» Z â†’ S w v Z)
      â†’ S w u Î» {x â†’ Î£ W Î» v â†’ Î£ (v âˆˆ V) Î» vâˆˆV â†’ x âˆˆ projâ‚ (f vâˆˆV)}
    R-Sw-trans : âˆ€ {w u v} â†’ R w u â†’ R u v â†’ S w u ï½› v ï½
    S-monotone : âˆ€ {w u} {V Z : ğ•} â†’ S w u V â†’ V âŠ† Z â†’ Z âŠ† R w â†’ S w u Z
   #+end_src

   Notice that just below the definition of the field =W : Set=, we have introduced a
   definition of the type =ğ• : Setâ‚=

** IL and syntactic proofs
* Verbrugge
  In this section we proof that given a generalized Veltman model that satisfies
  a certain property, we can build an ordinary Veltman model with the same
  associated forcing relation. For the rest of this section we fix a generalized
  Veltman model $Mâ‰”âŸ¨W, R, S, VâŸ©$.

  We define an ordinary Veltman model $M'â‰”âŸ¨W',R',S',V'âŸ©$ where
  \begin{flalign*}
  W'â‰”&\{âŸ¨x,AâŸ©:AâŠ†W^2, \\ &(W1)\ âˆ€âŸ¨u,vâŸ©âˆˆA\ âˆƒY(xS_uY,vâˆˆY), \\
  & (W2)\ âˆ€uV(xS_uVâ‡’âˆƒvâˆˆV(âŸ¨u,vâŸ©âˆˆA)\}; \\
  R'â‰”&\{âŸ¨âŸ¨x,AâŸ©,âŸ¨y,BâŸ©âŸ© : xRy,âˆ€wz(wRxâ‡’âŸ¨w,zâŸ©âˆˆBâ‡’âŸ¨w,zâŸ©âˆˆA)\}; \\
  S'â‰”&\{âŸ¨âŸ¨w,CâŸ©,âŸ¨x,AâŸ©,âŸ¨y,BâŸ©âŸ© : âŸ¨w,CâŸ©R'âŸ¨x,AâŸ©,âŸ¨w,CâŸ©R'âŸ¨y,BâŸ©, âˆ€v(âŸ¨w,vâŸ©âˆˆBâ‡’âŸ¨w,vâŸ©âˆˆA) \}; \\
  V'â‰”&\{âŸ¨âŸ¨x, AâŸ©,varâŸ©: âŸ¨x,varâŸ©âˆˆV, âŸ¨x,AâŸ©âˆˆW'\}.
  \end{flalign*}

  {{{beginlemma}}}
  The structure $âŸ¨W',R',S',V'âŸ©$ is an ordinary Veltman model.
  {{{endlemma}}}
  {{{beginproof}}}
  {{{agda}}} It is routine to check that all the requirement are satisfied.
  {{{endproof}}}

  Let the conditions $(C_0)$ and $(C_1)$ be defined thus:
  \begin{flalign*}
  (Câ‚€)&â‰”âˆ€wxV.xS_wVâ‡’âˆƒyâˆˆV.âˆ€bV'.yS_bV'â‡’âˆƒvâˆˆV'. (b=w â‡’ xS_b\{v\}), (bRw â‡’ wS_b\{v\}); \\
  (Câ‚)&â‰”âˆ€wbxV.wRxâ‡’xS_bVâ‡’âˆƒvâˆˆV.xS_b\{v\},(bRwâ‡’wS_b\{v\}).
  \end{flalign*}
  {{{begintheorem}}}
  If $M$ satisfies both conditions $(C_0)$ and $(C_1)$ then
  for any world $âŸ¨w,CâŸ©âˆˆW'$ and formula $D$:
  \[wâŠ©Dâ‡”âŸ¨w,CâŸ©âŠ©D\]
  {{{endtheorem}}}
  {{{beginproof}}} {{{agda}}}
  We proceed by induction on the formula. We only consider the
  case $Dâ–·E$ as the other cases are easy.
  - \boxed{â‡’} Assume $wâŠ©Dâ–·E$ and let $C$ be such that $âŸ¨w,CâŸ©âˆˆW'$. We
    want to prove $âŸ¨w,CâŸ©âŠ©Dâ–·E$. Assume that for some $âŸ¨x,AâŸ©âˆˆW'$ we have
    $âŸ¨w,CâŸ©R'âŸ¨x,AâŸ©âŠ©D$. By IH it follows that $xâŠ©D$ and hence there exists $V$
    such that $xS_wVâŠ©E$. By $(C_0)$ there is some $yâˆˆV$ such that

    #+name: eq:verb-y-cond
    \begin{equation}
    âˆ€bV'.yS_bV'â‡’âˆƒvâˆˆV'. (b=w â‡’ xS_b\{v\}), (bRw â‡’ wS_b\{v\})
    \end{equation}

    We proceed by showing that there is some $B$ such that
    $âŸ¨x,AâŸ©S'_{âŸ¨w,CâŸ©}âŸ¨y,BâŸ©$. Let $B$ be defined thus:
    \[Bâ‰”\{âŸ¨u,vâŸ©: âˆƒY.yS_uY,vâˆˆY,(u=wâ‡’âŸ¨w,vâŸ©âˆˆA),(uRwâ‡’âŸ¨u,vâŸ©âˆˆC)\}\]

    To show $âŸ¨y,BâŸ©âˆˆW'$ we need to prove that $(W1)$ and $(W2)$ hold. The
    condition $(W1)$ follows immediately from the definition of $B$. To show
    $(W2)$ assume that for some $b$ and $V$ we have $yS_bV$. We need to see that
    there exists $vâˆˆV$ such that $âŸ¨b,vâŸ©âˆˆB$. From $yS_bV$ and [[eq:verb-y-cond]] we
    get that there exists $vâˆˆV'$ such that
    \begin{flalign}
    b=w &â‡’ xS_b\{v\} \label{eq:verb-b=w}, \\
    bRw &â‡’ wS_b\{v\} \label{eq:verb-2}
    \end{flalign}
    To show that $âŸ¨b,vâŸ©âˆˆB$ we first see that $b=wâ‡’âŸ¨w,vâŸ©âˆˆA$. Assume $b=w$, then
    by \ref{eq:verb-b=w} it follows that $xS_b\{v\}$ and therefore by condition
    $(W2)$ for $A$ it follows $âŸ¨b,vâŸ©âˆˆA$. We proceed likewise and use
    \ref{eq:verb-2} to show $bRwâ‡’âŸ¨b,vâŸ©âˆˆC$. This concludes the proof that
    $âŸ¨y,BâŸ©âˆˆW'$.

    We now check the conditions for $âŸ¨x,AâŸ©S'_{âŸ¨w,CâŸ©}âŸ¨y,BâŸ©$. We already have
    $âŸ¨w,CâŸ©R'âŸ¨x,AâŸ©$ by assumption. To see that $âŸ¨w,CâŸ©R'âŸ¨y,BâŸ©$ we first observe
    that $wRy$ holds since $xS_wV$ and $yâˆˆV$. Then assume that for some $b,z$ we
    have $bRw$ and $âŸ¨b,zâŸ©âˆˆB$. Then from the definition of $B$ it follows that
    $âŸ¨b,zâŸ©âˆˆC$. The condition $âˆ€v(âŸ¨w,vâŸ©âˆˆBâ‡’âŸ¨w,vâŸ©âˆˆA)$ follows immediately from the
    definition of $B$.

    Finally, since $VâŠ©E$ and $yâˆˆV$ we have $yâŠ©E$ and thus by IH it follows that
    $âŸ¨y,BâŸ©âŠ©E$.

  - \boxed{â‡} We proceed by contraposition. Assume $wâŠ®Dâ–·E$, then there exists
    $x$ such that $wRx$ and
    #+name: eq:verb-neg
    \begin{equation}
    âˆ€Y(vS_wYâ‡’âˆƒyâˆˆY(yâŠ®E)).
    \end{equation}

    Let $A$ be defined thus:
    \[Aâ‰” \{âŸ¨b,vâŸ©:(âˆƒY.xS_bY,vâˆˆY),(b=wâ‡’M,vâŠ®E),(bRwâ‡’âŸ¨b,vâŸ©âˆˆC)\}.\]

    We first show that $âŸ¨x,AâŸ©âˆˆW'$. Condition $(W1)$ follows directly from the
    definition of $A$. To show that $(W2)$ holds assume that for some $b$ and
    $V$ we have $xS_bV$. We need to see that for some $vâˆˆV$ we have $âŸ¨b,vâŸ©âˆˆA$.
    Since $wRx$ and $xS_bV$ it follows from condition $(C_1)$ that there exists
    $vâˆˆV$ such that
    \begin{flalign}
    &xS_b\{v\}, \label{eq:verb-neg-b=w} \\
    bRwâ‡’&wS_b\{v\}. \label{eq:verb-neg-bRw}
    \end{flalign}
    The first condition to show $âŸ¨b,vâŸ©âˆˆA$, namely that $âˆƒY.xS_bY,vâˆˆY$, is met
    trivially. For the next condition assume $b=w$, then see that we have
    $xS_w\{v\}$ by \ref{eq:verb-neg-b=w} and thus by [[eq:verb-neg]] it follows that
    $vâŠ®E$. For the remaining condition assume $bRw$, then by \ref{eq:verb-neg-bRw} we
    have $wS_b\{v\}$ and thus by $(W2)$ for $C$ we have $âŸ¨b,vâŸ©âˆˆC$. Therefore we
    conclude $âŸ¨b,vâŸ©âˆˆA$ and thus $âŸ¨x,AâŸ©âˆˆW'$.

    To see that $âŸ¨w,CâŸ©R'âŸ¨x,AâŸ©$ we already have $wRx$ by assumption. The
    remaining condition, $âˆ€bz(bRxâ‡’âŸ¨b,zâŸ©âˆˆAâ‡’âŸ¨b,zâŸ©âˆˆC)$, follows directly from the
    definition of $A$.

    Since $xâŠ©D$, it follows from the IH that $âŸ¨x,AâŸ©âŠ©D$.

    Lastly, assume that for some $âŸ¨y,BâŸ©âˆˆW'$ we have $âŸ¨x,AâŸ©S'_{âŸ¨w,CâŸ©}âŸ¨y,BâŸ©$. By
    definition of $S'$ we have $xS_wy$ and thus $wRy$. By quasi-reflexivity of
    $S$ we then have $yS_w\{y\}$ and thus by $(W2)$ for $B$ we have $âŸ¨w,yâŸ©âˆˆB$.
    By definition of $S'$ we also have that $âˆ€v(âŸ¨w,vâŸ©âˆˆBâ‡’âŸ¨w,vâŸ©âˆˆA)$, hence
    $âŸ¨w,yâŸ©âˆˆA$. By definition of $A$ it follows that $yâŠ®E$ and by IH we have
    $âŸ¨y,BâŸ©âŠ®E$, which concludes the proof.
  {{{endproof}}}

  {{{begintheorem}}} If a generalized Veltman frame satisfies
  quasi-transitivity Condition 3, 4, 5 or 6, then it satisfies conditions
  $(C_0)$ and $(C_1)$. {{{endtheorem}}}

  {{{beginproof}}} {{{agda}}} Here we prove the property for a generalized
  Veltman frame satisfying quasi-transitivity Condition 3. Conditions 4, 5 and 6
  imply Condition 3 as shown in Theorem [[theorem:trans]].

  Assume $F$ is a generalized Veltman frame satisfying quasi-transitivity
  Condition 3.
  It is easy to observe that the following property holds:
  #+name: eq:verb-trans-prop
  \begin{equation}
  uS_xY â‡’ âˆƒ\, yâˆˆY\, âˆ€ z(yS_x\{z\} â‡’ uS_x\{z\}).
  \end{equation}
  - \boxed{(Câ‚€)} Assume that for some $w,x,V$ we have $xS_wV$. Then by
    [[eq:verb-trans-prop]] there is some $yâˆˆV$ such that
    #+name: eq:verb-trans-y
    \begin{equation}
     âˆ€ z(yS_w\{z\} â‡’ xS_w\{z\}).
    \end{equation}

    Now assume that for some $b,V'$ we have $yS_bV'$. It follows by
    [[eq:verb-trans-prop]] that there is some $vâˆˆV'$ such that
    #+name: eq:verb-trans-v
    \begin{equation}
     âˆ€ z(vS_b\{z\} â‡’ yS_b\{z\}).
    \end{equation}
    Assume that $b=w$, we need to see that $xS_b\{v\}$. From $xS_wV$ and $yâˆˆV$
    it follows that $wRy$. Then by quasi-reflexivity we have $yS_w\{y\}$ and by
    [[eq:verb-trans-y]] we get $xS_w\{v\}$ which is the same as $xS_b\{v\}$. Assume
    that $bRw$, we need to see that $wS_b\{v\}$. From $bRwRy$ we have
    $wS_b\{y\}$ and from property [[eq:verb-trans-prop]] we get
    #+name: eq:verb-trans-Sbyz
    \begin{equation}
    âˆ€z(yS_b\{z\}â‡’wS_b\{z\}).
    \end{equation}
    Then since $yS_bV'$ and $vâˆˆV'$ we have $bRv$ so by quasi-reflexivity we have
    $vS_b\{v\}$. Finally by [[eq:verb-trans-v]] we get $yS_b\{v\}$ and by
    [[eq:verb-trans-Sbyz]] we get $wS_b\{v\}$.
  - \boxed{(C_1)} Assume that for some $w,b,x,V$ we have $wRxS_bV$.
    By [[eq:verb-trans-prop]] it follows that there is some $vâˆˆV$ such that
    #+name: eq:verb-trans-SbxV
    \begin{equation}
     âˆ€z(vS_b\{z\} â‡’ xS_b\{z\}).
    \end{equation}
    We first see that $xS_b\{v\}$. From $xS_bV$ and $vâˆˆV$ we get $bRv$ and by
    quasi-reflexivity we get $vS_b\{v\}$. Then by [[eq:verb-trans-SbxV]] we have
    $xS_b\{v\}$. Assume $bRw$, we need to see $wS_b\{v\}$. By quasi-reflexivity
    we get $vS_b\{v\}$ and by [[eq:verb-trans-SbxV]] we get $xS_b\{v\}$. By $bRwRx$
    we get $wS_b\{x\}$ and thus by [[eq:verb-trans-prop]] we have
    #+name: eq:verb-Sbwx
    \begin{equation}
    âˆ€z(xS_b\{z\}â‡’wS_b\{z\}).
    \end{equation}
    Finally by $xS_b\{v\}$ and [[eq:verb-Sbwx]] we get $wS_b\{v\}$.
  {{{endproof}}}
* other

\printglossary

\printbibliography[
heading=bibintoc,
title=Bibliography
]


* Appendix
  :PROPERTIES:
  :END:
  All the Agda code goes here.
