#+latex_compiler: xelatex
#+latex_class: article
#+title: Interpretability logics
#+author: Jan Mas Rovira
#+subtitle: Master's thesis

#+latex_header: \usepackage{hyperref}
#+latex_header: \usepackage{graphicx}
#+latex_header: \usepackage{unicode-math}
#+latex_header: \usepackage{fontspec}
#+latex_header: \usepackage[x11names, table]{xcolor}
#+latex_header: \usepackage[margin=2.5cm]{geometry}
#+latex_header: \usepackage{lmodern}
#+latex_header: \setmonofont{FreeMono}
#+latex_header: \usepackage{cancel}
#+latex_header: \usepackage{amsthm}
#+latex_header: \usepackage{float}
#+latex_header: \usepackage{newunicodechar}
#+latex_header: \usepackage[toc,indexonlyfirst,docdef=restricted]{glossaries-extra}
#+latex_header: \usepackage[style=ieee]{biblatex}
#+latex_header: \usepackage{multicol}

#+latex_header: \bibliography{refs}
#+latex_header: \makeglossaries

#+latex_header: \hypersetup{colorlinks=true,urlcolor=DodgerBlue4,linkcolor=Firebrick4,citecolor=Green4}
#+latex_header: \newcommand{\ie}[0]{i.e.\ }
#+latex_header: \newcommand{\todo}[0]{\textcolor{red}{pending}}
#+latex_header: \newcommand{\pend}[0]{\textcolor{Tomato3}{pending }}
#+latex_header: \newcommand{\red}[1]{\textcolor{red}{#1 }}
#+macro: jan @@latex:{\color{red}@@Jan: $1@@latex:}@@

#+macro: begindef @@latex:\begin{definition}@@
#+macro: enddef @@latex:\end{definition}@@

#+macro: begincoro @@latex:\begin{corollary}@@
#+macro: endcoro @@latex:\end{corollary}@@

#+macro: beginremark @@latex:\begin{remark}@@
#+macro: endremark @@latex:\end{remark}@@

#+macro: begintheorem @@latex:\begin{theorem}@@
#+macro: endtheorem @@latex:\end{theorem}@@

#+macro: beginlemma @@latex:\begin{lemma}@@
#+macro: endlemma @@latex:\end{lemma}@@

#+macro: beginproof @@latex:\begin{proof}@@
#+macro: endproof @@latex:\end{proof}@@


#+macro: defglossary @@latex:\newglossaryentry{$1}{name=$2,description={$3}}@@
#+macro: defacronym @@latex:\newacronym{$1}{$2}{$3}@@


#+latex_header: \newtheorem{theorem}{Theorem}
#+latex_header: \theoremstyle{definition}
#+latex_header: \newtheorem{corollary}[theorem]{Corollary}
#+latex_header: \theoremstyle{definition}
#+latex_header: \newtheorem{lemma}[theorem]{Lemma}
#+latex_header: \theoremstyle{definition}
#+latex_header: \newtheorem{definition}[theorem]{Definition}
#+latex_header: \theoremstyle{definition}
#+latex_header: \newtheorem{remark}[theorem]{Remark}

#+latex_header: \newglossaryentry{agdaprf}{name={\includegraphics[height=\baselineskip]{img/agda}},description={A proof formalized in Agda}}

#+macro: beginmulticols @@latex:\begin{multicols}{$1}@@
#+macro: endmulticols @@latex:\end{multicols}@@

{{{defglossary(gvm,model,Generalized Veltman model)}}}
{{{defglossary(gvf,frame,Generalized Veltman frame)}}}
{{{defglossary(ovf,frame,Ordinary Veltman frame)}}}
{{{defglossary(ovm,model,Ordinary Veltman model)}}}
{{{defglossary(forcing-gen,{\ensuremath{⊩^{gen}_M}},Forcing relation for generalized semantics)}}}
{{{defglossary(forcing-ord,{\ensuremath{⊩^{ord}_M}},Forcing relation for ordinary semantics)}}}
{{{defglossary(choice-set,choice set,Choice set)}}}
{{{defglossary(noetherian,Noetherian,Conversely well-founded relation)}}}
#+latex_header: \newglossaryentry{dependent-pair}{name={dependent pair},description={A pair in which the type of the second component is indexed by the first component}}
#+latex_header: \newglossaryentry{sum type}{name={sum type},description={A disjunction of two ore more types}}
#+latex_header: \newglossaryentry{decidable model}{name={decidable model},description={A model whose forcing relation is decidable}}
#+latex_header: \newglossaryentry{Rel}{name={\texttt{Rel}},description={Homogeneous relation}}
#+latex_header: \newglossaryentry{REL}{name={\texttt{REL}},description={Heterogeneous relation}}
#+latex_header: \newglossaryentry{Pred}{name={\texttt{Pred}},description={A predicate or a subset}}

#+macro: agda @@latex:\gls{agdaprf}\glsadd{agdaprf}@@
#+latex_header: \newcommand{\prin}[1]{\text{$\mathsf{#1}$}}
#+latex_header: \newcommand{\kgen}[1]{\text{($\mathsf{#1}$)\textsubscript{gen}}}
#+latex_header: \newcommand{\kord}[1]{\text{($\mathsf{#1}$)\textsubscript{ord}}}

#+latex_header: \newcommand{\joost}[1]{\textcolor{purple}{\bf Joost: #1}}
#+latex_header: \newcommand{\jan}[1]{\textcolor{orange}{\bf Jan: #1}}
#+latex_header: \newcommand{\luka}[1]{\textcolor{blue}{\bf Luka: #1}}

# Missing monospaced characters
#+latex_header: \setmathfont{XITS Math}
#+latex_header: \newfontfamily{\myfont}{XITS Math}
#+latex_header: \newunicodechar{𝕎}{\makebox[1em]{\myfont𝕎}}
#+latex_header: \newunicodechar{｛}{\ensuremath{\{}}
#+latex_header: \newunicodechar{｝}{\ensuremath{\}}}
#+latex_header: \setmathfont{Latin Modern Math}

* Introduction
** Overview of interpretability logics
** Original contributions
   This work includes the following original contributions:
   1. Generalized frame condition for $R₁$ (in collaboration with Luka). [[theorem:R₁][Link]];
   2. generalized frame condition for $Rⁿ$. [[theorem:Rⁿ][Link]];
   3. analysis of transitivity. [[theorem:trans][Link]];
   4. every Agda proof.

** Language
   <<sec:language>> The symbols of interpretability logics are $⊥,→,▷$.
   Formulas are defined recursively thus:
   \[Fm≔Var\ |\ ⊥\ |\ Fm→Fm \ |\  Fm▷Fm.\]

   We define $Var≔ℕ$. However, we use non-capital letters $a,b,c,x,y,z…$ to
   refer to variables.

   We define the usual operators and constants in the following way:

   1. $¬ A ≔ A → ⊥$;
   2. $⊤ ≔ ¬ ⊥$;
   3. $A ∨ B ≔ ¬ A → B$;
   4. $A ∧ B ≔ ¬ (A → ¬ B)$;
   5. $A ↔ B ≔ (A → B) ∧ (B → A)$;
   6. $□ A ≔ ¬ A ▷ ⊥$;
   7. $♢ A ≔ ¬ □ ¬ A$.

   The precedence of the operators is in the following order: $∧,▷,∨,→$.
** Notation
   Some notation that we use throughout the report:
   1. If $A$ and $B$ are binary relations, then $wAuBv$ means $wAu$ and $uBv$.
      For instance $wRuS_xv$ means $wRu$ and $uS_xv$. Another example: $wRu⊩A$
      means $wRu$ and $u⊩A$;
   2. $Y⊩A$ iff for all $y∈Y$ we have $y⊩A$;
   3. $Y⊮A$ iff there is some $y∈Y$ such that $y⊮A$;
   4. $⟦A⟧≔\{w:w⊩A\}$;
   5. {{{agda}}} this is Agda's logo. Each proof that is formalized in Agda
      has been tagged with it;
   6. When we write a dot after the quantification of some variables, the scope of
      the variables extends to the rightmost part of what follows. Hence the
      formula  $∀x∃y.Pxy∧∀z.Pyz$ is equivalent to $∀x∃y(Pxy∧∀z(Pyz))$.


   In Section [[sec:trans]] and [[sec:frame-condition]] we present some diagrams. We use
   straight arrows to represent the $R$ relation and curvy arrows to represent
   some $S_w$ relation. We sometimes use red ink when an arrow is in a positive
   position in the formula to emphasize its role. We use discontinuous arrows
   when it is quantified universally.

   We believe that diagrams can help the reader have a better understanding of
   the underlying formula, however, they are not meant to be a replacement as
   they cannot unambiguously convey all the information in the formula.

** Logic $IL$
   The logic $IL$ encompasses all classical tautologies in the new language plus
   the following axiom schemes:
   - K: $□ (A → B) → □ A → □ B$;
   - L: $□ (□ A → A) → □ A$;
   - J1: $□ (A → B) → A ▷ B$;
   - J2: $A ▷ B ∧ B ▷ C → A ▷ C$;
   - J3: $(A ▷ C ∧ B ▷ C) → (A ∨ B) ▷ C$;
   - J4: $A ▷ B → ♢ A → ♢ B$;
   - J5: $♢ A ▷ A$.
   If $A$ is an instantiation of any of the previous axiom schemes, then
   $⊢_{IL}A$. Additionally it has the following rules:
   - Necessitation: if $⊢_{IL}A$ then $⊢_{IL}□A$.
   - Modus ponens: if $Π⊢_{IL}A→B$ and $Π⊢_{IL}A$ then $Π⊢_{IL}B$.
   - Identity: If $A∈Π$ then $Π⊢_{IL}A$.

   While it is acceptable to have infinite sets of assumptions, when verifying
   properties in Agda we have restricted ourselves to finite sets. This
   restriction is not meaningful in the context of this project.

   {{{begintheorem}}} *Local soundness for ordinary semantics*. That is, if
   $Π⊢_{IL}A$ and $M$ is an ordinary model with a world $w$ such that $w⊩Π$,
   then $w⊩A$. {{{endtheorem}}} {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} <<theorem:il-sound>> *Local soundness for generalized
   semantics*. That is, if $Π⊢_{IL}A$ and $M$ is a generalized model with a world
   $w$ such that $w⊩Π$, then $w⊩A$. {{{endtheorem}}}

   {{{beginproof}}} {{{agda}}} We have verified this in Agda for all the presented
   quasi-transitivity conditions in Table [[fig:table-trans]]. {{{endproof}}}

   {{{begintheorem}}} *Weakening*. If
   $Π⊢_{IL}A$ then $B,Π⊢_{IL}A$. {{{endtheorem}}}
   {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} *Deduction*.
   $Π⊢_{IL}A→B$ iff $A,Π⊢_{IL}B$. {{{endtheorem}}}
   {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} *Cut*. If
   $Π⊢_{IL}B$ and $B,Π⊢_{IL}A$ then $Π⊢_{IL}A$. {{{endtheorem}}}
   {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} *Structurality*. If $Π⊢_{IL}B$ and $σ$ is a
   substitution then $σ[Π]⊢_{IL}σ(A)$. {{{endtheorem}}} {{{beginproof}}}
   {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} *Conjunction*. $Π⊢_{IL}A∧B$ iff $Π⊢_{IL}A$ and $Π⊢_{IL}B$.
   {{{endtheorem}}} {{{beginproof}}} {{{agda}}} {{{endproof}}}

   {{{begintheorem}}} The following holds:
    1. $⊢_{IL} A → A$;
    2. $⊢_{IL} A ▷ A$;
    3. $⊢_{IL} (A → B) → (B → C) → A → C$;
    4. $⊢_{IL} A → ¬ ¬ A$;
    5. $⊢_{IL} (¬ ¬ A) → A$;
    6. $⊢_{IL} (A → B) → ¬ B → ¬ A$;
    7. $⊢_{IL} A → ⊤$;
    8. $⊢_{IL} ⊥ → A$;
    9. $⊢_{IL} ¬ A → A → B$;
    10. $⊢_{IL} A ∧ B → A$;
    11. $⊢_{IL} A ∧ B → B$;
    12. $⊢_{IL} (A → B → C) → B → A → C$;
    13. $⊢_{IL} A → B → A ∧ B$;
    14. $⊢_{IL} A → A ∨ B$;
    15. $⊢_{IL} B → A ∨ B$;
    16. $⊢_{IL} A ▷ (A ∨ ♢ A)$;
    17. $⊢_{IL} (A ∨ ♢ A) ▷ A$;
    18. $⊢_{IL} A → B ⇒ ⊢_{IL} □ A → □ B$;
    19. $⊢_{IL} A ↔ B ⇒ ⊢_{IL} □ A ↔ □ B$;
    20. $⊢_{IL} □ (A ∧ B) ↔ (□ A ∧ □ B)$;
    21. $⊢_{IL} A → B ⇒ ⊢_{IL} ♢ A → ♢ B$;
    22. $⊢_{IL} A ↔ B ⇒ ⊢_{IL} ♢ A ↔ ♢ B$;
    23. $⊢_{IL} ¬ (A ∧ B) ↔ ¬ A ∨ ¬ B$;
    24. $⊢_{IL} (A ∨ ¬ B) → (A ∧ B ∨ ¬ B)$.
   {{{endtheorem}}}
   {{{beginproof}}} {{{agda}}}
   {{{endproof}}}

** Semantics
   In this document we consider two variants of relational semantics for
   interpretability logics similar to Kripke semantics for other modal logics.

*** Ordinary Veltman semantics
    {{{begindef}}} <<def:ordinary-frames>> cite:modal-matters An ordinary
    Veltman \gls{ovf} $F=⟨W,R,S⟩$ is a structure constituted by a non-empty set
    of worlds $W$, a binary relation $R⊆W²$ and a ternary relation $S⊆W×W×W$. We
    write $wRu$ instead of $⟨w,u⟩∈R$ and $uS_wv$ instead of $⟨w,u,v⟩∈S$. The
    structure must satisfy the following conditions:

    1. $R$ is a transitive;
    2. $R$ is conversely well-founded. That is, there is no infinite ascending
       chain $w₁Rw₂R…$;
    3. if $uS_wv$ then $wRu$ and $wRv$;
    4. if $wRu$ then $uS_wu$;
    5. if $wRu$ and $uRv$ then $uS_wv$.
    6. for every $w$, $S_w$ is transitive;
    {{{enddef}}}


    {{{begindef}}} An ordinary Veltman \gls{ovm} $M=⟨F,V⟩$ is a structure
    constituted by an ordinary Veltman frame $F$ and a valuation $V⊆W×Var$. If
    $F=⟨W,R,S⟩$ we will write $M=⟨W,R,S,V⟩$ instead of $M=⟨⟨W,R,S⟩,V⟩$. {{{enddef}}}

    {{{begindef}}} <<def:ord-forcing>> Given a model $M$, we define a forcing
    relation $\gls{forcing-ord}⊆W × Fm$. We write $M,w⊩A$ instead of
    $⟨w,A⟩∈\gls*{forcing-ord}$ or simply $w⊩A$ when the model is clear from the
    context. We write $w⊮A$ when $⟨w,A⟩∉⊩_M$.
    1. $w⊮⊥$;
    2. if $p∈Var$, then $w⊩p$ iff $⟨w,p⟩∈V$;
    3. if $A,B∈Fm$, then $w⊩A→B$ iff if $w⊩A$ then $w⊩B$;
    4. if $A,B∈Fm$, then $w⊩A▷B$ iff if $wRu$ and $u⊩A$ then there exists $v$ such
       that $v⊩B$ and $uS_wv$.
    {{{enddef}}}

    If $F$ is an ordinary Veltman frame and $A$ a formula, we write $F⊩A$ to
    denote that for every valuation we have $⟨F,V⟩⊩A$.

    {{{begincoro}}}
    <<coro:ord-semantics>>
    It can be shown that:
    1. If $A,B∈Fm$, then $w⊩A∧B$ iff $w⊩A$ and $w⊩B$;
    1. If $A,B∈Fm$, then $w⊩A∨B$ iff $w⊩A$ or $w⊩B$;
    2. if $A∈Fm$, then $w⊩¬A$ iff $w⊮A$;
    3. if $A∈Fm$, then $w⊩♢A$ iff there exists $u$ such that $wRu$ and $u⊩A$;
    4. if $A∈Fm$, then $w⊩□A$ iff for every $u$ such that $wRu$ we have $u⊩A$.
    {{{endcoro}}}
    {{{beginproof}}}
    {{{agda}}}
    {{{endproof}}}

*** Generalized Veltman semantics
    {{{begindef}}} cite:mikec2019interpretability A generalized Veltman \gls{gvf}
    $F=⟨W,R,S⟩$ is a structure constituted by a non-empty set of worlds $W$, a binary
    relation $R⊆W²$ and a ternary relation $S⊆W×W×(𝒫(W)∖\{∅\})$. We write $wRu$
    instead of $⟨w,u⟩∈R$ and $uS_wY$ instead of $⟨w,u,Y⟩∈S$. The structure must
    satisfy the following conditions :

    1. $R$ is transitive; <<R-trans>>
    2. $R$ is conversely well-founded. That is, there is no infinite ascending
       chain $w₁Rw₂R…$;
    3. if $uS_wY$ then $wRu$ and for all $y∈Y$ we have $wRy$;
    4. /quasi-reflexivity/: if $wRu$ then $uS_w\{u\}$;
    5. if $wRu$ and $uRv$ then $uS_w\{v\}$;
    6. /quasi-transitivity/: if $uS_wY$ and $yS_wZ_y$ for all $y∈Y$, then
       $uS_w\left(⋃_{y∈Y}Z_y\right)$. This is a particular notion of
       quasi-transitivity, throughout this document we explore a total of eight
       notions, see Section [[sec:trans]].
    # 7. $S$ is monotone in the following sense: if $uS_wV⊆Z⊆\{u:wRu\}$ then
    #    $uS_wZ$.
    {{{enddef}}}

    {{{begindef}}}
    <<def:gen-frame>>
    A generalized Veltman \gls{gvm} $M=⟨F,V⟩$ is a structure
    constituted by a generalized Veltman \gls{gvf} $F$ and a valuation $V⊆W×Var$.
    {{{enddef}}}
    {{{begindef}}}
    Given a model $M$, we define a forcing relation $\gls{forcing-gen}⊆W ×
    Fm$. We use the same notational conventions as in the ordinary semantics.
    1. $w⊮⊥$;
    2. if $p∈Var$, then $w⊩p$ iff $⟨w,p⟩∈V$;
    3. if $A,B∈Fm$, then $w⊩A→B$ iff if $w⊩A$ then $w⊩B$;
    4. if $A,B∈Fm$, then $w⊩A▷B$ iff if $wRu$ and $u⊩A$ then there exists $Y$ such
       that $Y⊩B$ and $uS_wY$. When we write $Y⊩B$ we mean that for all $y∈Y$ we
       have $y⊩B$;
    {{{enddef}}}

    If $F$ is a generalized Veltman frame and $A$ a formula, we write $F⊩A$ to
    denote that for every valuation we have $⟨F,V⟩⊩A$.

    {{{begincoro}}} We can show the same results in Corollary [[coro:ord-semantics]]
    for generalized semantics:
    1. If $A,B∈Fm$, then $w⊩A∧B$ iff $w⊩A$ and $w⊩B$;
    1. If $A,B∈Fm$, then $w⊩A∨B$ iff $w⊩A$ or $w⊩B$;
    2. If $A∈Fm$, then $w⊩¬A$ iff $w⊮A$;
    3. If $A∈Fm$, then $w⊩♢A$ iff there exists $u$ such that $wRu$ and $u⊩A$;
    4. If $A∈Fm$, then $w⊩□A$ iff for every $u$ such that $wRu$ we have $u⊩A$.
    {{{endcoro}}}
    {{{beginproof}}}
    {{{agda}}}
    {{{endproof}}}

** Transitivity
   <<sec:trans>> In the literature one can find several semantic requirements
   for the quasi-transitivity condition. Theorem [[theorem:trans]] presents the
   some direct implications between them. Theorems [[theorem:il-sound]] and
   [[theorem:trans-extend]] are sufficient to argue that all of them are appropriate
   for proving completeness of IL.


#+name: fig:table-trans
#+caption: Semantic requirements for quasi-transitivity mentioned in the literature.
#+attr_latex: :align c|l|l :float t :center t :placement [H] :font \small
| Nr. | Semantic requirement for transitivity                                                  | Mentioned in                              |
|-----+----------------------------------------------------------------------------------------+-------------------------------------------|
| (1) | $uS_xY ⇒ ∀ \, \{ Y_y\}_{y∈ Y} \Big((∀\, y∈Y\ yS_xY_y) ⇒ ∃ Z⊆ ⋃_{y∈ Y}Y_y ∧ uS_xZ\Big)$ | This paper                                |
| (2) | $uS_xY ⇒ ∀ \, \{ Y_y\}_{y∈ Y} \Big((∀\, y∈Y\ yS_xY_y) ⇒ uS_x⋃_{y∈ Y}Y_y\Big)$          | Verbrugge '92 \cite{Verbrugge}            |
| (3) | $uS_xY ⇒ ∃\, y∈Y\, ∀ Y'(yS_xY' ⇒ ∃ \, Y''{⊆}Y' ∧ uS_xY'')$                             | This paper                                |
| (4) | $uS_xY ⇒ ∃\, y∈Y\, ∀ Y'(yS_xY' ⇒ uS_xY')$                                              | Joosten '98 \cite{joosten-master}         |
| (5) | $uS_xY ⇒ ∀\, y∈Y\, ∀ Y'(yS_xY' ⇒ ∃ \, Y''{⊆}Y' ∧ uS_xY'')$                             | This paper                                |
| (6) | $uS_xY ⇒ ∀\, y∈Y\, ∀ Y'(yS_xY' ⇒ uS_xY')$                                              | Verbrugge '92 \cite{Verbrugge}            |
| (7) | $uS_xY ⇒ ∀\, y∈Y\, ∀ Y'(yS_xY'\wedge y∉Y' ⇒ ∃ \, Y''{⊆}Y'\ uS_xY'')$                   | This paper                                |
| (8) | $uS_xY ⇒ ∀\, y∈Y\, ∀ Y'(yS_xY'\wedge y∉Y' ⇒ uS_xY')$                                   | Goris, Joosten '09 \cite{a-new-principle} |

   #+caption: Diagrams for conditions 2, 4 and 6.
   #+name: fig:diagrams-transitivity
   #+attr_latex: :float t :width 0.9\textwidth :placement [H]
   [[file:img/trans-2-4-6.pdf]]

# I NOW SEE THAT THE TABLE IN YOUR SECTION 1.6 HAS BEEN UPDATED IN OUR PAPER

# OF COURSE, YOU SHOULD ADAPT IT TO YOUR THESIS.
# SHORTLY WE WILL PUT IT ON THE ARXIV SO THAT YOU CAN INCLUDE A REFERENCE



 # All of the presented quasi-transitivity requirements are adequate for proving
 # IL soundness and completeness. For soundness it is routine to check that every
 # instantiation of $J2$ holds. For the completeness part it is enough to see that
 # any ordinary Veltman model $M=⟨W,R,S,V⟩$ can be transformed into a generalized
 # Veltman model $M'=⟨W,R,S',V⟩$ where $S'≔\{⟨w,x,\{y\}⟩:⟨w,x,y⟩∈S\}$ and see that
 # $M'$ has the same truth value as $M$. This has been verified in Agda.

 {{{begintheorem}}} <<theorem:trans>> Let $F$ be a generalized Veltman frame. Let
 $M≔∀w,u,V,Z(uS_wV⊆Z⊆\{u:wRu\}⇒uS_wZ)$ represent the monotonicity condition. The
 following implications hold.

 The first item should be read as $F⊨M∧(1)→(2)$.

 {{{beginmulticols(3)}}}

   1. $M ∧ (1) ⇒ (2)$
   2. $(2) ⇒ (1)$
   3. $M ∧ (3) ⇒ (4)$
   4. $(4) ⇒ (3)$
   5. $(5) ⇒ (1)$
   6. $M ∧ (5) ⇒ (2)$
   7. $(5) ⇒ (3)$
   8. $M ∧ (5) ⇒ (4)$
   9. $M ∧ (5) ⇒ (6)$
   10. $(5) ⇒ (7)$
   11. $M ∧ (5) ⇒ (8)$
   12. $(6) ⇒ (1)$
   13. $M ∧ (6) ⇒ (2)$
   14. $(6) ⇒ (3)$
   15. $(6) ⇒ (4)$
   16. $(6) ⇒ (5)$
   17. $(6) ⇒ (7)$
   18. $(6) ⇒ (8)$
   19. $M ∧ (7) ⇒ (8)$
   20. $(8) ⇒ (7)$

 {{{endmulticols}}} {{{endtheorem}}}

 {{{beginproof}}}
 {{{agda}}}
 {{{endproof}}}

 {{{begintheorem}}}
 <<theorem:trans-extend>>
 Given an ordinary Veltman model $M=⟨W,R,S,V⟩$ we can find some
 generalized Veltman model $M'=⟨W,R,S',V⟩$ satisfying transitivity
 $(i)∈\{1…8\}$ such that for every world $w$ and formula $A$: \[M,w⊩A⇔M',w⊩A.\]
 {{{endtheorem}}}

 {{{beginproof}}} We prove it for the transitivity condition (2) (the rest can
 be proven in the same way). Let $M=⟨W,R,S,V⟩$ be an ordinary model. Let
 $M'≔⟨W,R,S',V⟩$ with $S'$ defined thus: \[S'≔\{⟨w,x,\{y\}⟩:⟨w,x,y⟩∈S\}.\] It is
 easy to observe that $M'$ satisfies conditions $1,…,5$ from definition
 [[def:gen-frame]]. It is also easy to see that it satisfies transitivity 2. We show
 that they force the same formulas by induction on the complexity of the
 formula. The only interesting case is $A▷B$.
   - Assume $M,w⊩A▷B$ and that for some $x$ we have $wRx⊩A$. It follows that
     there exists some $y$ such that $xS_wy⊩B$. By definition of $M'$ we have
     $xS'_w\{y\}$ and also $\{y\}⊩B$, therefore $M',w⊩A▷B$.
   - Assume $M,w⊮A▷B$, then there exists some $x$ such that $wRx⊩A$ and
     $∀y(xS_wy⇒y⊮B)$. It is obvious that for $M'$ we have $∀y(xS'_w\{y\}⇒y⊮B)$
     and also $∀Y(xS'_wY⇒Y⊮B)$, which is the required property.
 {{{endproof}}}

** Monotonicity
   Consider the following monotonicity condition:

  #+begin_center
    if $uS_wV⊆Z⊆\{v:wRv\}$ then $uS_wZ$.
  #+end_center

  {{{begintheorem}}} <<theorem:mono>> Let $F=⟨W,R,S⟩$ be a generalized Veltman
  frame with quasi-transitivity $(i)∈\{1,…,8\}$.
  Let $F'=⟨W,R,S'⟩$ where $S'$ is the monotone closure of $S$:

  \[S'≔\{⟨w,x,Y'⟩ : ⟨w,x,Y⟩∈S, Y⊆Y'⊆\{u:wRu\}\}.\]

  Then $F'$ is a generalized Veltman frame satisfying quasi-transitivity
  Condition (2). Furthermore, let $V$ be an arbitrary valuation and $A$ an
  arbitrary formula. Let $M≔⟨F,V⟩$ and $M'≔⟨F',V⟩$. We have that for every world
  $w$: \[M,w⊩A⇔M',w⊩A.\] {{{endtheorem}}}


  {{{beginproof}}} {{{agda}}}

  We check conditions listed in definition [[def:gen-frame]].
  - Conditions 1 and 2 are clear since $R$ is unchanged;
  - condition 3 follows from the fact that in the definition of $S'$ we require
    $Y'⊆\{u:wRu\}$;
  - for conditions 4 and 5 observe that $S⊆S'$. Then, since these conditions hold for
    $F$ they also hold for $F'$;
  - for quasi-transitivity Condition (2) assume that $uS'_xY'$ and that for
    every $y'∈Y'$ we have $y'S'_xΥ_{y'}$. We need to show that
    $uS'_x⋃_{y'∈Y'}Υ_{y'}$. By definition of $S'$ it follows that there exists
    $Y⊆Y'$ such that $uS_xY$, furthermore, for every $y'∈Y'$ we have that there
    exists $f(Υ_{y'})⊆Υ_{y'}$ such that $y'S_xf(Υ_{y'})$. From $Y⊆Y'$ it follows
    that for all $y∈Y$ there exists $f(Υ_{y})⊆Υ_{y}$ such that $yS_xf(Υ_{y})$.
    Then by (2) for $F$ it follows that $uS_x⋃_{y∈Y}f(Υ_{y})$. Then see that
    $⋃_{y∈Y}f(Υ_{y})⊆⋃_{y'∈Y'}Υ_{y'}$. It remains to show
    $⋃_{y'∈Y'}Υ_{y'}⊆xR\{u:xRu\}$. Consider some $u$ such that there is some
    $y'∈Y'$ with $u∈Υ_{y'}$. By assumption we have $y'S'_xΥ_{y'}$ and thus
    $xRu$.
  To show $M,w⊩A⇔M',w⊩A$ we proceed by induction on $A$. The only
  interesting case is $A▷B$.
  - Assume that $M,w⊩A▷B$ and that there is some world $x$ such that $wRx$ and
    $M',x⊩A$. By IH we have $M,x⊩A$, so there exists some $Y$ such that $xS_wY$
    and $M,Y⊩B$. By IH we have $M',Y⊩B$ and by definition of $S'$ it follows
    that $xS'_wY$, therefore $M',w⊩A▷B$.
  - Assume that $M,w⊮A▷B$. It follows that there is some $x$ such that $wRx$,
    $M,x⊩A$ and $(⋆)\ ∀Y(xS_wY⇒M,Y⊮B)$. We want to prove that
    $∀Y'(xS'_wY'⇒M',Y'⊮B)$. Assume that for some $Y'$ we have $xS'_wY'$. By
    definition of $S'$ it follows there exists some $Y$ such that $Y⊆Y'$ and
    $xS_wY$. Hence by $(⋆)$ we have that $M,Y⊮B$ and thus there exists $y∈Y$
    such that $M,y⊮B$. By IH we get that $M',y⊮B$ and since $y∈Y⊆Y'$ we have
    $Y'⊮B$, so $M',w⊮A▷B$.
  {{{endproof}}}

  As we see in Theorem [[theorem:mono]] taking the monotone closure of each $S_w$ does not
  change the forcing relation and the resulting frame satisfies quasi-transitivity
  Condition (2).

  # The previous lemma allows us to safely assume that monotonicity is a condition
  # for a Veltman frame with quasi-transitivity (2).

  {{{beginremark}}} Taking the monotone closure of each $S_w$ is essentially
  different than assuming that each $S_w$ is monotone by definition of the
  frame, as then the forcing relation may change. In the following example we
  present a generalized Veltman model with Condition (8) that showcases such
  behaviour.

   #+caption: Example frame: $wRv_0,wRv_1,wRv_2,wRv_3$, $v_0S_w\{v_1\}$, $v_2S_w\{v_3\}$.
   #+name: fig:example-trans
   #+attr_latex: :float t :width 0.28\textwidth :placement [H]
   [[file:img/example.pdf]]

  Let $M$ be a model based on the frame displayed[fn::In the figure we do not
  show the $S_w$ relations required by quasi-reflexivity for clarity.] in figure
  [[fig:example-trans]] such that $⟦p⟧ = \{v_0\}$, $⟦q⟧ = \{v_2\}$. We see that
  $w⊩¬(p ▷ q)$ as $p$ is only true in $v_0$ and we only have $v_0S_w\{v_1\}$ and
  $v_0S_w\{v_0\}$ with $v_0⊮q$ and $v_1⊮q$. If we take the monotonic closure of
  $S$ we have $v_0S_w \{v_1, v_2\}$ and by quasi-transitivity (8) we get $v_0S_w
  \{v_3\}$ and consequently $w⊩¬(p ▷ q)$ is no longer true.

  {{{endremark}}}

* Frame conditions
  <<sec:frame-condition>> An interpretability principle is a schema of modal
  formulas that carries some special significance.

  JOOST: OF COURSE, YOU WILL NEED SOME GENERAL BACKGROUND. WHAT DOES FRAME
  VALIDITY MEAN, WHAT ARE FRAME CONDITIONS, ETC.

  In this section we present a series of principles in conjunction with their
  respective frame conditions for ordinary semantics as well as generalized
  semantics.
** The principle \prin{M}
   The \prin{M} principle reads as follows:
   \[A ▷ B → (A ∧ □ C) ▷ (B ∧ □ C).\]

   JOOST: AT SOME STAGE YOU SHOULD BE GIVING CONTEXT HERE. WHEN WAS THE
   PRINCIPLE INTRODUCED AND BY WHOM. ALSO, WHY IS IT IMPORTANT, ETC.

*** Ordinary semantics
   The frame condition for \prin{M} for ordinary semantics, we write $\kord{M}$,
   reads as follows:
   \[∀w,x,y,z(xS_w yRz ⇒ xRz).\]

   #+caption: Ordinary frame condition for \prin{M}.
   #+name: fig:ord-M-condition
   #+attr_latex: :float t :width 0.20\textwidth :placement [H]
   [[file:img/M-ord.pdf]]

   {{{begintheorem}}} For any ordinary frame $F$, we have that $F$ satisfies the
   $\kord{M}$ condition iff any model based on $F$ forces every instantiation of the \prin{M}
   principle. In symbols:

   \[F ⊨ \kord{M} ⇔ F ⊩ M.\] {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   - \boxed{⇒} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $w⊩A▷B$ and that there is a world $x$ such that $wRx$ and $x⊩A∧□C$.
     Our aim is to find a world $z$ such that $xS_wz⊩B∧□C$. Since $wRx⊩A$ and
     $w⊩A▷B$ there is a world $z$ such that $xS_wz⊩B$. We now show that $z⊩□C$.
     Consider an arbitrary $u$ such that $zRu$. By the frame condition it
     follows that $xRu$ and we know $x⊩□C$ hence $u⊩C$ and thus $z⊩□C$. Hence
     $z$ is the desired world.

   - \boxed{⇐} Let $a,b,c∈Var$, assume $F⊩a▷b→(a∧□c)▷(b∧□c)$. Assume also that
     for some $x,w,u$ we have $xS_wzRu$. Our goal is to prove $xRu$. Consider a
     model such that the following holds.
     \begin{flalign*}
     ⟦a⟧ &= \{x\}; \\
     ⟦b⟧ &= \{z\}; \\
     ⟦c⟧ &= \{v:xRv\}.
     \end{flalign*}
     We observe that $w⊩a▷b$ because $a$ is only forced in $x$ and we have
     $xS_wz⊩b$. Then it follows that $w⊩(a∧□c)▷(b∧□c)$. It is easy to observe
     that $x⊩a∧□c$, furthermore we have that by the definition of an ordinary frame
     $xS_wz⇒wRx$, hence $wRx$ and thus there must exist some $v$ such that
     $xS_wv⊩b∧□c$. Since $b$ is only true in $z$ it must be $z⊩b∧□c$. Then,
     because $zRu$ we have $u⊩c$, therefore $xRu$.
   {{{endproof}}}

*** Generalized semantics
   The frame condition for \prin{M} for generalized semantics, we write $\kgen{M}$,
   reads as follows:

   \[ ∀w,x,V(xS_wV⇒ ∃V'⊆V(xS_wV',∀v'∈V'∀z(v'Rz⇒xRz))).\]


   #+caption: Generalized frame condition for \prin{M}.
   #+name: fig:gen-M-condition
   #+attr_latex: :float t :width 0.20\textwidth :placement [H]
   [[file:img/wip.png]]

   {{{begintheorem}}} For any generalized frame $F$, we have that $F$ satisfies the
   $\kgen{M}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{M} principle. In symbols:

   \[F ⊨ \kgen{M} ⇔ F ⊩ M.\] {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   - \boxed{⇒} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $w⊩A▷B$ and that there is a world $x$ such that $wRx$ and $x⊩A∧□C$.
     Our aim is to find a set $Z$ such that $xS_wZ⊩B∧□C$. Since $wRx⊩A$ and
     $w⊩A▷B$ there is set $Z$ such that $xS_wZ⊩B$. Then by the $\kgen{M}$
     condition it follows that there is a set $Z'⊆Z$ such that $xS_wZ'$ and
     $∀v∈Z'∀z(vRz⇒xRz)$. Now we show $Z'⊩□C$. Let $v∈Z'$ and $u$ such that
     $vRu$, by the condition above it follows $xRu$ and since $x⊩□C$ we have
     $u⊩C$. Hence $Z'$ is the desired set.
   - \boxed{⇐} Let $a,b,c∈Var$ and assume $F⊩a ▷ b → (a ∧ □ c) ▷ (b ∧ □ c)$ and
     $uS_wV$. Consider a model satisfying the following
     \begin{flalign*}
     ⟦a⟧ &= \{u\}; \\
     ⟦b⟧ &= V; \\
     ⟦c⟧ &= \{v:uRv\}.
     \end{flalign*}
     We see that $w⊩a▷b$ since $a$ is only true in $u$ and we have $uS_wV⊩b$. It
     follows that ${w⊩(a ∧ □ c)▷(b∧□c)}$. It is easy to see that $u⊩a∧□c$, hence
     there must exist $V'$ such that $uS_wV'⊩b∧□c$. Clearly $V'⊆V$ since $b$ is
     forced exactly in $V$. Now let $v',z$ such that $v'∈V'$ and $v'Rz$. Since
     $v'⊩□c$, then $z⊩c$ and thus $uRz$. Therefore $V'$ is the desired set.
   {{{endproof}}}
** The principle \prin{M₀}
   The \prin{M₀} principle reads as follows:
   \[A ▷ B → ♢ A ∧ □ C ▷ B ∧ □ C.\]

*** Ordinary semantics
    The $\kord{M₀}$ condition reads as follows:
    \[∀w,x,y,z(wRxRyS_wz⇒xS_wz,∀u(zRu⇒xRu)).\]

   #+caption: Ordinary frame condition for \prin{M₀}.
   #+name: fig:M_0-ord
   #+attr_latex: :float t :width 0.25\textwidth :placement [H]
   [[file:img/M_0-ord.pdf]]

    {{{begintheorem}}} For any ordinary frame $F$, we have that $F$ satisfies the
    $\kord{M₀}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{M₀} principle. In symbols:

    \[F ⊨ \kord{M₀} ⇔ F ⊩ M₀.\] {{{endtheorem}}}

    {{{beginproof}}}
    {{{agda}}}
    - \boxed{⇒} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
      that $w⊩A▷B$ and that there exists some $x$ such that $wRx⊩ ♢ A ∧ □ C$. It
      follows that there exists some world $y$ such that $xRy⊩A$, then since
      $wRy$ and $w⊩A▷B$ there exists a world $z$ such that $yS_wz⊩B$. By the
      $\kord{M₀}$ condition we have that $xS_wz$ and $(⋆)\ ∀u(zRu⇒xRu)$. Hence,
      it remains to show $z⊩□C$. Consider some world $u$ such that $zRu$, by
      $(⋆)$ it follows that $xRu$ and since $x⊩□C$ we also have $u⊩C$.
    - \boxed{⇐} Let $a,b,c∈Var$ and assume $F⊩a ▷ b → (♢ a ∧ □ c) ▷ (b ∧ □ c)$ and
      assume that for some $w,x,y,z$ we have $wRxRyS_wz$. Consider a model based
      on $F$ such that the following holds:
      \begin{flalign*}
      ⟦a⟧ &= \{y\}; \\
      ⟦b⟧ &= \{z\}; \\
      ⟦c⟧ &= \{w:xRw\}.
      \end{flalign*}
      Observe that $w⊩a▷b$ since $a$ is forced only in $y$ and we have $yS_wz⊩b$.
      It follows that $w⊩(♢ a ∧ □ c) ▷ (b ∧ □ c)$. Clearly $x⊩♢a∧□c$, hence there
      must exist some world $v$ such that $xS_wv⊩b∧□c$ but since $b$ is only
      forced in $z$ we have $z=v$ and thus $xS_wz$. To prove the remaining
      implication let $u$ such that $zRu$, then $u⊩c$ and thus $xRu$.
    {{{endproof}}}

*** Generalized semantics
    The $\kgen{M₀}$ condition reads as follows:
    \[∀w,x,y,Y(wRxRyS_wY⇒∃Y'⊆Y(xS_wY',∀y'∈Y'∀z(y'Rz⇒xRz))).\]

   #+caption: Generalized frame condition for \prin{M₀}.
   #+name: fig:M_0-gen
   #+attr_latex: :float t :width 0.30\textwidth :placement [H]
   [[file:img/M_0-gen.pdf]]


    {{{begintheorem}}} For any ordinary frame $F$, we have that $F$ satisfies the
    $\kgen{M₀}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{M₀} principle. In symbols:

    \[F ⊨ \kgen{M₀} ⇔ F ⊩ M₀.\] {{{endtheorem}}}

    {{{beginproof}}}
    {{{agda}}}
    - \boxed{⇒} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
      that $w⊩A▷B$ and that there is a world $x$ such that $wRx⊩♢A∧□C$. Then
      there must exist some world $y$ such that $xRy⊩A$. Since $wRy$ and $w⊩A▷B$
      there exists some set $Y$ such that $yS_wY⊩B$. Then by the $\kgen{M₀}$
      condition we have that there exists some $Y'⊆Y$ such that $xS_wY'$ and
      $(⋆)\ ∀y'∈Y'∀z(y'Rz⇒xRz)$. Clearly $Y'⊩B$ since $Y'⊆Y$. To show that
      $Y'⊩□C$ consider some $y'∈Y'$ and some $z$ such that $y'Rz$. Then, by
      $(⋆)$ it follows that $xRz$ and since $x⊩□C$ we also have $x⊩C$.
    - \boxed{⇐} Let $a,b,c∈Var$ and assume $F⊩a ▷ b → (♢ a ∧ □ c) ▷ (b ∧ □ c)$
      and assume that for some $w,x,y,Y$ we have $wRxRyS_wY$. Then consider a
      model based on $F$ such that.
      \begin{flalign*}
      ⟦a⟧ &= \{y\}; \\
      ⟦b⟧ &= Y; \\
      ⟦c⟧ &= \{v:xRv\}.
      \end{flalign*}
      Observe that $w⊩a▷b$ as $a$ is only forced in $y$ and we have $yS_wY⊩b$.
      Consequently it holds that $w⊩(♢ a ∧ □ c) ▷ (b ∧ □ c)$. See also that
      $x⊩♢a$ since $xRy⊩a$ and also $x⊩□c$ by definition of the model. Then
      there must exist some set $Y'$ such that $xS_wY'⊩b∧□c$. Clearly $Y'⊆Y$ since
      $Y'⊩b$. To show the remaining condition pick some $y'∈Y'$ and some $z$
      such that $y'Rz$. Since $Y'⊩□c$ then $z⊩c$ and thus $xRz$.
    {{{endproof}}}

** The principle \prin{P₀}

   The \prin{P₀} principle reads as follows:
   \[A ▷ ♢ B → □ (A ▷ B).\]
*** Ordinary semantics
    The $(P₀)_{ord}$ condition reads as follows:
    \[∀w,x,y,z,u(wRxRyS_wzRu⇒yS_xu).\]

   #+caption: Ordinary frame condition for \prin{P₀}.
   #+name: fig:P_0-ord
   #+attr_latex: :float t :width 0.15\textwidth :placement [H]
   [[file:img/P_0-ord.pdf]]

   {{{begintheorem}}} For any ordinary frame $F$, we have that $F$ satisfies the
   $(P₀)_{ord}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{P₀} principle. In symbols:

   \[F ⊨ (P₀)_{ord} ⇔ F ⊩ P₀.\] {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   - \boxed{⇒} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $w⊩A▷♢B$ and that there is a world $x$ such that $wRx$. Our goal is to
     show that $x⊩A▷B$. Consider a world $y$ such that $xRy⊩A$. As $wRy$ and
     $w⊩A▷♢B$ then there exist some worlds $z,u$ such that $yS_wzRu⊩B$. By the
     $(P₀)_{ord}$ condition it follows that $yS_xu$ and thus $x⊩A▷B$.
   - \boxed{⇐} Let $a,b∈Var$ and assume $F⊩a ▷ ♢ b → □ (a ▷ b)$ and assume that
     $wRxRyS_wzRu$. We want to show $yS_xu$. Consider a model based on $F$ such
     that:
     \begin{flalign*}
     ⟦a⟧ = \{y \}; \\
     ⟦b⟧ = \{u \}.
     \end{flalign*}
     Observe that $w⊩a▷♢b$ as the only world that forces $a$ is $y$ and we have
     $yS_wz⊩♢b$, because $zRu⊩b$. Consequently we have $w⊩□(a▷b)$ and therefore
     $x⊩a▷b$. Then, since $xRy⊩a$ it follows that there exist some $v$ such that
     $yS_xv⊩b$, but since $b$ is only forced in $u$, it must be $u=v$ and so
     $yS_xu$.
   {{{endproof}}}

*** Generalized semantics
    The $(P_0)_{gen}$ condition reads as follows:
    \[∀w,x,y,Y,Z((wRxRyS_wY,∀y∈Y∃z∈Z(yRz))⇒∃Z'⊆Z(yS_xZ')).\]

   #+caption: Generalized frame condition for \prin{P₀}.
   #+name: fig:P_0-gen
   #+attr_latex: :float t :width 0.31\textwidth :placement [H]
   [[file:img/P_0-gen.pdf]]


   {{{begintheorem}}} For any generalized frame $F$, we have that $F$ satisfies the
   $(P₀)_{gen}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{P₀} principle. In symbols:

   \[F ⊨ (P₀)_{gen} ⇔ F ⊩ P₀.\] {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   - \boxed{⇒} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $w⊩A▷♢B$ and that there is a world $x$ such that $wRx$. We aim to show
     that $x⊩A▷B$. Assume there is a world $u$ such that $xRu⊩A$ and as $wRu$
     and $w⊩A▷♢B$ then there exists a set $Y$ $uS_xY⊩♢B$. Let $𝔹=\{w:w⊩B\}$.
     Then observe that $∀y∈Y$ there exists some $z∈𝔹$ since $Y⊩♢B$. Hence by the
     $(P₀)_{gen}$ condition there exists some $𝔹'⊆𝔹$ such that $yS_x𝔹'$. Clearly
     $𝔹'⊩B$, therefore $x⊩A▷B$.
   - \boxed{⇐} Let $a,b∈Var$ and assume $F⊩a ▷ ♢ b → □ (a ▷ b)$ and assume
     that for some $w,x,y,Y,Z$ we have $wRxRyS_wY$ and $(⋆)\ ∀y∈Y∃z∈Z(yRz)$.
     Consider a model based on $F$ such that:
     \begin{flalign*}
    ⟦a⟧ &= \{y\}; \\
    ⟦b⟧ &= Z.
     \end{flalign*}
     See that $w⊩a▷♢b$ as the only world that forces $a$ is $y$ and we have
     $yS_wY$ and by $(⋆)$ it follows that $Y⊩♢b$. Consequently it holds that
     $w⊩□(a▷b)$ and since $wRx$ then $x⊩a▷b$. Also, since $xRy⊩a$ then there
     exists $Z'$ such that $yS_xZ'⊩b$. Clearly $Z'⊩b$ implies $Z'⊆Z$ so we are
     done.
   {{{endproof}}}

** The principle \prin{R}
   The \prin{R} principle reads as follows:

   \[A ▷ B → ¬ (A ▷ ¬C) ▷ (B ∧ □ C)\ .\]

   IT WOULD BE NICE IF EACH PRINCIPLE HAS A SHORT DESCRIPTION: WHEN INTRODUCED,
   WHY, BY WHOM, WHY INTERESTING, CURRENT STATUS. WE CAN THINK IF WE DO THIS IN
   ONE SECTION FOR ALL OR EACH TIME WHEN THE PRINCIPLE IS INTRODUCED. OR
   POSSIBLY EVEN A MIXTURE OF BOTH

*** Ordinary semantics
    The $\kord{R}$ condition reads as follows:
    \[∀w,x,y,z\left(wRxRyS_wz⇒∀v(zRv⇒yS_xv)\right)\ .\]

   #+caption: Ordinary frame condition for \prin{R}.
   #+name: fig:ord-R-condition
   #+attr_latex: :float t :width 0.15\textwidth :placement [H]
   [[file:img/R-ord.pdf]]

\joost{TO NOT OVERLOAD WRITING, SHALL WE SPEAK OF FRAMES WHEN SPEAKING OF
REGULAR/ORDINARY FRAMES AND ONLY INDICATE GENERALISED WHERE NEEDED? LUKA, WHAT
DO YOU THINK?}

\luka{ I agree, that's what Croatian authors do}


   {{{begintheorem}}}
   For any ordinary frame $F$, we have that $F$ satisfies the
   $\kord{R}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{R} principle. In symbols:

   \[F ⊨ \kord{R} ⇔ F ⊩ R\ .\]
   {{{endtheorem}}}

   # LM: it would be good if you used \sf fonts when writing principles (\textsf{...}, \mathsf{...}, {\sf ...})
\joost{HERE AND IN THE THESIS IN GENERAL, I MISS A DISCUSSION ABOUT ASSURINGNESS. THIS
SHOULD BE ADDED AND USED. AT THIS PARTICULAR POINT IN YOUR PROOF YOU SHOULD
MENTION THAT y IS A C-assuring SUCCESSOR OF x SO THAT YOU OBTAIN (*).}

\luka{LM: Joost, would you use assuringness/criticality even in semantic context? I
would add a note, something along the lines of "of course, we can associate a
MCS with every world of a model, if we suppose e.g. that all propositional
variables p_i for i > ... are evaluated as false and let mcs(w) = {A : w \vdash
A}".}

a world \(y\) such that \(xRy⊩A\) and \((⋆)\ ∀v(yS_xv⇒v⊩C)\).

MAKE THIS FORMULA DISPLAYED. MOREOVER, IT IS BETTER TO GENERATE A LABEL. FOR EXAMPLE:


   {{{beginproof}}}
   {{{agda}}}
   - \boxed{⇒} Let $M$ be a model based on $F$ and let $w$ be any world. Assume
     that $w⊩A▷B$ and that there is a world $x$ such that $wRx⊩¬(A▷¬C)$. We need
     to see that there is some world $v$ such that $xS_wv⊩B∧□C$. From
     $x⊩¬(A▷¬C)$ we get a world $y$ such that $xRy⊩A$ and $(⋆)\ ∀v(yS_xv⇒v⊩C)$.
     Since $w⊩A▷B$, and by transitivity we have $wRy$, it follows that there
     exists a world $z$ such that $yS_wz⊩B$. To see that $z$ is the desired
     world we first see that $z⊩□C$. Let $u$ be such that $zRu$, then by
     $\kord{R}$ it follows that $yS_xu$ and by $(⋆)$ we get $u⊩C$. Finally, we
     have to see that $xS_wz$. Since $wRxRy$ we have that $xS_wy$ and we have
     $yS_wz$ from before, hence by transitivity of $S_w$ we get $xS_wz$.

   To see that \(z\) is the desired world. I WOULD SAY HERE: "WE HAVE TO VERIFY
TWO THINGS". THEN YOU MENTION THE TWO THINGS AND THEN YOU PROVE THEM ONE BY ONE.
LIKE THIS, YOU HELP THE NON-EXPERIENCED READER REMIND WHAT IS IT THAT YOU ARE
AFTER


   - \boxed{⇐} Let $a,b,c∈Var$ and assume that for some $w,x,y,z$ we have
     $wRxRyS_wz$ . Consider a model
     based on $F$ that satisfies the following.
    \begin{flalign*}
     ⟦a⟧ &= \{y\} \\
     ⟦b⟧ &= \{z\} \\
     ⟦c⟧ &= \{u:yS_xu\}
    \end{flalign*}
     By assumption we have that $w⊩a ▷ b → (¬ (a ▷ ¬c) ▷ (b ∧ □ c))$. Clearly
     $w⊩a▷b$ as we have $yS_wz⊩b$. Consequently it holds that $w⊩¬ (a ▷ ¬c) ▷ (b
     ∧ □ c)$. In order to show that $x⊩¬ (a ▷ ¬c)$, considering that $a$ is only
     forced in $y$, it suffices to observe that $∀z(yS_xz⇒z⊩c)$, which clearly
     holds. Then there must exist some world $v$ such that $xS_wv⊩b∧□c$ but
     $v=z$ since $z$ is the only world that forces $b$, hence $xS_wz⊩□c$. Now to
     show $∀v(zRv⇒yS_xv)$ consider some $v$ such that $zRv$. From $z⊩□c$ we get
     $v⊩c$ and thus $yS_xv$.
   {{{endproof}}}

*** Generalized semantics

    We first introduce the concept of choice set

   {{{begindef}}} If $xRy$ we say that a set of worlds $K$ is a \gls{choice-set} for
   $⟨x,y⟩$ iff for any $V$ such that $yS_xV$ we have $V∩K≠∅$. We denote the
   family of choice sets for $⟨x,y⟩$ by $𝒞(x,y)$. Note that this definition
   depends on the frame, but it should always be clear from context.
   {{{enddef}}}

    The $R_{gen}$ condition reads as follows:
    \begin{flalign*}
    &∀w,x,y,Y,K(wRxRyS_wY,K∈𝒞(x,y)   \\
    ⇒& ∃Y'⊆Y(xS_wY',∀y'∈Y'∀z(y'Rz→z∈K)))
    \end{flalign*}

   #+caption: Generalized frame condition for \prin{R}.
   #+name: fig:gen-R-condition
   #+attr_latex: :float t :width 0.35\textwidth :placement [H]
   [[file:img/R-gen.pdf]]

   {{{begintheorem}}}
   <<theorem:R⁰>>
   For any generalized frame $F$, we have that $F$ satisfies the
   $R_{gen}$ condition iff any model based on $F$ forces every instantiation of
   the \prin{R} principle. In symbols:

   \[F ⊨ R_{gen} ⇔ F ⊩ R\]
   {{{endtheorem}}}
   {{{beginproof}}}
   {{{agda}}}
   - \boxed{⇒} Let $M$ be a model based on $F$ assume there is a world $w$ such
     that $w⊩A▷B$ and a world $x$ such that $wRx$ and $x⊩¬(A▷¬C)$. We need to
     show that there is a set $Z$ such that $xS_wZ⊩B∧□C$. From $x⊩¬(A▷¬C)$ it
     follows that there is a world $y$ such that $xRy⊩A$ and $(⋆)\
     ∀V(yS_xV⇒∃c∈V(c⊩C))$. Consider the set $K≔\{c:c⊩C,∃V(c∈V,yS_xV)\}$. Clearly
     by $(⋆)$ it follows that $K$ is a choice set for $⟨x,y⟩$. By transitivity
     of $R$ we get $wRy$ and since $w⊩A▷B$ then there must exist some $Y$ such
     that $yS_wY⊩B$. We can now apply the $R_{gen}$ condition and get a $Y'⊆Y$
     such that $xS_wY'$ and $(†)\ ∀y'∈Y'∀z(y'Rz→z∈K)$. To show that $Y'$ is the
     desired set it remains to see that $Y'⊩B∧□C$. From the fact that $Y'⊆Y⊩B$
     it easily follows that $Y'⊩B$. Now, let $y'∈Y'$ and $u$ such that $y'Ru$,
     from $(†)$ we get $u∈K$ and by definition of $K$ we have $u⊩C$.
   - \boxed{⇐} Let $a,b,c∈Var$ and assume $F⊩ a ▷ b → (¬ (a ▷ ¬c) ▷ (b ∧ □ c))$.
     Assume also that for some $w,x,y,Y,K$ we have $wRxRyS_wY,K∈𝒞(x,y)$. Now
     consider a model based on $F$ that satisfies the following:
    \begin{flalign*}
    ⟦a⟧ &=\{y\} \\
    ⟦b⟧ &=Y \\
    ⟦c⟧ &= K \\
    \end{flalign*}
    By assumption we have $w⊩a ▷ b → (¬ (a ▷ ¬c) ▷ (b ∧ □ c))$. Observe that
     that $w⊩a▷b$ since $yS_wY⊩b$. Thus $w⊩¬ (a ▷ ¬c) ▷ (b ∧ □ c)$. Being $y$
     the only world that forces $a$, in order to show $x⊩¬(a▷¬c)$ we need to see
     that $∀V(yS_xV⇒∃z∈V(z⊩c))$, which is equivalent to $∀V(yS_xV⇒∃z∈V∩K)$ and
     this holds since $K∈𝒞(x,y)$. As a consequence of $x⊩¬(a▷¬c)$ we have that
     there exists a $Y'$ such that $xS_wY'⊩b∧□c$. From $Y'⊩b$ we get $Y'⊆Y$ and
     from $Y'⊩□c$ we get $∀y'∈Y'(∀z(y'Rz→z∈K))$, hence $Y'$ is the desired set.
   {{{endproof}}}

** The principle \prin{R₁}
  The $R_1$ principle reads as follows:
  \[A ▷ B → (¬(A ▷ ¬C)∧ (D▷♢E))▷(B∧□C∧(D▷E))\]

*** Ordinary semantics

    The $\kord{R_1}$ frame condition reads as follows:
    \[∀w,x,y,z(wRxRyS_wz⇒∀u(zRu⇒yS_xu,∀v(uS_xv⇒∀m(vRm⇒uS_zm))))\]

    # #+caption: Ordinary frame condition for \prin{R₁}
    # #+name: fig:ord-R₁-condition
    # #+attr_latex: :float t :width 0.20\textwidth :placement [H]
    # [[file:img/wip.png]]

    {{{begintheorem}}}
    For any ordinary frame $F$, we have that $F$ satisfies the
    $\kord{R_1}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{R₁} principle. In symbols:

    \[F ⊨ \kord{R_1} ⇔ F ⊩ R₁\]
    {{{endtheorem}}}

    {{{beginproof}}}
    The details of the proof can be found in cite:two-new-series.
    # - \boxed{⇐} Let $a,b,c,d,e∈Var$ and assume $F⊩ a ▷ b → ((¬ (a ▷ ¬c) ∧(d▷♢e))
    #   ▷ (b ∧ □ c ∧ (d▷e)))$. Consider some worlds $w,x,y,z,u,v,m$ and assume for
    #   a contradiction that $wRxRyS_wzRu,yS_xu⇒(uS_xv,vRm,u\cancel{S}_zm)$. Now
    #   consider a model based on $F$ that satisfies the following:
    #   \begin{flalign*}
    #   ⟦a⟧ &= \{y\} \\
    #   ⟦b⟧ &= \{z\} \\
    #   ⟦c⟧ &= \{w:yS_xw\} \\
    #   ⟦d⟧ &= \{?\} \\
    #   ⟦e⟧ &= \{?\} \\
    #   \end{flalign*}
    #   First observe that $w⊩a▷b$ since $a$ is only forced in $y$ and we have
    #   $yS_wz⊩b$. Therefore $w⊩¬ (a ▷ ¬c) ∧(d▷♢e) ▷ (b ∧ □ c ∧ (d▷e))$. Now we
    #   show that $x⊩¬ (a ▷ ¬c)$. Since $a$ is only forced in $y$ and $xRy$, we
    #   need to show that $∀u(yS_xu⇒u⊩c)$, which clearly holds. We proceed by
    #   showing $x⊩d▷♢e$ (????).
    # - \boxed{⇒} Let $M$ be a model based on $F$ assume there is a world $w$ such
    #   that $w⊩A▷B$ and a world $x$ such that $wRx$ and $x⊩¬(A▷¬C)∧(D▷♢E)$. Then
    #   there exists world $y$ such that $xRy⊩A$ and $(⋆)\ ∀v(yS_xv⇒v⊩C)$. As
    #   $wRy⊩A$ and $w⊩A▷B$ there exists a world $z$ such that $yS_wz⊩B$. It
    #   remains to show that $z⊩□C∧(D▷E)$. We first see that $z⊩□C$. Consider
    #   $v$ such that $zRv$, by $\kord{R_1}$ it follows that $yS_xv$ and by $(⋆)$
    #   we get $v⊩C$. Now we show $z⊩D▷E$. Let $u$ be such that $zRu⊩D$, we need
    #   to find some $m$ such that $uS_zm⊩E$. By $\kord{R_1}$ we get $yS_xu$ and
    #   $(†)\ ∀v,m((uS_xv,vRm)⇒uS_zm)$. See that $yS_xu$ implies $xRu$ and since
    #   $x⊩D▷♢E$ and $u⊩D$ we get that there is some $n$ such that $uS_xn⊩♢E$.
    #   Hence there is a world $m$ such that $nRm⊩E$. Finally by $(†)$ and $uS_xn$
    #   and $nRm$ we get $uS_zm$ and thus we have the desired $m$ and we conclude
    #   $z⊩D▷E$.
    {{{endproof}}}

*** Generalized semantics
    Some definitions:
    1. $R^{-1}[E] ≔ \{x : ∃y∈E. xRy\}$. $E$ denotes a set.
    2. $Rₓ^{-1}[E]≔R^{-1}[E]∩R[x]$. $E$ denotes a set.


    The $(R_1)_{gen}$ condition reads as follows:
    \begin{flalign*}
    &∀w,x,u,𝔹,ℂ,𝔼(wRxRuS_w𝔹, ℂ∈𝒞(x,u) \\
    ⇒\ & (∃𝔹'⊆𝔹)(xS_w𝔹',R[𝔹']⊆ℂ,(∀v∈𝔹')(∀c∈ℂ)(vRcSₓRₓ^{-1}[𝔼]⇒(∃𝔼'⊆𝔼)cS_v𝔼')))
    \end{flalign*}
    \begin{flalign*}
    &∀w,x,u,𝔹,ℂ,𝔼(wRxRuS_w𝔹, ℂ∈𝒞(x,u) \\
    ⇒\ & (∃𝔹'⊆𝔹)(xS_w𝔹',R[𝔹']⊆ℂ,(∀v∈𝔹')(∀c∈ℂ)(∃U⊆Rₓ^{-1}[𝔼],vRcSₓU)⇒(∃𝔼'⊆𝔼)cS_v𝔼')))
    \end{flalign*}

    {{{begintheorem}}}
    <<theorem:R₁>>
    For any generalized frame $F$, we have that $F$ satisfies the
    $(R₁)_{gen}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{R₁} principle. In symbols:

    \[F⊨(R₁)_{gen}⇔F⊩R₁\]
    {{{endtheorem}}}

    {{{beginproof}}}
    {{{agda}}}
    - \boxed{⇒} Let's fix the model and let $w ∈ W$ be arbitrary. Suppose $w⊩ A
      ▷B$, and let $x$ be such that $wRx$ and $x⊩ ¬(A ▷ ¬C) ∧ (D ▷ ♢E)$. It
      follows from $x ⊩¬(A ▷¬C)$ that there exists $u$ such that $xRu$, such
      that $u⊩A$, and for every $Z$ such that $uS_x Z$ there is some $c_Z ∈ Z$
      such that $c_Z ⊩C$. From $wRu$, $w⊩ A▷ B$ and $u⊩ A$ follows in particular
      that there is a $𝔹$, $uS_w 𝔹 ⊩B$. Let $ℂ ≔ \{c_Z: uS_x Z\}$. It is easy to
      check that $ℂ ∈ 𝒞(x, u)$. Let $𝔼 ≔ [⊩E]$ (set of worlds that force $E$).
      For the selected $w, x, u, 𝔹, ℂ, 𝔼$ the property $(R 1)_{gen}$ implies
      that there exists $𝔹' ⊆ 𝔹$ such that:

      \[xS_w𝔹',R[𝔹']⊆ℂ ,(∀v∈𝔹')(∀c∈ℂ)(vRcS_xR_x^{-1}[𝔼]⇒(∃𝔼'⊆𝔼)cS_v𝔼')\]

      We have that $𝔹' ⊩B$ since $𝔹'⊆𝔹$ and $𝔹'⊩□ C$ since $R[𝔹']⊆ℂ$. We now show
      that $𝔹'⊩ D▷ E$. Assume that for some $c ∈ R [𝔹']$ we have $c⊩ D$. From
      earlier we have $x⊩ D ▷ ♢E$. Since $c ∈ R [𝔹 '] ⊆ C ⊆ R [x]$, then $xRc$ so
      it follows that there exists $U$ such that $cS_x U$ and $U⊩♢E$. Clearly
      $U⊆[♢E]_x$ and also $[♢E]_x⊆R[x]$, hence by monotonicity we have
      $cS_x[♢E]_x$ which is the same as $cS_x R_x^{−1}[𝔼]$ so by the above
      property there exists $𝔼'⊆𝔼$ such that $cS_v 𝔼'$. Because $𝔼'⊆𝔼$ we have
      $𝔼'⊩E$.
    - \boxed{⇐} Assume for a contradiction that $F⊭(R₁)_{gen}$. It follows that
      there exist $w,x,u,𝔹,ℂ,𝔼$ such that $wRxRuS_w𝔹$, $ℂ∈𝒞(x,u)$ and:
      \[(∀𝔹'⊆𝔹)\left(xS_w𝔹', R[𝔹']⊆ℂ⇒ (∃v∈𝔹')(∃c∈ℂ)(∃Z⊆R_x^{-1}[𝔼].vRcS_xZ,∀𝔼'⊆𝔼.
      c\cancel{S}_v 𝔼')\right)\]

      Let $𝒱$ be a family of sets defined thus:
      \[𝒱≔ \{U : U⊆𝔹, xS_wU,R[U]⊆ℂ\}\]

      From the condition it follows that for every $U∈𝒱$ the following is valid:
      \[(∃v_U∈U)(∃c_U∈ℂ)(∃Z_U⊆R_x^{-1}[𝔼](v_URc_US_xZ_U,(∀𝔼'⊆𝔼) c_U\cancel{S}_{v_U} 𝔼'))\]

      Let us fix such $v_U$ and $c_U$ and $Z_U$ for all $U∈𝒱$.

      Define a valuation such that the following applies:
      \begin{flalign*}
      ⟦a⟧ &= \{u\} \\
      ⟦b⟧ &= 𝔹 \\
      ⟦c⟧ &= ℂ \\
      ⟦d⟧ &= \{c_U:U∈𝒱\} \\
      ⟦e⟧ &= 𝔼
      \end{flalign*}

      By assumption we have $w ⊩ a ▷ b → (¬(a▷¬c)∧(d▷♢e))▷(b∧□c∧(d▷e))$.

      It is easy to see that $w ⊩ a ▷ b$ and $x ⊩ ¬(a ▷ ¬c)$.

      Let us prove $x ⊩ d▷♢e$. Let $xRc⊩ D$. Then $c = c_U$ for some $U ∈ 𝒱$.
      From the definition of $c_U$ we have $c_U S_x Z_U$, a forcing is defined
      such that $e$ is true exactly on the set $𝔼$. Hence $R_x^{-1}[𝔼]⊩♢e$ and
      since $Z_U⊆R_x^{-1}[𝔼]$ it follows that $x ⊩ d▷♢e$.

      We can also check that for $U ∈ 𝒱$ we have $U⊩ b ∧ □c$ and the following
      following condition holds for any set $U$:
      \begin{flalign*}
        (⋆)\ xS_wU ,U⊩ b ∧ □c⇒U∈ 𝒱
      \end{flalign*}
      Then since $w⊩a▷b$ and $wRx⊩(a◁c)∧(d▷♢e)$ there must exist some set $U$
      such that $xS_wU⊩b∧□c∧(d▷e)$. From $(⋆)$ follows that that $U∈𝒱$ hence
      there exist $v_U,c_U,Z_U$ such that $Z_U⊆R_x^{-1}[𝔼]$ and
      $v_URc_US_xZ_U,(∀𝔼'⊆𝔼) c_U\cancel{S}_{v_U} 𝔼'$. Since $c_U⊩d$ there must
      exist some $Y$ such that $c_US_{v_U}Y⊩e$, however, by the definition of
      the valuation it follows that $Y⊆𝔼$ and thus $c_U\cancel{S}_{v_U} Y$,
      which is a contradiction.

    {{{endproof}}}

# \newpage
** The principle \prin{R_2} :noexport:
  The \prin{R_2} principle reads as follows:
  \[A₀ ▷ (B₀ ∧ (A₁ ▷ B₁)) → ¬(A₀ ▷ ¬C₀)∧ (E₁▷¬(A₁▷¬C₁))▷ B₀∧(A₁▷B₁)∧□C₀∧(E₁▷A₁)∧(E₁▷B₁∧□C₁)\]

*** Generalized semantics
    Some definitions:

    The $(R_2)_{gen}$ condition reads as follows:
    \begin{flalign*}
    &∀w,x,u,𝔹,ℂ,𝔼(wRxRuS_w𝔹, ℂ∈𝒞(x,u) \\
    ⇒\ & (∃𝔹'⊆𝔹)(xS_w𝔹',R[𝔹']⊆ℂ,(∀v∈𝔹')(∀c∈ℂ)(vRcSₓRₓ^{-1}[𝔼]⇒(∃𝔼'⊆𝔼)cS_v𝔼')))
    \end{flalign*}
    \begin{flalign*}
    &∀w,x,u,𝔹,ℂ,𝔼(wRxRuS_w𝔹, ℂ∈𝒞(x,u) \\
    ⇒\ & (∃𝔹'⊆𝔹)(xS_w𝔹',R[𝔹']⊆ℂ,(∀v∈𝔹')(∀c∈ℂ)(∃U⊆Rₓ^{-1}[𝔼],vRcSₓU)⇒(∃𝔼'⊆𝔼)cS_v𝔼')))
    \end{flalign*}

    {{{begintheorem}}}
    <<theorem:R₂>>
    For any generalized frame $F$, we have that $F$ satisfies the
    $(R₂)_{gen}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{R_2} principle. In symbols:

    \[F⊨(R₂)_{gen}⇔F⊩R₂\]
    {{{endtheorem}}}

    {{{beginproof}}}
    {{{endproof}}}

# \newpage

** The principle \prin{R¹}

   The \prin{R¹} principle reads as follows:
   \[A ▷ B → (♢¬(D ▷ ¬C)∧ (D▷A))▷(B∧□C)\]

*** Generalized semantics
    The $\kgen{R¹}$ condition reads as follows:
    \begin{flalign*}
    &∀w,x,y,z,𝔸,𝔹,ℂ,𝔻. \\
    &wRxRyRz, \\
    & (∀u.wRu,u∈𝔸⇒∃V.uS_wV,V⊆𝔹), \\
    & (∀u.xRu,u∈𝔻⇒∃V.uS_xV,V⊆𝔸), \\
    & (∀V.zS_yV⇒∃v∈V.v∈ℂ),      \\
    & z∈𝔻 \\
    ⇒\ & ∃V⊆𝔹(xS_wV,R[V]⊆ℂ)
    \end{flalign*}

    {{{begintheorem}}}
    For any generalized frame $F$, we have that $F$ satisfies the
    $\kgen{R¹}$ condition iff any model based on $F$ forces every instantiation of
    the \prin{R¹} principle. In symbols:

    \[F⊨\kgen{R¹}⇔F⊩R¹\]
    {{{endtheorem}}}


    {{{beginproof}}}
    {{{agda}}}
    - \boxed{⇒} Fix a model $M$ and a world $w$, we are to prove that $w⊩A ▷ B →
      (♢¬(D ▷ ¬C)∧ (D▷A))▷(B∧□C)$. For that assume that $w⊩A▷B$ and that for some
      $x,y,z$ we have $wRxRyRz$ and $x⊩D▷A$, $y⊩¬(D▷¬C)$, $z⊩D$. Now let
      $𝔸≔\{w:w⊩A\}$. We define $𝔹,ℂ,𝔻$ likewise for formulas $B,C,D$ respectively.
      It is routine to check that the left part of the implication of $\kgen{R¹}$
      is met. Hence there exist a set $V⊆𝔹$ such that $xS_wV$ and $R[V]⊆ℂ$. By the
      definition of the sets $𝔹$ and $ℂ$ it follows that $V⊩B∧□C$.
    - \boxed{⇐} Fix a frame $F$ and let $a,b,c,d$ be propositional variables and
      assume $F⊩a ▷ b → (♢¬(d ▷ ¬c)∧ (d▷a))▷(b∧□c)$. Assume that the left part
      of the implication of $\kgen{R¹}$ holds. Now consider a model extending
      $F$ such that:
      \begin{flalign*}
       ⟦a⟧ &= 𝔸 \\
       ⟦b⟧ &= 𝔹 \\
       ⟦c⟧ &= ℂ \\
       ⟦d⟧ &= 𝔻
      \end{flalign*}
      Now one can easily check that $w⊩A▷B$, $x⊩♢¬(D▷¬C)∧(D▷A)$, hence there exists $U$
      such that $xS_wU$ and $U⊩B∧□C$. From that we derive that $U⊆𝔹$ and $R[U]⊆ℂ$.
    {{{endproof}}}

** The principle $\prin{R²}$ :noexport:

   The $R²$ principle reads as follows:
   \[A ▷ B → (♢ [(E ▷ D) ∧ ♢ ¬ (E ▷ ¬ C)] ∧ (D ▷ A)) ▷ (B ∧ □ C) \]

*** Generalized semantics
    The $(R²)_{gen}$ condition reads as follows:
    \begin{flalign*}
    &∀w,x,y,z,s,𝔸,𝔹,ℂ,𝔻,𝔼.\\
    &wRxRyRzRs, \\
    & (∀u.wRu∈𝔸⇒∃V.uS_wV⊆𝔹), \\
    & (∀u.xRu∈𝔻⇒∃V.uS_xV⊆𝔸), \\
    & (∀u.yRu∈𝔼⇒∃V.uS_yV⊆𝔻), \\
    & (∀V.sS_zV⇒V∩ℂ≠0),      \\
    & s∈𝔻 \\
    ⇒\ & ∃V⊆𝔹.xS_wV,R[V]⊆ℂ
    \end{flalign*}

    {{{begintheorem}}}
    For any generalized frame $F$, we have that $F$ satisfies the
    $(R²)_{gen}$ condition iff any model based on $F$ forces every instantiation of
    the $R²$ principle. In symbols:

    \[F⊨(R²)_{gen}⇔F⊩R²\]
    {{{endtheorem}}}

    {{{beginproof}}}
    - \boxed{⇒} Fix a model and assume that for some world $w$ we have $w⊩A▷B$.
      Consider some $x$ such that $wRx⊩♢ [(E ▷ D) ∧ ♢ ¬ (E ▷ ¬ C)] ∧ (D ▷ A)$.
      Hence there exists some $y$ such that $xRy⊩(E ▷ D) ∧ ♢ ¬ (E ▷ ¬ C)$. It
      follows that there exists some $z$ such that $yRz⊩ ¬ (E ▷ ¬ C)$ and thus
      there exists some $s$ such that $zRs⊩E$ and $(⋆)\ ∀V(sS_zV⇒∃c∈V(c⊩C))$.
    - \boxed{⇐}
    {{{endproof}}}

** The principle \prin{Rⁿ}
   The \prin{R^n} principle is defined thus cite:two-new-series:
   \begin{flalign*}
   U_0 &≔ ♢¬(D_0▷¬C) \\
   U_{r+1} &≔ ♢((Dᵣ▷D_{r+1}) ∧ Uᵣ) \\
   \\
   R⁰& ≔ A ▷ B → ¬ (A ▷ ¬ C) ▷ B ∧ □ C \\
   R^{n+1}& ≔ A ▷ B → ((D_{n}▷A) ∧ U_{n}) ▷ B ∧ □ C
   \end{flalign*}
*** Ordinary semantics
    The frame condition for ordinary semantics $\kord{R^n}$ can be found in
    cite:two-new-series.

*** Generalized semantics
    The $\kgen{Rⁿ}$ condition reads as follows:
    \begin{flalign*}
    &∀w,x₀,…,x_{n-1},y,z,𝔸,𝔹,ℂ,𝔻₀,…,𝔻_{n-1}.\\
    &wRx_{n-1}R…Rx_0RyRz, \\
    & (∀u.wRu,u∈𝔸⇒∃V.uS_wV⊆𝔹), \\
    & (∀u.x_{n-1}Ru∈𝔻_{n-1}⇒∃V.uS_{x_{n-1}}V⊆𝔸), \\
    & (∀i∈\{1…n-1\}∀u.xᵢRu∈𝔻_i⇒∃V.uS_{x_i}V⊆𝔻_{i+1}), \\
    & (∀V.zS_yV⇒V∩ℂ≠0),      \\
    & z∈𝔻₀ \\
    ⇒\ & ∃V⊆𝔹.x_{n-1}S_wV,R[V]⊆ℂ
    \end{flalign*}
    {{{beginlemma}}}
    <<lemma:Rⁿ>>
    Let $M$ be a model, let $x$ be a world of $M$ and let $n∈ℕ$. For any $i≤n$ we have
    that if $M , x ⊩ U_i$ then there exist some worlds $y,z,x₀,…,x_{i}$ such that:
    1. $xᵢ=x$;
    2. $x_iR…Rx₀RyRz$;
    3. for all $j≤i$ we have that $M,x_j⊩U_j$;
    4. for all $j<i$ we have that $M,x_j⊩D_j▷D_{j+1}$;
    5. for all $V$ we have that if $zS_yV$ then $V∩\{w:M,w⊩C\}≠∅$;
    6. $M,z⊩D₀$.
    {{{beginproof}}}
    {{{agda}}}

    By induction on $i$.
    - For $i=0$ we have that $x⊩♢¬(D₀▷¬C)$. It follows that there exists some
      $y$ such that $xRy⊩¬(D₀▷¬C)$ and therefore there exists some $z$ such that
      $yRz⊩D₀$ and for any $V$, if $zS_yV$, then $V∩\{w:M,w⊩C\}≠∅$. It is clear
      that all claims are met.
    - For $i+1$ we have that $x⊩♢(D_i▷D_{i+1}∧U_i)$. It follows that there
      exists some $x_{i}$ such that $x_i⊩D_i▷D_{i+1}∧U_i$. By IH there exist
      $y,z,x₀,…,x_{i}$ such that satisfy claims $1…6$. We set $x_{i+1}≔x$. It is
      trivial to observe that by using the IH all conditions are met for $i+1$.
    {{{endproof}}}
    {{{endlemma}}}
    {{{begintheorem}}}
    <<theorem:Rⁿ>>
    For any generalized frame $F$, we have that $F$ satisfies
    the $\kgen{Rⁿ}$ condition iff any model based on $F$ forces every
    instantiation of the \prin{Rⁿ} principle. In symbols:

    \[F⊨\kgen{Rⁿ}⇔F⊩Rⁿ\]
    {{{endtheorem}}}

    {{{beginproof}}}
    {{{agda}}}

    If $n=0$ we refer to theorem [[theorem:R⁰]]. For $n+1$ proceed as follows.
    - \boxed{⇒} Fix a model and assume that for some world $w$ we have $w⊩A▷B$.
      Then assume also that $wRx⊩((Dₙ▷A)∧U_n)$. By lemma [[lemma:Rⁿ]] it follows
      that there exist $y,z,x₀,…,x_{n}$ satisfying $1…6$. Then let $𝔸≔⟦A⟧$,
      $𝔹≔⟦B⟧$, $ℂ≔⟦C⟧$ and for $i≤n$ let $𝔻ᵢ≔⟦Dᵢ⟧$. It is routine to check that
      the left part of the $(R^{n+1})_{gen}$ holds and thus we get that there exists
      some $V⊆𝔹$ such that $x_{n}S_wV$ and $R[V]⊆ℂ$. Since $V⊆𝔹$ we have that
      $x_{n}⊩B$ and since $R[V]⊆ℂ$ we have $x_{n}⊩□C$. Finally, since
      $x_{n}=x$ we conclude $x⊩B∧□C$.
    - \boxed{⇐} Fix a frame $F$ and let $a,b,c,d₀,…,dₙ$ be propositional
      variables and assume $F⊩R^{n+1}$. Assume that the left part of the
      implication of $(R^{n+1})_{gen}$ holds. Now consider a model based on $F$
      that satisfies the following:
      \begin{flalign*}
       ⟦a⟧ &= 𝔸 \\
       ⟦b⟧ &= 𝔹 \\
       ⟦c⟧ &= ℂ \\
       ⟦dᵢ⟧ &= 𝔻ᵢ, \text{ for all } i∈\{0…n\}
      \end{flalign*}
      Now one can routinely check that $w⊩A▷B$ and $x⊩((D_n▷A)∧U_n)$, hence there
      exists $U$ such that $xS_wU$ and $U⊩B∧□C$. From that we derive that $U⊆𝔹$
      and $R[U]⊆ℂ$.
    {{{endproof}}}

** The principle \prin{Rₙ}
   The $R_n$ principle is defined thus cite:two-new-series:
   \begin{flalign*}
   wip
   \end{flalign*}

   \newpage
** Generic generalized frame condition
   In this section we present a method that given a formula $A$, builds a (second
   order?) formula that is a generalized frame condition for $A$.

   {{{begindef}}} Given a generalized frame $F=⟨W,R,S⟩$ and a formula $A$ with
   $Var(A)=x₁,…,xₙ$. Let $ℱ$ be defined by (we write $𝕏_*$ instead of $𝕏₁,…,𝕏ₙ$).
 \begin{flalign*}
   ℱ&:\underbrace{𝒫(W)×⋯×𝒫(W)}_n×Fm→𝒫(W) \\
   ℱ(𝕏_*,xᵢ) &≔  𝕏ᵢ\\
   ℱ(𝕏_*,⊥) &≔ ∅ \\
   ℱ(𝕏_*,A→B) &≔ \{w:w ∈ ℱ(𝕏_*,A) ⇒ w ∈ ℱ(𝕏_*,B)\} \\
   ℱ(𝕏_*,A▷B) &≔ \{w:∀ u.(wRu,u∈ℱ(𝕏_*,A))⇒∃Y.uS_wY⊆ℱ(𝕏_*,B))\} \\
 \end{flalign*}

   Then define
   \[(A)^*_{gen}≔∀𝕏_*∀w∈W.w∈ℱ(𝕏_*,A) \]

   {{{enddef}}}

   {{{begintheorem}}}

   Let $A$ be a formula. For any generalized frame $F$, we have that $F$
   satisfies the $(A)^*_{gen}$ condition iff any model based on $F$ forces $A$.
   In symbols:

     \[F⊨(A)^*_{gen}⇔F⊩A\]
   {{{endtheorem}}}

   {{{beginproof}}}
   {{{agda}}}
   Proved in Agda.
   {{{endproof}}}

   {{{beginremark}}}
   For instance, if we want the frame condition for \prin{P₀} we look at
    \[(a ▷ ♢ b → □ (a ▷ b))^*_{gen}\]
    where $a,b$ are different variables.
   {{{endremark}}}
* The logic of Agda
  Everything about agda in general.
  Look here cite:norell:thesis.

** Universe hierarchy
   <<sec:universe-hierarchy>>
   In Agda we have $Setᵢ : Set_{i+1}$ for $i∈ℕ$.
** Positivity
   <<sec:positivity>>

   See cite:agda-doc.
* Agda in the project
  The goal of this section is to guide the reader through a brief practical
  introduction to the language while explaining some key parts of code that we
  have implemented.

  It is worth noting that we have started from scratch as we believe that no
  other previous work in interpretability logics has been done in Agda.

  The implementation relies on the Agda standard library cite:agda-stdlib.

** Naming conventions
   1. If we have =f : T= we say that =f= has type =T= or that =f= is a proof of =T=.
   2. If we have =f : A → B → C= we say =f= has arguments =A= and =B= and it has
      return type =C=.
** Modal formulas
   Here we present the Agda type that represents a formula as defined in section
   [[sec:language]]. It is a very simple type yet an insightful introductory example.

   First we define variables to be natural numbers:
   #+begin_src text
Var : Set
Var = Nat
   #+end_src

   We proceed by inductively defining the formula type: =Fm=. We add a
   constructor for variables and one for each primitive operator.
   #+begin_src text
data Fm : Set where
  var : Var → Fm
  ⊥' : Fm
  _↝_ : Fm → Fm → Fm
  _▷_ : Fm → Fm → Fm
   #+end_src
   There are a number of things to take notice:
   1. The =data= keyword is used to introduce the definition of a new type;
   2. the newly introduced =Fm= type is not indexed by any other type, hence it
      has type =Set= as indicated by =Fm : Set=;
   3. take the constructor =var=, which has type =Var → Fm=. This means that if
      we apply =var= to a variable (i.e. a natural number) we get a term of type
      =Fm=. For instance, =var 3= has type =Fm=.
   4. we have named the bottom constructor =⊥'= since the symbol =⊥= is commonly
      used in Agda. We have used the =↝= to denote an implication since =→= is a
      reserved symbol;
   5. the underscores in =_↝_= and =_▷_= mean that these constructors are infix
      operators. Thus, the following formula is syntactically valid: =(var 1 ▷
      var 0) ↝ ⊥'=.

      It is often the case that we define priority for our infix operators. The
      following code defines the /infixity/ of =_↝_= and =_▷_=
        #+begin_src text
      infixr 20 _↝_
      infixr 50 _▷_
        #+end_src
      The higher the number the more priority, hence we can drop the parentheses
      from the previous formula =var 1 ▷ var 0 ↝ ⊥'=. The $r$ in =infixr= stands
      for right associativity.

   We finally add definable operators as Agda functions. For instance, we define
   negation thus:
  #+begin_src text
infix 60 ¬'_
¬'_ : Fm → Fm
¬' a = a ↝ ⊥'
  #+end_src
  We use the symbol =¬'= instead of =¬= for the same reason we used =⊥'= instead
  of =⊥=.

** Predicates and relations
   <<sec:predicates>>
   In this section we give a short description on how to represent predicates
   and relations in Agda.

   We define a predicate to have the following type[fn::We leave universe
   polymorphism out for simplicity.]:\glsadd{Pred}
   #+begin_src text
   Pred : Set → Set₁
   Pred A = A → Set
   #+end_src
   Hence, a predicate on the elements of some type =A= is a function from =A= to
   =Set=.

   Relations follow the same pattern:\glsadd{REL}
   #+begin_src text
   REL : Set → Set → Set₁
   REL A B = A → B → Set
   #+end_src
   For homogeneous relations we use the name =Rel=:\glsadd{Rel}
   #+begin_src text
   Rel : Set → Set → Set₁
   Rel A = REL A A
   #+end_src

   Now consider as an example the natural numbers and the =≤= relation, which is
   defined inductively according to the following definition.
   1. For all $a∈ℕ$ we have $0≤a$;
   2. for all $a,b∈ℕ$ we have that if $a≤b$ then also $a+1≤b+1$.
   #+begin_src text
   data Nat : Set where
     zero : Nat
     suc : Nat → Nat

   data _≤_ : Rel Nat where
     z≤n : (a : Nat) → zero ≤ a
     s≤s : {a b : Nat} → a ≤ b → suc a ≤ suc b
   #+end_src
   Note that =≤= is the first indexed type that we present as it is indexed by
   two natural numbers. Keep in mind that =Rel Nat = Nat → Nat → Set=.
   If =t : a ≤ b= we say that =t= is a proof that =a= is less or equal than =b=.

   Let us prove that $1≤2$; hence we need to build a term of type =suc zero ≤
   suc (suc zero)=.
   #+begin_src text
   1≤2 : suc zero ≤ suc (suc zero)
   1≤2 = s≤s (z≤n (suc zero))
   #+end_src
   Note that we did not explicitly give parameters =a, b= for the =s≤s=
   constructor as they are declared in curly braces[fn::Arguments defined in
   curly braces do not need to be given explicitly so long as Agda can infer its
   values.] and can be inferred by the type =a ≤ b=. Note that we could have
   done the same with the argument =a= of =z≤n= but we keep it explicit for
   illustrating the difference.

   We can also build proofs recursively. Let us prove that =_≤_= is reflexive by
   induction:
   #+begin_src text
   ≤-refl : (a : Nat) → a ≤ a
   ≤-refl zero = z≤n zero
   ≤-refl (suc a) = s≤s (≤-refl a)
   #+end_src
   A key feature to notice is that we can name arguments and refer to them in
   subsequent arguments and in the return type. For instance here we have named
   =a= the first argument, which is a natural number. We use the syntax =(a :
   Nat)=. And then we use the name =a= to build the return type, that is: =a ≤ a=.

   We can also define the property of transitivity.
   #+begin_src text
   Transitive : {A : Set} → Rel A → Set
   Transitive R = ∀ {a b c} → R a b → R b c → R a c
   #+end_src
   We see that a proof that some relation is transitive is a function that given
   proofs of =R a b= and =R b c= constructs a proof of =R a c=. Notice that the
   arguments =a b c= are declared implicit as they can be inferred from the types
   =a ≤ b= and =b ≤ c=. Let us prove that =≤= is transitive:
   #+begin_src text
   ≤-trans : Transitive _≤_
   ≤-trans {a} {b} {c} (z≤n b) b≤c = z≤n c
   ≤-trans {suc a} {suc b} {suc c} (s≤s a≤b) (s≤s b≤c) = s≤s (≤-trans a≤b b≤c)
   #+end_src
   The previous proof works as follows. We perform induction on the proof of =a
   ≤ b=, that is, the first explicit argument.
   - Case =z≤n=; we know that =a = zero= and we can easily build a proof of
     =a ≤ c= by using the =z≤n= constructor.
   - Case =s≤s a≤b=; then is must be that the second proof is built using the
     =s≤s= constructor since we have =suc b=. Hence we have =a≤b : a ≤ b= and
     =b≤c : b ≤ c=. By using a recursive call (induction hypothesis) to
     =≤-trans= we can build a proof of =a ≤ c=. Finally we can apply the
     constructor =s≤s= to obtain a proof of =suc a ≤ suc c=.
** Top and bottom
   In Agda we call top (=⊤=) the unit type, i.e. the type with only one
   inhabitant.
   #+begin_src text
   data ⊤ : Set where
     tt : ⊤
   #+end_src
   For instance, we can define a predicate that is always satisfied thus:
   #+begin_src text
   Trivial : Pred Nat
   Trivial n = ⊤
   #+end_src
   It is always satisfied as we can build a proof of =Trivial= for any =n= using
   the =tt= constructor:
   #+begin_src text
   Trivial-n : (n : Nat) → Trivial n
   Trivial-n n = tt
   #+end_src

   We call bottom (=⊥=) the empty type.
   #+begin_src text
   data ⊥ : Set where
   #+end_src
   Notice that it has no constructors hence it is impossible to construct a term
   with type =⊥=. The bottom type is specially useful to define negation in Agda:
   #+begin_src text
   ¬ : Set → Set
   ¬ A = A → ⊥
   #+end_src
   The principle of explosion can be trivially proved thus:
   #+begin_src text
   explosion : {A : Set} → ⊥ → A
   explosion ()
   #+end_src
   Since the type =⊥= has no constructors when we pattern match against the
   argument we get an empty case (denoted by =()=) and thus there is no need to
   provide a term of type =A=.
** Sum types
   We say that a type is a \gls*{sum type} if it is the disjunction of two (or
   more) types.

   In Agda we can define a two options sum type in the following way:
   #+begin_src text
   data _⊎_ (A B : Set) : Set where
     inj₁ : A → A ⊎ B
     inj₂ : B → A ⊎ B
   #+end_src

   For instance, let us prove that every natural is either even or odd:
   #+begin_src text
   even odd : Pred Nat
   even zero = ⊤
   even (suc n) =
   #+end_src
** Dependent pairs
    Consider the following non-dependent pair definition (again, we present a non universe
    polymorphic version for simplicity):
    #+begin_src text
data _×_ (A B : Set) : Set where
  _,_ : A → B → A × B
    #+end_src
    Notice that =_×_= is a parameterized type as it has parameters =(A B :
    Set)=, which are the types of each component of the pair. Parameters are
    shared parameters by all constructors (in this case there is only one
    constructor).

    See that we can easily build a pair $⟨0,1⟩$ thus:
    #+begin_src text
    p : Nat × Nat
    p = zero , (suc zero)
    #+end_src

    We now introduce the notion of \glspl*{dependent-pair}, also called
    \(Σ\)-pairs. Consider the following definition.
    #+begin_src text
data Σ (A : Set) (B : A → Set) : Set where
  _,_ : (a : A) → (b : B a) → Σ A B
    #+end_src
    The only, although essential, difference, is that the type of the second
    parameter is indexed by the value of the first. This is specially useful to
    represent existential quantification. For instance, we can design a type
    that asserts that some predicate is satisfiable[fn::we could simply write
    =P= instead of =(λ a → P a)= since eta-reductions are valid in Agda.]:
    #+begin_src text
    Satisfiable : {A : Set} → Pred A → Set
    Satisfiable {A} P = Σ A (λ a → P a)
    #+end_src
    For instance:
    #+begin_src text
    TODO: show meaningful example of dependent pair
    #+end_src

    It useful to define the projection of each component:
    #+begin_src text
    proj₁ : {A : Set} {B : A → Set} → Σ A B → A
    proj₁ (a , b) = a

    proj₂ : {A : Set} {B : A → Set} → (p : Σ A B) → B (proj₁ p)
    proj₂ (a , b) = b
    #+end_src
** Noetherian relations
    We say that a relation is \gls*{noetherian} if it is conversely
    well-founded. We begin by formalizing the concept of infinite ascending
    chain in Agda. In order to do that, we define a coinductive record data type
    (cite:agda-doc) (cite:norell:thesis). A coinductive record is allowed to be
    infinite.

    #+begin_src text
record InfiniteChain {ℓW ℓR} {W : Set ℓW} (_<_ : Rel W ℓR) (a : W)
  : Set (ℓR ⊔ ℓW)where
  coinductive
  field
    b : W
    a<b : a < b
    tail : InfiniteChain _<_ b
    #+end_src

    We see that the previous record data type represents an infinite ascending
    chain starting at =a= of some relation =<=. It has three fields. =b=: The
    next element in the chain. =a<b=: A proof that $a < b$ and =tail=: an
    infinite chain starting at =b=.

    Then we can define being Noetherian as the negation of the existence of an
    infinite chain:
    #+begin_src text
Noetherian : ∀ {ℓR ℓW} {W : Set ℓW} → Rel W ℓR → Set (ℓR ⊔ ℓW)
Noetherian _<_ = ∀ {a} → ¬ (InfiniteChain _<_ a)
    #+end_src

    For instance, we can prove that a Noetherian relation is irreflexive. First
    we show that from a proof that $xRx$ we can build an infinite chain:
    #+begin_src text
infiniteRefl : ∀ {ℓ} {R : Rel A ℓ} {x} → R x x → InfiniteChain R x
InfiniteChain.b (infiniteRefl {x = x} Rxx) = x
InfiniteChain.a<b (infiniteRefl {x = x} Rxx) = Rxx
InfiniteChain.tail (infiniteRefl {x = x} Rxx) = infiniteRefl Rxx
    #+end_src

    And then we can apply the Noetherian definition.
    #+begin_src text
Noetherian⇒Irreflexive : ∀ {ℓR ℓW} {W : Set ℓW} {R : Rel W ℓR}
     → Noetherian R → ∀ {x} → ¬ R x x
Noetherian⇒Irreflexive noetherian Rxx = noetherian (infiniteRefl Rxx)
    #+end_src

    To see another example refer to the proof of soundness for J5 (pending).
** Ordinary semantics
   In this section we explain how we have represented ordinary Veltman semantics
   in Agda.

   To represent ordinary Veltman semantics in Agda, the first step is to
   define the type of an ordinary Veltman frame:
   #+begin_src text
record Frame : Set₁ where
  constructor frame
  field
    W : Set
    witness : W
    R : Rel W lzero
    S : Rel₃ W lzero
    R-trans : Transitive R
    R-noetherian : Noetherian R
    Sw⊆R[w]² : ∀ {w u v} → S w u v → R w u × R w v
    Sw-refl : ∀ {w u} → R w u → S w u u
    Sw-trans : ∀ {w} → Transitive (S w)
    R-Sw-trans : ∀ {w u v} → R w u → R u v → S w u v
   #+end_src
   The keyword =record= is used to define a new product type (a tuple) in which
   each component (or field) has a name.

   The first component, =W=, corresponds to the type of the worlds in the frame.
   The second component, =witness= is required to make sure that the set of
   worlds is not empty. The =R= and =S= components are the relations. The
   remaining components are the properties that must be satisfied according to
   definition [[def:ordinary-frames]]. Notice the =lzero= in the type of =R= and =S=
   which restricts this relations to be in the 0 level of the universe hierarchy
   (i.e. =R= has type =W → W → Set₀=, see [[sec:universe-hierarchy]]) as making them
   universe polymorphic has no gains for the purposes of this work and it would
   make code harder to read.

   We define a valuation on a frame thus:
   #+begin_src text
Valuation : Frame → Set₁
Valuation F = REL W Var lzero
  where open Frame F
   #+end_src

   And then we define a model to be a tuple of a frame and a valuation on that
   frame.
   #+begin_src text
record Model : Set₁ where
  constructor model
  field
    F : Frame
    V : Valuation F
   #+end_src

   Our next step is to define the forcing relation.
   #+begin_src text
data _,_⊩_ (M : Model) (w : MW M) : Fm → Set where
   ...
   #+end_src
   We set a model and a world of that model as parameters as they should be
   shared by all constructors. We leave the formula as an index as it may vary
   depending on the constructor. We should introduce a constructor for each case
   in definition [[def:ord-forcing]]:[fn::we have slightly
   simplified the types of the constructors below to make them more readable.]
   1. We do not need a constructor for =⊥'= as its absence implicitly implies that
      we can never build an instance of =M , w ⊩ ⊥'= regardless of =M= and =w=.
   2. if $x∈Var$, then $w⊩x$ iff $⟨w,x⟩∈V$;
      #+begin_src text
  var : {x : Var} → V w x → M , w ⊩ var x
      #+end_src
   3. if $A,B∈Fm$, then $w⊩A→B$ iff if $w⊩A$ then $w⊩B$;
      #+begin_src text
  impl : {A B : Fm} → ((M , w ⊩ A) → (M , w ⊩ B)) → M , w ⊩ (A ↝ B)
      #+end_src
   4. if $A,B∈Fm$, then $w⊩A▷B$ iff if $wRu$ and $u⊩A$ then there exists $v$ such
      that $v⊩B$ and $uS_wv$.
      #+begin_src text
   rhd : {A B : Fm} →
     ({u : W} → R w u → M , u ⊩ A → (Σ W λ v → S w u v × (M , v ⊩ B)))
     → M , w ⊩ A ▷ B
      #+end_src

   Unfortunately the definition above is not valid in Agda. The reason is that
   constructors =rhd= and =impl= both fail the positivity check (see
   [[sec:positivity]]). For instance, see that in the =impl= constructor we have
   =(M , w ⊩ A)= on the left of an arrow =→=.

   We have circumvented this problem by providing mutually recursive definitions
   for /forcing/ (=_,_⊩_=) and /not forcing/ (=_,_⊮_=).

   The type definition without the constructors is as follows.
   #+begin_src text
   data _,_⊮_ (M : Model) (w : MW M) : Fm → Set
   data _,_⊩_ (M : Model) (w : MW M) : Fm → Set
   #+end_src

   Next we provide the strictly positive types of each constructor of the
   =_,_⊩_= and =_,_⊮_= relations.
   1. For the =⊥'= constant.
      1. Forcing (=_,_⊩_=). No constructor is required.
      2. Not forcing (=_,_⊮_=).
        #+begin_example
        bot : M , w ⊮ ⊥'
        #+end_example
   2. For variables.
    1. Forcing (=_,_⊩_=).
       #+begin_src text
  var : {x : Var} → V w x → M , w ⊩ var x
       #+end_src
    2. Not forcing (=_,_⊮_=).
       #+begin_example
  var : {x : Var} → ¬ (V w x) → M , w ⊮ var x
       #+end_example

   3. For implication (=↝=).
    1. Forcing (=_,_⊩_=).
       #+begin_src text
  impl : {A B : Fm} → M , w ⊮ A ⊎ M , w ⊩ B → M , w ⊩ A ↝ B
       #+end_src
    2. Not forcing (=_,_⊮_=).
       #+begin_src text
  impl : {A B : Fm} → M , w ⊩ A → M , w ⊮ B → M , w ⊮ A ↝ B
       #+end_src
   4. For interpretability (=▷=).
    1. Forcing (=_,_⊩_=).
       #+begin_src text
  rhd : {A B : Fm} →
    (∀ {u} → R w u → M , u ⊮ A ⊎ (Σ W λ v → S w u v × M , v ⊩ B))
    → M , w ⊩ A ▷ B
       #+end_src
    2. Not forcing (=_,_⊮_=).
       #+begin_src text
  rhd : {A B : Fm} →
    Σ W (λ u → R w u × M , u ⊩ A × ((v : W) → (¬ S w u v) ⊎ M , v ⊮ B))
    → M , w ⊮ A ▷ B
       #+end_src

   Putting it all together results in the following definitions:
   #+begin_src text
data _,_⊩_ M w where
  var : {x : Var} → V w x → M , w ⊩ var x
  impl : {A B : Fm} → M , w ⊮ A ⊎ M , w ⊩ B → M , w ⊩ A ↝ B
  rhd : {A B : Fm} →
    (∀ {u} → R w u → M , u ⊮ A ⊎ (Σ W λ v → S w u v × M , v ⊩ B))
    → M , w ⊩ A ▷ B
   #+end_src
   #+begin_src text
data _,_⊮_ M w where
  var : {x : Var} → ¬ (V w x) → M , w ⊮ var a
  impl : {A B : Fm} → M , w ⊩ A → M , w ⊮ B → M , w ⊮ A ↝ B
  rhd : {A B : Fm} →
    Σ W (λ u → R w u × M , u ⊩ A × ((v : W) → (¬ S w u v) ⊎ M , v ⊮ B))
    → M , w ⊮ A ▷ B
  bot : M , w ⊮ ⊥'
   #+end_src

   To prove that =_,_⊩= and =_,_⊮= are indeed the negation of each other
   we should prove two lemmas; in Agda types[fn::=A ⇔ B ≔ A → B × B → A=]:
   {{{beginlemma}}}
   <<lemma:forcing-neg>>
   \hfill
   1. =∀ {M w A} → M , w ⊩ A ⇔ ¬ (M , w ⊮ A)=.
   2. =∀ {M w A} → ¬ (M , w ⊩ A) ⇔ M , w ⊮ A=.
   {{{endlemma}}} For lemma 1 we can prove $⇒$ and for lemma 2 we can prove $⇐$
   (see lemma [[lemma:equiv]]). However, it is not possible to prove the remaining
   directions. In general terms, this is due to the fact that in Agda (and in
   intuitionistic logic in general) we can prove that =(¬ A ⊎ B) → A → B= but we
   cannot prove =A → B → (¬ A ⊎ B)=. The reason being that we lack the law of
   excluded middle, as it is a non-constructive axiom. In order to prove the
   remaining directions we need to assume that the forcing relation is
   decidable.

   {{{begindef}}} We say that =M= is \gls*{decidable model} if for any world =w= and
   formula =A= we have that either =M , w ⊩ A= or =M , w ⊮ A=.

   In Agda terms:
   #+begin_src text
DecidableModel : Model → Set
DecidableModel M = ∀ w A → M , w ⊩ A ⊎ M , w ⊮ A
   #+end_src
   {{{enddef}}}

   {{{beginproof}}}
   {{{agda}}}

   Under the assumption that we restrict ourselves to decidable models we can
   prove lemma [[lemma:forcing-neg]].
   {{{endproof}}}

   {{{beginlemma}}} <<lemma:equiv>> The following is true[fn::Note that =MR M=
   is the =R= of the frame on which the model =M= is based. We give analogous
   definitions to =MW= and =MS=.]:

   1. =⊩⊥ : ∀ {M w} → ¬ (M , w ⊩ ⊥')=;
   2. =⊮→¬⊩ : ∀ {M w A} → M , w ⊮ A → ¬ (M , w ⊩ A)=;
   3. =⊩→¬⊮ : ∀ {M w A} → M , w ⊩ A → ¬ (M , w ⊮ A)=;
   4. =⊩MP : ∀ {M w A B} → M , w ⊩ A ↝ B → M , w ⊩ A → M , w ⊩ B=;
   5. =⊩¬ : ∀ {M w A} → (M , w ⊩ ¬' A) ⇔ (M , w ⊮ A)=;
   6. =⊮¬ : ∀ {M w A} → M , w ⊮ ¬' A ⇔ M , w ⊩ A=;
   7. =⊩¬¬ : ∀ {M w A} → M , w ⊩ ¬' ¬' A ⇔ M , w ⊩ A=;
   8. =⊮¬¬ : ∀ {M w A} → M , w ⊮ ¬' ¬' A ⇔ M , w ⊮ A=;
   9. =⊩∧ : ∀ {M w A B} → M , w ⊩ A ∧ B ⇔ (M , w ⊩ A × M , w ⊩ B)=;
   10. =⊮∧ : ∀ {M w A B} → M , w ⊮ A ∧ B ⇔ (M , w ⊮ A ⊎ M , w ⊮ B)=;
   11. =⊩∨ : ∀ {M w A B} → M , w ⊩ A ∨ B ⇔ (M , w ⊩ A ⊎ M , w ⊩ B)=;
   12. =⊩□ : ∀ {M w A} → M , w ⊩ □ A ⇔ (∀ {v} → MR M w v → M , v ⊩ A)=;
   13. =⊮□ : ∀ {M w A} → M , w ⊮ □ A ⇔ (Σ (MW M) λ u → MR M w u × M , u ⊮ A)=;
   14. =⊩♢ : ∀ {M w A} → M , w ⊩ ♢ A ⇔ (Σ (MW M) λ u → MR M w u × M , u ⊩ A)=;
   15. =⊮♢ : ∀ {M w A} → M , w ⊮ ♢ A ⇔ (∀ {u} → MR M w u → M , u ⊮ A)=;
   16. =⊩↝⇨ : ∀ {M w A B} → M , w ⊩ A ↝ B → M , w ⊩ A → M , w ⊩ B=;
   17. =⊩▷⇨ : ∀ {M w A B} → M , w ⊩ A ▷ B → (∀ {u} → MR M w u → M , u ⊩ A → Σ (MW M) λ v → (MS M) w u v × M , v ⊩ B)=.
   {{{endlemma}}}
   {{{beginproof}}} {{{agda}}} All of the above has been proven
   in Agda without assuming that the model is decidable. {{{endproof}}}


   {{{beginlemma}}} <<lemma:ord-equiv-dec>> A series of equivalences that can be proven for decidable
   models.

   1. =⊩↝ : ∀ {w A B} → M , w ⊩ A ↝ B ⇔ (M , w ⊩ A → M , w ⊩ B)=;
   2. =⊩▷ : ∀ {w A B} → M , w ⊩ A ▷ B ⇔
      (∀ {u} → MR M w u → M , u ⊩ A → Σ (MW M) λ v → (MS M) w u v × M , v ⊩ B)=;
   3. =⊩⇔¬⊮ : ∀ {w A} → M , w ⊩ A ⇔ (¬ M , w ⊮ A)=;
   4. =⊮⇔¬⊩ : ∀ {w A} → M , w ⊮ A ⇔ (¬ M , w ⊩ A)=.
   {{{endlemma}}} {{{beginproof}}} {{{agda}}} Note that we only need the
   decidability assumption for 1 ($⇐$), 2 ($⇐$), 3 ($⇐$) and 4 ($⇐$). {{{endproof}}}

   From now on, we always restrict ourselves to decidable models as the usage of
   lemma [[lemma:ord-equiv-dec]] is ubiquitous. If we were to assume that we are
   outside of Agda and that we accept the law of excluded middle as part of our
   metalogic, the mentioned assumption could be dropped.

** Subsets (predicates revisited)
   \glsadd{Pred}
   In Agda, the keyword =Set= refers to an Agda type (insert ref to previous
   section), which is the closest concept to regular mathematics /set/. In this
   section when we say /set/ we refer to a subset of an Agda type. The most
   natural way to represent subsets in Agda is to use predicates. See
   [[sec:predicates]] for an introduction. A predicate represents the characteristic
   function of the associated subset. For instance consider the predicate:
   #+begin_src text
   even : Pred Nat
   even = ...
   #+end_src
   Then =even= represents the subset of natural numbers that are even. It is
   important to note that predicates are always restricted to a specific type,
   in this case =Nat=, and for that reason the term /subset/ may be more adequate.

   Next we present how we represent in Agda common operations on sets.
   Assume for the below definitions that we have some =A : Set= in scope.
   1. \boxed{∈} A proof of membership is a simple function application.
      #+begin_src text
      _∈_ : REL A (Pred A)
      a ∈ X = X a
      #+end_src
      This definition is mostly superfluous but it helps to have a syntax closer
      to regular mathematics.
   2. \boxed{∉} A proof of non membership is function from a proof of membership to =⊥=.
      #+begin_src text
      _∉_ : REL A (Pred A)
      a ∉ X = ¬ (a ∈ X)
      #+end_src
   3. \boxed{⊆} A proof of inclusion =X ⊆ Y= is a function that maps a proof of
      membership to =X= to a proof of membership to =Y=.
      #+begin_example
      _⊆_ : Rel (Pred A)
      X ⊆ Y = ∀ {x} → x ∈ X → x ∈ Y
      #+end_example
   4. \boxed{∩} We use pairs to represent the intersection. Each component is a
      proof of membership to =X= and =Y= respectively.
      #+begin_src text
      _∩_ : Pred A → Pred A → Pred A
      X ∩ Y = λ x → x ∈ X × x ∈ Y
      #+end_src
   5. \boxed{∪} We use a sum type to represent the union.
      #+begin_src text
      _∪_ : Pred A → Pred A → Pred A
      X ∪ Y = λ x → x ∈ X ⊎ x ∈ Y
      #+end_src
   6. \boxed{∅}
      The empty set is represented by a characteristic constant function to =⊥=.
      #+begin_src text
      ∅ : Pred A
      ∅ = λ x → ⊥
      #+end_src
   7. \boxed{𝟏}
      Similarly, the universe set is represented by a characteristic constant function to =⊤=.
      #+begin_src text
      U : Pred A
      U = λ x → ⊤
      #+end_src
   8. \(\boxed{\{x\}}\) A singleton set is defined using equality (TODO: define
      equality in Agda).
      #+begin_example
      ｛_｝ : A → Pred A
      ｛ x ｝ = λ y → x ≡ y
      #+end_example
** Generalized semantics
   In this section we explain how we have represented generalized Veltman
   semantics in Agda.

   Analogously to ordinary semantics we start by defining a frame:

   #+begin_src text
record Frame {ℓ} : Set (lsuc ℓ) where
  constructor frame
  field
    W : Set
  𝕎 : Set₁
  𝕎 = Pred W lzero
  field
    witness : W
    R : Rel W lzero
    S : REL₃ W W 𝕎 lzero
    Swu-sat : ∀ {w u Y} → S w u Y → Satisfiable Y
    R-trans : Transitive R
    R-noetherian : Noetherian {ℓ} R
    Sw⊆R[w] : ∀ {w u Y} → S w u Y → R w u
    SwuY⊆R[w] : ∀ {w u Y} → S w u Y → ∀ {y} → y ∈ Y → R w y
    S-quasirefl : ∀ {w u} → R w u → S w u ｛ u ｝
    S-quasitrans : ∀ {w u V} → S w u V → (f : ∀ {v} → v ∈ V → Σ 𝕎 λ Z → S w v Z)
      → S w u λ {x → Σ W λ v → Σ (v ∈ V) λ v∈V → x ∈ proj₁ (f v∈V)}
    R-Sw-trans : ∀ {w u v} → R w u → R u v → S w u ｛ v ｝
    S-monotone : ∀ {w u} {V Z : 𝕎} → S w u V → V ⊆ Z → Z ⊆ R w → S w u Z
   #+end_src

   Notice that just below the definition of the field =W : Set=, we have introduced a
   definition of the type =𝕎 : Set₁=

** IL and syntactic proofs
* Verbrugge
  In this section we proof that given a generalized Veltman model that satisfies
  a certain property, we can build an ordinary Veltman model with the same
  associated forcing relation. For the rest of this section we fix a generalized
  Veltman model $M≔⟨W, R, S, V⟩$.

  We define an ordinary Veltman model $M'≔⟨W',R',S',V'⟩$ where
  \begin{flalign*}
  W'≔&\{⟨x,A⟩:A⊆W^2, \\ &(W1)\ ∀⟨u,v⟩∈A\ ∃Y(xS_uY,v∈Y), \\
  & (W2)\ ∀uV(xS_uV⇒∃v∈V(⟨u,v⟩∈A)\}; \\
  R'≔&\{⟨⟨x,A⟩,⟨y,B⟩⟩ : xRy,∀wz(wRx⇒⟨w,z⟩∈B⇒⟨w,z⟩∈A)\}; \\
  S'≔&\{⟨⟨w,C⟩,⟨x,A⟩,⟨y,B⟩⟩ : ⟨w,C⟩R'⟨x,A⟩,⟨w,C⟩R'⟨y,B⟩, ∀v(⟨w,v⟩∈B⇒⟨w,v⟩∈A) \}; \\
  V'≔&\{⟨⟨x, A⟩,var⟩: ⟨x,var⟩∈V, ⟨x,A⟩∈W'\}.
  \end{flalign*}

  {{{beginlemma}}}
  The structure $⟨W',R',S',V'⟩$ is an ordinary Veltman model.
  {{{endlemma}}}
  {{{beginproof}}}
  {{{agda}}} It is routine to check that all the requirement are satisfied.
  {{{endproof}}}

  Let the conditions $(C_0)$ and $(C_1)$ be defined thus:
  \begin{flalign*}
  (C₀)&≔∀wxV.xS_wV⇒∃y∈V.∀bV'.yS_bV'⇒∃v∈V'. (b=w ⇒ xS_b\{v\}), (bRw ⇒ wS_b\{v\}); \\
  (C₁)&≔∀wbxV.wRx⇒xS_bV⇒∃v∈V.xS_b\{v\},(bRw⇒wS_b\{v\}).
  \end{flalign*}
  {{{begintheorem}}}
  If $M$ satisfies both conditions $(C_0)$ and $(C_1)$ then
  for any world $⟨w,C⟩∈W'$ and formula $D$:
  \[w⊩D⇔⟨w,C⟩⊩D\]
  {{{endtheorem}}}
  {{{beginproof}}} {{{agda}}}
  We proceed by induction on the formula. We only consider the
  case $D▷E$ as the other cases are easy.
  - \boxed{⇒} Assume $w⊩D▷E$ and let $C$ be such that $⟨w,C⟩∈W'$. We
    want to prove $⟨w,C⟩⊩D▷E$. Assume that for some $⟨x,A⟩∈W'$ we have
    $⟨w,C⟩R'⟨x,A⟩⊩D$. By IH it follows that $x⊩D$ and hence there exists $V$
    such that $xS_wV⊩E$. By $(C_0)$ there is some $y∈V$ such that

    #+name: eq:verb-y-cond
    \begin{equation}
    ∀bV'.yS_bV'⇒∃v∈V'. (b=w ⇒ xS_b\{v\}), (bRw ⇒ wS_b\{v\})
    \end{equation}

    We proceed by showing that there is some $B$ such that
    $⟨x,A⟩S'_{⟨w,C⟩}⟨y,B⟩$. Let $B$ be defined thus:
    \[B≔\{⟨u,v⟩: ∃Y.yS_uY,v∈Y,(u=w⇒⟨w,v⟩∈A),(uRw⇒⟨u,v⟩∈C)\}\]

    To show $⟨y,B⟩∈W'$ we need to prove that $(W1)$ and $(W2)$ hold. The
    condition $(W1)$ follows immediately from the definition of $B$. To show
    $(W2)$ assume that for some $b$ and $V$ we have $yS_bV$. We need to see that
    there exists $v∈V$ such that $⟨b,v⟩∈B$. From $yS_bV$ and [[eq:verb-y-cond]] we
    get that there exists $v∈V'$ such that
    \begin{flalign}
    b=w &⇒ xS_b\{v\} \label{eq:verb-b=w}, \\
    bRw &⇒ wS_b\{v\} \label{eq:verb-2}
    \end{flalign}
    To show that $⟨b,v⟩∈B$ we first see that $b=w⇒⟨w,v⟩∈A$. Assume $b=w$, then
    by \ref{eq:verb-b=w} it follows that $xS_b\{v\}$ and therefore by condition
    $(W2)$ for $A$ it follows $⟨b,v⟩∈A$. We proceed likewise and use
    \ref{eq:verb-2} to show $bRw⇒⟨b,v⟩∈C$. This concludes the proof that
    $⟨y,B⟩∈W'$.

    We now check the conditions for $⟨x,A⟩S'_{⟨w,C⟩}⟨y,B⟩$. We already have
    $⟨w,C⟩R'⟨x,A⟩$ by assumption. To see that $⟨w,C⟩R'⟨y,B⟩$ we first observe
    that $wRy$ holds since $xS_wV$ and $y∈V$. Then assume that for some $b,z$ we
    have $bRw$ and $⟨b,z⟩∈B$. Then from the definition of $B$ it follows that
    $⟨b,z⟩∈C$. The condition $∀v(⟨w,v⟩∈B⇒⟨w,v⟩∈A)$ follows immediately from the
    definition of $B$.

    Finally, since $V⊩E$ and $y∈V$ we have $y⊩E$ and thus by IH it follows that
    $⟨y,B⟩⊩E$.

  - \boxed{⇐} We proceed by contraposition. Assume $w⊮D▷E$, then there exists
    $x$ such that $wRx$ and
    #+name: eq:verb-neg
    \begin{equation}
    ∀Y(vS_wY⇒∃y∈Y(y⊮E)).
    \end{equation}

    Let $A$ be defined thus:
    \[A≔ \{⟨b,v⟩:(∃Y.xS_bY,v∈Y),(b=w⇒M,v⊮E),(bRw⇒⟨b,v⟩∈C)\}.\]

    We first show that $⟨x,A⟩∈W'$. Condition $(W1)$ follows directly from the
    definition of $A$. To show that $(W2)$ holds assume that for some $b$ and
    $V$ we have $xS_bV$. We need to see that for some $v∈V$ we have $⟨b,v⟩∈A$.
    Since $wRx$ and $xS_bV$ it follows from condition $(C_1)$ that there exists
    $v∈V$ such that
    \begin{flalign}
    &xS_b\{v\}, \label{eq:verb-neg-b=w} \\
    bRw⇒&wS_b\{v\}. \label{eq:verb-neg-bRw}
    \end{flalign}
    The first condition to show $⟨b,v⟩∈A$, namely that $∃Y.xS_bY,v∈Y$, is met
    trivially. For the next condition assume $b=w$, then see that we have
    $xS_w\{v\}$ by \ref{eq:verb-neg-b=w} and thus by [[eq:verb-neg]] it follows that
    $v⊮E$. For the remaining condition assume $bRw$, then by \ref{eq:verb-neg-bRw} we
    have $wS_b\{v\}$ and thus by $(W2)$ for $C$ we have $⟨b,v⟩∈C$. Therefore we
    conclude $⟨b,v⟩∈A$ and thus $⟨x,A⟩∈W'$.

    To see that $⟨w,C⟩R'⟨x,A⟩$ we already have $wRx$ by assumption. The
    remaining condition, $∀bz(bRx⇒⟨b,z⟩∈A⇒⟨b,z⟩∈C)$, follows directly from the
    definition of $A$.

    Since $x⊩D$, it follows from the IH that $⟨x,A⟩⊩D$.

    Lastly, assume that for some $⟨y,B⟩∈W'$ we have $⟨x,A⟩S'_{⟨w,C⟩}⟨y,B⟩$. By
    definition of $S'$ we have $xS_wy$ and thus $wRy$. By quasi-reflexivity of
    $S$ we then have $yS_w\{y\}$ and thus by $(W2)$ for $B$ we have $⟨w,y⟩∈B$.
    By definition of $S'$ we also have that $∀v(⟨w,v⟩∈B⇒⟨w,v⟩∈A)$, hence
    $⟨w,y⟩∈A$. By definition of $A$ it follows that $y⊮E$ and by IH we have
    $⟨y,B⟩⊮E$, which concludes the proof.
  {{{endproof}}}

  {{{begintheorem}}} If a generalized Veltman frame satisfies
  quasi-transitivity Condition 3, 4, 5 or 6, then it satisfies conditions
  $(C_0)$ and $(C_1)$. {{{endtheorem}}}

  {{{beginproof}}} {{{agda}}} Here we prove the property for a generalized
  Veltman frame satisfying quasi-transitivity Condition 3. Conditions 4, 5 and 6
  imply Condition 3 as shown in Theorem [[theorem:trans]].

  Assume $F$ is a generalized Veltman frame satisfying quasi-transitivity
  Condition 3.
  It is easy to observe that the following property holds:
  #+name: eq:verb-trans-prop
  \begin{equation}
  uS_xY ⇒ ∃\, y∈Y\, ∀ z(yS_x\{z\} ⇒ uS_x\{z\}).
  \end{equation}
  - \boxed{(C₀)} Assume that for some $w,x,V$ we have $xS_wV$. Then by
    [[eq:verb-trans-prop]] there is some $y∈V$ such that
    #+name: eq:verb-trans-y
    \begin{equation}
     ∀ z(yS_w\{z\} ⇒ xS_w\{z\}).
    \end{equation}

    Now assume that for some $b,V'$ we have $yS_bV'$. It follows by
    [[eq:verb-trans-prop]] that there is some $v∈V'$ such that
    #+name: eq:verb-trans-v
    \begin{equation}
     ∀ z(vS_b\{z\} ⇒ yS_b\{z\}).
    \end{equation}
    Assume that $b=w$, we need to see that $xS_b\{v\}$. From $xS_wV$ and $y∈V$
    it follows that $wRy$. Then by quasi-reflexivity we have $yS_w\{y\}$ and by
    [[eq:verb-trans-y]] we get $xS_w\{v\}$ which is the same as $xS_b\{v\}$. Assume
    that $bRw$, we need to see that $wS_b\{v\}$. From $bRwRy$ we have
    $wS_b\{y\}$ and from property [[eq:verb-trans-prop]] we get
    #+name: eq:verb-trans-Sbyz
    \begin{equation}
    ∀z(yS_b\{z\}⇒wS_b\{z\}).
    \end{equation}
    Then since $yS_bV'$ and $v∈V'$ we have $bRv$ so by quasi-reflexivity we have
    $vS_b\{v\}$. Finally by [[eq:verb-trans-v]] we get $yS_b\{v\}$ and by
    [[eq:verb-trans-Sbyz]] we get $wS_b\{v\}$.
  - \boxed{(C_1)} Assume that for some $w,b,x,V$ we have $wRxS_bV$.
    By [[eq:verb-trans-prop]] it follows that there is some $v∈V$ such that
    #+name: eq:verb-trans-SbxV
    \begin{equation}
     ∀z(vS_b\{z\} ⇒ xS_b\{z\}).
    \end{equation}
    We first see that $xS_b\{v\}$. From $xS_bV$ and $v∈V$ we get $bRv$ and by
    quasi-reflexivity we get $vS_b\{v\}$. Then by [[eq:verb-trans-SbxV]] we have
    $xS_b\{v\}$. Assume $bRw$, we need to see $wS_b\{v\}$. By quasi-reflexivity
    we get $vS_b\{v\}$ and by [[eq:verb-trans-SbxV]] we get $xS_b\{v\}$. By $bRwRx$
    we get $wS_b\{x\}$ and thus by [[eq:verb-trans-prop]] we have
    #+name: eq:verb-Sbwx
    \begin{equation}
    ∀z(xS_b\{z\}⇒wS_b\{z\}).
    \end{equation}
    Finally by $xS_b\{v\}$ and [[eq:verb-Sbwx]] we get $wS_b\{v\}$.
  {{{endproof}}}
* other

\printglossary

\printbibliography[
heading=bibintoc,
title=Bibliography
]


* Appendix
  :PROPERTIES:
  :END:
  All the Agda code goes here.
