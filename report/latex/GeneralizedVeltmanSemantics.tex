\begin{spverbatim}
module _ where

open import Agda.Builtin.Nat using (Nat; suc; _+_)
open import Agda.Primitive using (Level; lzero; lsuc; _âŠ”_)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.List using (List)
open import Data.List.Relation.Unary.All using (All)
open import Data.Product
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚)
open import Function using (_âˆ˜_; case_of_)
open import Relation.Binary using (REL; Rel; Transitive; Reflexive)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; _â‰¢_; refl)
open import Relation.Nullary using (Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; ï½›_ï½; _âˆ©_; _âŠ†_; Satisfiable)

open import Formula using (Fm; Var; _â†_; âŠ¥'; _â–·_; var; Â¬'_)
open import Base using (Noetherian; RELâ‚ƒ; Relâ‚ƒ)
open import GeneralizedFrame using (FrameL; Frame; module Trans-conditions) public

module Generic
  (T : âˆ€ {â„“W â„“S} (W : Set â„“W) â†’ RELâ‚ƒ W W (Pred W â„“W) â„“S â†’ Set (lsuc â„“W âŠ” â„“S))
  where

  Valuation : âˆ€ {â„“W â„“R â„“S W R S} â†’ Frame {â„“W} {â„“R} {â„“S} W R S T â†’ Set (lsuc lzero âŠ” â„“W)
  Valuation {W = W} F = REL W Var lzero

  record Model
    {â„“W â„“R â„“S}
    (W : Set â„“W)
    (R : Rel W â„“R)
    (S : RELâ‚ƒ _ _ _ â„“S)
    (V : REL W Var lzero)
    : Set (lsuc â„“W âŠ” â„“R âŠ” â„“S) where
    constructor model
    field
      F : Frame {â„“W} {â„“R} {â„“S} W R S T

  infix 5 _,_âŠ®_
  data _,_âŠ®_ {â„“W â„“R â„“S W R S V} (M : Model {â„“W} {â„“R} {â„“S} W R S V) (w : W)
    : Fm â†’ Set (lsuc â„“W âŠ” â„“R âŠ” â„“S)

  infix 5 _,_âŠ©_
  data _,_âŠ©_ {â„“W â„“R â„“S W R S V} (M : Model {â„“W} {â„“R} {â„“S} W R S V) (w : W) : Fm â†’ Set (lsuc â„“W âŠ” â„“R âŠ” â„“S)

  data _,_âŠ©_ {â„“W} {â„“R} {â„“S} {W} {R} {S} {V} M w where
    var : âˆ€ {a : Var} â†’ a âˆˆ V w â†’ M , w âŠ© var a
    impl : âˆ€ {A B} â†’ M , w âŠ® A âŠ M , w âŠ© B â†’ M , w âŠ© A â† B
    rhd : âˆ€ {A B} â†’
      (âˆ€ {u} â†’ R w u â†’ M , u âŠ® A âŠ (âˆƒ[ Y ] (S w u Y Ã— (Y âŠ† M ,_âŠ© B))))
      â†’ M , w âŠ© A â–· B

  data _,_âŠ®_ {â„“W} {â„“R} {â„“S} {W} {R} {S} {V} M w where
    var : âˆ€ {a : Var} â†’ a âˆ‰ V w â†’ M , w âŠ® var a
    impl : âˆ€ {A B} â†’ M , w âŠ© A â†’ M , w âŠ® B â†’ M , w âŠ® A â† B
    rhd : âˆ€ {A B} â†’
      âˆƒ[ u ] (R w u Ã— M , u âŠ© A
      Ã— âˆ€ Y â†’ Satisfiable Y â†’ (Â¬ S w u Y) âŠ (Satisfiable (Y âˆ© (M ,_âŠ® B))))
      â†’ M , w âŠ® A â–· B
    bot : M , w âŠ® âŠ¥'

  DecidableModel : âˆ€ {â„“W â„“R â„“S W R S V} â†’ Model {â„“W} {â„“R} {â„“S} W R S V
    â†’ Set (lsuc â„“W âŠ” â„“R âŠ” â„“S)
  DecidableModel M = âˆ€ w A â†’ M , w âŠ© A âŠ M , w âŠ® A

  MultiDecidableModel : âˆ€ {â„“W â„“R â„“S W R S V} â†’ Model {â„“W} {â„“R} {â„“S} W R S V
    â†’ Set (lsuc â„“W âŠ” â„“R âŠ” â„“S âŠ” lsuc â„“W)
  MultiDecidableModel {â„“W = â„“W} {W = W} M =
    âˆ€ (Y : Pred W â„“W) A â†’ Y âŠ† M ,_âŠ© A âŠ Satisfiable (Y âˆ© (M ,_âŠ® A))

  SingleDecidableModel : âˆ€ {â„“W â„“R â„“S W R S V} â†’ {M : Model {â„“W} {â„“R} {â„“S} W R S V}
    â†’ MultiDecidableModel M â†’ DecidableModel M
  SingleDecidableModel x w A = case x ï½› w ï½ A of
    Î» { (injâ‚ x) â†’ injâ‚ (x refl) ; (injâ‚‚ (u , refl , snd)) â†’ injâ‚‚ snd}

  S-decidable : âˆ€ {â„“W â„“R â„“S W R S} â†’ (F :  Frame {â„“W} {â„“R} {â„“S} W R S T)
    â†’ Set (lsuc â„“W âŠ” â„“S)
  S-decidable {S = S} F = âˆ€ x y u â†’ (Î£ ğ• Î» U â†’ u âˆˆ U Ã— S x y U) âŠ (âˆ€ U â†’ S x y U â†’ u âˆ‰ U)
    where open Frame F

-- Frame validity
  infix 5 _*âŠ©_
  _*âŠ©_ : âˆ€ {â„“W â„“R â„“S W R S} â†’ Frame {â„“W} {â„“R} {â„“S} W R S T â†’ Fm â†’ Set (lsuc â„“W âŠ” â„“R âŠ” â„“S)
  F *âŠ© A = âˆ€ val w â†’ model {V = val} F , w âŠ© A

  infix 5 _*âŠ®_
  _*âŠ®_ : âˆ€ {â„“W â„“R â„“S W R S} â†’ Frame {â„“W} {â„“R} {â„“S} W R S T â†’ Fm â†’ Set (lsuc â„“W âŠ” â„“R âŠ” â„“S)
  F *âŠ® A = Î£ (Valuation F Ã— _) Î» { (val , w) â†’ model {V = val} F , w âŠ® A}
    where open Frame F

  _,_âŠ©*_ : âˆ€ {â„“W â„“R â„“S W R S V} â†’ (M : Model {â„“W} {â„“R} {â„“S} W R S V) (w : W) â†’ List Fm â†’ Set _
  M , w âŠ©* Î  = All (M , w âŠ©_) Î 

module _ where open Generic Trans-conditions.Trans-L public

module T1 where open Generic Trans-conditions.Trans-1 public
module T2 where open Generic Trans-conditions.Trans-2 public
module T3 where open Generic Trans-conditions.Trans-3 public
module T4 where open Generic Trans-conditions.Trans-4 public
module T5 where open Generic Trans-conditions.Trans-5 public
module T6 where open Generic Trans-conditions.Trans-6 public
module T7 where open Generic Trans-conditions.Trans-7 public
module T8 where open Generic Trans-conditions.Trans-6 public
\end{spverbatim}
