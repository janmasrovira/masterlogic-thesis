\begin{spverbatim}
module GeneralizedVeltmanSemantics.Properties.GenericFrameCond where

open import Function.Equivalence using (_â‡”_; equivalence; module Equivalence)

open import Agda.Builtin.Nat using (Nat; suc; zero)
open import Agda.Builtin.Unit using (âŠ¤; tt)
open import Agda.Primitive using (Level; lzero; lsuc; _âŠ”_)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.Product using (Î£; projâ‚; projâ‚‚; _Ã—_) renaming (_,_ to _â¸´_)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚; [_,_])
open import Function using (_âˆ˜_; const; case_of_; id)
open import Function.Equality using (_âŸ¨$âŸ©_)
open import Relation.Binary using (REL; Rel; Transitive)
open import Relation.Nullary using (yes; no; Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; Satisfiable; _âŠ†_; _âˆ©_; ï½›_ï½; âˆ…)
open import Relation.Binary using (Irreflexive) renaming (Decidable to Decidableâ‚‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; subst; trans; sym)

open import Formula using (Fm; Var; _â†_; âŠ¥'; _â–·_; _â—_; var; âŠ¤'; Â¬'_; â–¡_; â™¢_; _âˆ§_; _âˆ¨_; car)
open import GeneralizedVeltmanSemantics
open import Base using (_â‡’_; _â‡_; Decidableâ‚ƒ; Relâ‚ƒ; RELâ‚ƒ)
open import GeneralizedVeltmanSemantics.Properties
  using (module Extended; âŠ©Â¬; âŠ®Â¬; âŠ©â–¡; âŠ©â™¢; âŠ©MP; âŠ©âˆ§; âŠ©â†’Â¬âŠ®)
import Principles as P

private
  variable
    â„“W â„“R â„“S : Level
    W : Set â„“W
    R : Rel W â„“R
    S : RELâ‚ƒ W W (Pred W â„“W) â„“S
    V : REL W Var lzero

module Condition
  (F : FrameL {lzero} {lzero} {lzero} W R S)
  where
  open FrameL F

  lift : Set â†’ Setâ‚
  lift Sa = Sa Ã— (âŠ¥ â†’ Set)

  Tagger : Setâ‚
  Tagger = Var â†’ ğ•

  fm2pred : Tagger â†’ Fm â†’ W â†’ Setâ‚
  fm2pred âŸ¦_âŸ§ (var v) u = lift (u âˆˆ âŸ¦ v âŸ§)
  fm2pred _ âŠ¥' w = lift âŠ¥
  fm2pred âŸ¦_âŸ§ (A â† B) w = w âˆˆ fm2pred âŸ¦_âŸ§ A â†’ w âˆˆ fm2pred âŸ¦_âŸ§ B
  fm2pred âŸ¦_âŸ§ (A â–· B) w = âˆ€ {u} â†’ R w u â†’ u âˆˆ fm2pred âŸ¦_âŸ§ A
    â†’ Î£ ğ• Î» Y â†’ S w u Y Ã— Y âŠ† fm2pred âŸ¦_âŸ§ B

  Frame-cond : Fm â†’ Setâ‚
  Frame-cond A = âˆ€ g w â†’ fm2pred g A w

module Truth-lemma
  {M : Model {lzero} {lzero} {lzero} W R S V}
  (M,_*âŠ©?_ : MultiDecidableModel M)
  (âˆˆS? : Decidableâ‚ƒ S)
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y) where

  open Model M
  open FrameL F
  open Extended M,_*âŠ©?_ âˆˆS? âˆˆSV?
  open Condition F

  lemma : âˆ€ {âŸ¦_âŸ§ w A} â†’ (q : âˆ€ {w v} â†’ M , w âŠ© var v â‡” w âˆˆ âŸ¦ v âŸ§) â†’
    M , w âŠ© A â‡” w âˆˆ fm2pred âŸ¦_âŸ§ A
  lemma {g} {w} {A} q = equivalence â‡¨ â‡¦
    where
    â‡¨ : âˆ€ {w A} â†’ M , w âŠ© A â†’ w âˆˆ fm2pred g A
    â‡¦ : âˆ€ {w A} â†’ w âˆˆ fm2pred g A â†’ M , w âŠ© A
    â‡¨ v@(var x) = q â‡’ v â¸´ Î» ()
    â‡¨ i@(impl _) u = â‡¨ ((âŠ©â† â‡’ i) (â‡¦ u))
    â‡¨ {w} r@(rhd _) Rwu uâˆˆ[A] = case (âŠ©â–· â‡’ r) Rwu (â‡¦ uâˆˆ[A]) of
      Î» { (Z â¸´ SZ â¸´ snd) â†’ Z â¸´ SZ â¸´ Î» {v â†’ â‡¨ (snd v)}}
    â‡¦ {w} {var x} (fst â¸´ _) = q â‡ fst
    â‡¦ {w} {A â† B} p = âŠ©â† â‡ Î» {x â†’ â‡¦ (p (â‡¨ x))}
    â‡¦ {w} {A â–· B} p = âŠ©â–· â‡ Î» {Rwu uA â†’ case p Rwu (â‡¨ uA) of
      Î» { (Z â¸´ ZS â¸´ snd) â†’ Z â¸´ ZS â¸´ Î» {x â†’ â‡¦ (snd x)}}}


module soundness
  {M : Model {lzero} {lzero} {lzero} W R S V}
  (M,_*âŠ©?_ : MultiDecidableModel M)
  (âˆˆS? : Decidableâ‚ƒ S)
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y) where

  open Model M
  open FrameL F
  open Extended M,_*âŠ©?_ âˆˆS? âˆˆSV?
  open Condition F
  open Truth-lemma M,_*âŠ©?_ âˆˆS? âˆˆSV?

  sound : âˆ€ w P â†’ Frame-cond P â†’ M , w âŠ© P
  sound w A cond = lemma g-aux â‡ cond âŸ¦_âŸ§ w
    where
    âŸ¦_âŸ§ : Tagger
    âŸ¦ x âŸ§ = [âŠ© var x ]
    g-aux : âˆ€ {w v} â†’ M , w âŠ© var v â‡” w âˆˆ [âŠ© var v ]
    g-aux {w} {v} = equivalence â‡¨ â‡¦
      where
      â‡¨ : M , w âŠ© var v â†’ w âˆˆ [âŠ© var v ]
      â‡¨ x = âˆˆ[âŠ© var v ] â‡ x
      â‡¦ : w âˆˆ [âŠ© var v ] â†’ M , w âŠ© var v
      â‡¦ x = âˆˆ[âŠ© var v ] â‡’ x


module Pâ‡’â„±
  {F : FrameL {lzero} {lzero} {lzero} W R S}
  (âˆˆS? : Decidableâ‚ƒ S)
  (dec : âˆ€ V â†’ MultiDecidableModel (model {V = V} F))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
  where
  open FrameL F
  open Condition F

  thm : âˆ€ P â†’ F *âŠ© P â†’ Frame-cond P
  thm P x g w = lemma g-aux â‡’ wâŠ©P
    where
    Val : Valuation F
    Val u a = u âˆˆ g a
    M = model {V = Val} F
    open Extended (dec Val) âˆˆS? âˆˆSV?
    open Truth-lemma (dec Val) âˆˆS? âˆˆSV?
    wâŠ©P : M , w âŠ© P
    wâŠ©P = x (Î» a b â†’ g b a) w
    g-aux : âˆ€ {w v} â†’ M , w âŠ© var v â‡” w âˆˆ g v
    g-aux {w} {v} = equivalence (Î» { (var x) â†’ x}) var
\end{spverbatim}
