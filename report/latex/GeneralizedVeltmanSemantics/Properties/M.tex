\begin{spverbatim}
module GeneralizedVeltmanSemantics.Properties.M where

open import Function.Equivalence using (_â‡”_; equivalence; module Equivalence)

open import Agda.Builtin.Nat using (Nat; suc; zero)
open import Agda.Builtin.Unit using (âŠ¤; tt)
open import Agda.Primitive using (Level; lzero; lsuc)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.Product using (Î£; projâ‚; projâ‚‚; _Ã—_) renaming (_,_ to _â¸´_)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚; [_,_])
open import Function using (_âˆ˜_; const; case_of_; id)
open import Function.Equality using (_âŸ¨$âŸ©_)
open import Relation.Binary using (REL; Rel; Transitive)
open import Relation.Nullary using (yes; no; Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; Satisfiable; _âŠ†_; _âˆ©_; ï½›_ï½)
open import Relation.Binary using (Irreflexive) renaming (Decidable to Decidableâ‚‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; subst; trans; sym)

open import Formula
open import GeneralizedVeltmanSemantics
open import Base
open import GeneralizedVeltmanSemantics.Properties
  using (module Extended; âŠ©Â¬; âŠ®Â¬; âŠ©â–¡; âŠ©â™¢; âŠ©MP; âŠ©âˆ§; âŠ©â†’Â¬âŠ®; âŠ®â†’Â¬âŠ©)
import Principles as P

private
  variable
    â„“W â„“R â„“S : Level

M-condition : âˆ€ {W R S} â†’ FrameL {â„“W} {â„“R} {â„“S} W R S â†’ Set _
M-condition {W = W} {R = R} {S = S} F = âˆ€ {w u V} â†’ S w u V â†’ Î£ ğ• Î» V' â†’ V' âŠ† V Ã— S w u V'
  Ã— âˆ€ {z v'} â†’ v' âˆˆ V' â†’ R v' z â†’ R u z
  where open FrameL F

module M-soundness
  {W R S V}
  {M : Model {lzero} {lzero} {lzero} W R S V}
  (M,_*âŠ©?_ : MultiDecidableModel M)
  (âˆˆS? : Decidableâ‚ƒ S)
  (S? : S-decidable (Model.F M))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y) where

  open Model M
  open FrameL F
  open Extended M,_*âŠ©?_ âˆˆS? âˆˆSV?

  âŠ©M : âˆ€ {w A B C} â†’ M-condition F â†’ M , w âŠ© A â–· B â† (A âˆ§ â–¡ C) â–· (B âˆ§ â–¡ C)
  âŠ©M {w} {A} {B} {C} cM = âŠ©â† â‡ Î» Aâ–·B â†’ âŠ©â–· â‡ Î» { {x} Rwx xâŠ©Aâˆ§â–¡C
    â†’ case âŠ©âˆ§ â‡’ xâŠ©Aâˆ§â–¡C of Î» { (xâŠ©A â¸´ xâŠ©â–¡C) â†’ case (âŠ©â–· â‡’ Aâ–·B) Rwx xâŠ©A of
    Î» { (Z â¸´ SwxZ â¸´ ZâŠ©B) â†’ case cM SwxZ of
    Î» { (Z' â¸´ Z'âŠ†Z â¸´ SwxZ' â¸´ snd) â†’ Z' â¸´ SwxZ' â¸´ Î» {p â†’ âŠ©âˆ§ â‡ (ZâŠ©B (Z'âŠ†Z p) â¸´
    âŠ©â–¡ â‡ Î» {y â†’ (âŠ©â–¡ â‡’ xâŠ©â–¡C) (snd p y)})}}}}}

module M-completeness
  {W R S}
  {F : FrameL {lzero} {lzero} {lzero} W R S}
  (âˆˆS? : Decidableâ‚ƒ S)
  (dec : âˆ€ V â†’ MultiDecidableModel (model {V = V} F))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
  where
  open FrameL F

  *âŠ©M : Setâ‚
  *âŠ©M = P.M (F *âŠ©_)

  pattern a = 0
  pattern b = 1
  pattern c = 2

  âŠ©Mâ‡’M-condition : *âŠ©M â†’ M-condition F
  âŠ©Mâ‡’M-condition âŠ©M {w} {u} {V} SwuV
    = case (âŠ©â–· â‡’ (âŠ©MP (âŠ©M Val w) wâŠ©aâ–·b)) Rwu uâŠ©aâˆ§â–¡c of
      Î» { (Z â¸´ SwuZ â¸´ ZâŠ©bâˆ§â–¡c) â†’ Z â¸´ (Î» {x â†’ [b] â‡’ projâ‚ (âŠ©âˆ§ â‡’ ZâŠ©bâˆ§â–¡c x)}) â¸´ SwuZ
      â¸´ Î» {x xâ‚ â†’ [c] â‡’ (âŠ©â–¡ â‡’ (projâ‚‚ (âŠ©âˆ§ â‡’ ZâŠ©bâˆ§â–¡c x))) xâ‚}}
    where
    Rwu : R w u
    Rwu = SwâŠ†Rw SwuV
    Val : Valuation F
    Val w a = w â‰¡ u
    Val w b = w âˆˆ V
    Val w c = R u w
    Val w (suc (suc (suc _))) = âŠ¥
    M = model {V = Val} F
    open Extended (dec Val) âˆˆS? âˆˆSV?
    [a] : âˆ€ {w} â†’ M , w âŠ© var a â‡” w â‰¡ u
    [a] = equivalence (Î» { (var x) â†’ x}) Î» {z â†’ var z}
    [b] : âˆ€ {w} â†’ M , w âŠ© var b â‡” w âˆˆ V
    [b] = equivalence (Î» { (var x) â†’ x}) Î» {z â†’ var z}
    [c] : âˆ€ {w} â†’ M , w âŠ© var c â‡” R u w
    [c] = equivalence (Î» { (var x) â†’ x}) Î» {z â†’ var z}
    wâŠ©aâ–·b : M , w âŠ© var a â–· var b
    wâŠ©aâ–·b = âŠ©â–· â‡ Î» { {i} Rwi ia â†’ case [a] â‡’ ia of Î» {refl â†’ V â¸´ (SwuV â¸´ Î» {x â†’ [b] â‡ x})}}
    uâŠ©aâˆ§â–¡c : M , u âŠ© var a âˆ§ â–¡ var c
    uâŠ©aâˆ§â–¡c = âŠ©âˆ§ â‡ ([a] â‡ refl â¸´ âŠ©â–¡ â‡ Î» x â†’ [c] â‡ x)

\end{spverbatim}
