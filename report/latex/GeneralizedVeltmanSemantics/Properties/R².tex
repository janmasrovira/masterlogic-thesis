\begin{spverbatim}
module GeneralizedVeltmanSemantics.Properties.RÂ² where

open import Function.Equivalence using (_â‡”_; equivalence; module Equivalence)

open import Agda.Builtin.Nat using (Nat; suc; zero)
open import Agda.Builtin.Unit using (âŠ¤; tt)
open import Agda.Primitive using (Level; lzero; lsuc)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.Product using (Î£; projâ‚; projâ‚‚; _Ã—_) renaming (_,_ to _â¸´_)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚; [_,_])
open import Function using (_âˆ˜_; const; case_of_; id)
open import Function.Equality using (_âŸ¨$âŸ©_)
open import Relation.Binary using (REL; Rel; Transitive)
open import Relation.Nullary using (yes; no; Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; Satisfiable; _âŠ†_; _âˆ©_; ï½›_ï½)
open import Relation.Binary using (Irreflexive) renaming (Decidable to Decidableâ‚‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; subst; trans; sym)

open import Formula
open import GeneralizedVeltmanSemantics
open import Base using (_â‡’_; _â‡_; Decidableâ‚ƒ)
open import GeneralizedVeltmanSemantics.Properties
  using (module Extended; âŠ©Â¬; âŠ®Â¬; âŠ©â–¡; âŠ©â™¢; âŠ©MP; âŠ©âˆ§; âŠ©â†’Â¬âŠ®; âŠ®â†’Â¬âŠ©)
open import GeneralizedFrame using (module Predicates)
import Principles as P

private
  variable
    â„“W â„“R â„“S : Level

RÂ²-condition : âˆ€ {W R S} â†’ FrameL {lzero} {lzero} {lzero} W R S â†’ Set _
RÂ²-condition {W = W} {R = R} {S = S} F =
  âˆ€ {w x y z s} {ğ”¸ ğ”¹ â„‚ ğ”» ğ”¼ : ğ•}
  â†’ R w x â†’ R x y â†’ R y z â†’ R z s
  â†’ (âˆ€ {u} â†’ R w u â†’ u âˆˆ ğ”¸ â†’ Î£ ğ• Î» V â†’ S w u V Ã— V âŠ† ğ”¹)
  â†’ (âˆ€ {u} â†’ R x u â†’ u âˆˆ ğ”¼ â†’ Î£ ğ• Î» V â†’ S x u V Ã— V âŠ† ğ”¸)
  â†’ (âˆ€ {u} â†’ R y u â†’ u âˆˆ ğ”» â†’ Î£ ğ• Î» V â†’ S y u V Ã— V âŠ† ğ”¼)
  â†’ (âˆ€ {V} â†’ S z s V â†’ Î£ W Î» v â†’ v âˆˆ V Ã— v âˆˆ â„‚)
  â†’ s âˆˆ ğ”»
  â†’ Î£ ğ• Î» V â†’ S w x V Ã— V âŠ† ğ”¹ Ã— R[ V ] âŠ† â„‚
  where open FrameL F
        open Predicates F

module RÂ²-soundness
  {W R S V}
  {M : Model {lzero} {lzero} {lzero} W R S V}
  (M,_*âŠ©?_ : MultiDecidableModel M)
  (âˆˆS? : Decidableâ‚ƒ S)
  (S? : S-decidable (Model.F M))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y) where

  open Model M
  open FrameL F
  open Extended M,_*âŠ©?_ âˆˆS? âˆˆSV?

  âŠ©RÂ²-aux : âˆ€ {A B C D E w x y z s}
    â†’ RÂ²-condition F
    â†’ R w x â†’ R x y â†’ R y z â†’ R z s
    â†’ M , w âŠ© A â–· B
    â†’ M , x âŠ© E â–· A
    â†’ M , y âŠ© D â–· E
    â†’ M , s âŠ© D
    â†’ (âˆ€ {V} â†’ S z s V â†’ Satisfiable (V âˆ© (M ,_âŠ© C)))
    â†’ Î£ ğ• Î» Y â†’ S w x Y Ã— Y âŠ† M ,_âŠ© B âˆ§ â–¡ C
  âŠ©RÂ²-aux {A} {B} {C} {D} {E} cond Rwx Rxy Ryz Rzs wâŠ©Aâ–·B xâŠ©Eâ–·A yâŠ©Dâ–·E sâŠ©D p
    = case cond Rwx Rxy Ryz Rzs
    (aux wâŠ©Aâ–·B) (aux xâŠ©Eâ–·A) (aux yâŠ©Dâ–·E)
    (aux-choice p) (âˆˆ[âŠ© D ] â‡ sâŠ©D) of
    Î» { (Y â¸´ SwxY â¸´ YâŠ†ğ”¹ â¸´ snd) â†’ Y â¸´ SwxY â¸´ Î» { {e} i â†’ âŠ©âˆ§ â‡ (âˆˆ[âŠ© B ] â‡’ YâŠ†ğ”¹ i â¸´ âŠ©â–¡ â‡ Î» { {t} j â†’ âˆˆ[âŠ© C ] â‡’ snd (e â¸´ i â¸´ j)})} }
    where
    -- the following function is general enough to be declared outside this module.
    aux : âˆ€ {A B w u} â†’ M , w âŠ© A â–· B â†’ R w u â†’ u âˆˆ [âŠ© A ] â†’ Î£ ğ• Î» V â†’ S w u V Ã— V âŠ† [âŠ© B ]
    aux {A} {B} wâŠ©Aâ–·B Rwu uâˆˆ[A] = case (âŠ©â–· â‡’ wâŠ©Aâ–·B) Rwu (âˆˆ[âŠ© A ] â‡’ uâˆˆ[A]) of
      Î» { (V â¸´ SwuV â¸´ snd) â†’ V â¸´ SwuV â¸´ Î» {xâ‚ â†’ âˆˆ[âŠ© B ] â‡ snd xâ‚}}
    aux-choice : âˆ€ {A w x} â†’ (âˆ€ {V} â†’ S w x V â†’ Satisfiable (V âˆ© (M ,_âŠ© A))) â†’ âˆ€ {V} â†’ S w x V â†’ Satisfiable (V âˆ© [âŠ© A ])
    aux-choice {A} p SwxV = case p SwxV of Î» { (k â¸´ fst â¸´ snd) â†’ k â¸´ fst â¸´ âˆˆ[âŠ© A ] â‡ snd }

  âŠ©RÂ² : âˆ€ {w A B C D E} â†’ RÂ²-condition F
    â†’ M , w âŠ© A â–· B â† (â™¢ ((D â–· E) âˆ§ â™¢ (Â¬' (D â–· Â¬' C))) âˆ§ (E â–· A)) â–· (B âˆ§ â–¡ C)
  âŠ©RÂ² {w} {A} {B} {C} {D} {E} c = âŠ©â† â‡ Î» {wâŠ©Aâ–·B â†’ âŠ©â–· â‡
    Î» { {x} Rwx xâŠ© â†’ case âŠ©âˆ§ â‡’ xâŠ© of Î» { (xâŠ©â™¢ â¸´ xâŠ©Eâ–·A) â†’ case âŠ©â™¢ â‡’ xâŠ©â™¢ of
    Î» { (y â¸´ Rxy â¸´ yâŠ©) â†’ case âŠ©âˆ§ â‡’ yâŠ© of Î» { (yâŠ©Dâ–·E â¸´ yâŠ©â™¢) â†’ case âŠ©â™¢ â‡’ yâŠ©â™¢ of
    Î» { (z â¸´ Ryz â¸´ zâŠ©) â†’ case âŠ©â— â‡’ zâŠ© of Î» { (s â¸´ Rzs â¸´ sâŠ©D â¸´ snd)
    â†’ âŠ©RÂ²-aux c Rwx Rxy Ryz Rzs wâŠ©Aâ–·B xâŠ©Eâ–·A yâŠ©Dâ–·E sâŠ©D snd}}}}}}}

module RÂ²-completeness
  {W R S}
  {F : FrameL {lzero} {lzero} {lzero} W R S}
  (âˆˆS? : Decidableâ‚ƒ S)
  (dec : âˆ€ V â†’ MultiDecidableModel (model {V = V} F))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
  where
  open FrameL F

  *âŠ©RÂ² : Setâ‚
  *âŠ©RÂ² = P.RÂ² (F *âŠ©_)

  pattern a = 0
  pattern b = 1
  pattern c = 2
  pattern d = 3
  pattern e = 4


  âŠ©RÂ²â‡’RÂ²-condition : *âŠ©RÂ² â†’ RÂ²-condition F
  âŠ©RÂ²â‡’RÂ²-condition âŠ©RÂ² {w} {x} {y} {z} {s} {ğ”¸} {ğ”¹} {â„‚} {ğ”»} {ğ”¼}
    Rwx Rxy Ryz Rzs ğ”¸â–·ğ”¹ ğ”¼â–·ğ”¸ ğ”»â–·ğ”¼ pâ„‚ sâˆˆğ”»
      = case (âŠ©â–· â‡’ âŠ©MP wâŠ©RÂ² wâŠ©aâ–·b) Rwx (âŠ©âˆ§ â‡ (âŠ©â™¢ â‡ (y â¸´ Rxy â¸´ âŠ©âˆ§ â‡
      (yâŠ©dâ–·e â¸´ âŠ©â™¢ â‡ (z â¸´ Ryz â¸´ zâŠ©Â¬dâ–·Â¬c))) â¸´ xâŠ©eâ–·a)) of
      Î» { (V â¸´ SwxV â¸´ snd) â†’ V â¸´ SwxV â¸´ (Î» {i â†’ [b] â‡’ projâ‚ (âŠ©âˆ§ â‡’ snd i)}) â¸´
      Î» { (u â¸´ uV â¸´ Rui) â†’ [c] â‡’ (âŠ©â–¡ â‡’ (projâ‚‚ (âŠ©âˆ§ â‡’ snd uV))) Rui}}
    where
    Val : Valuation F
    Val y a = y âˆˆ ğ”¸
    Val y b = y âˆˆ ğ”¹
    Val y c = y âˆˆ â„‚
    Val y d = y âˆˆ ğ”»
    Val y e = y âˆˆ ğ”¼
    Val y (suc (suc (suc (suc (suc x))))) = âŠ¥
    M = model {V = Val} F
    [a] : âˆ€ {u} â†’ M , u âŠ© var a â‡” u âˆˆ ğ”¸
    [a] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    [b] : âˆ€ {u} â†’ M , u âŠ© var b â‡” u âˆˆ ğ”¹
    [b] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    [c] : âˆ€ {u} â†’ M , u âŠ© var c â‡” u âˆˆ â„‚
    [c] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    [d] : âˆ€ {u} â†’ M , u âŠ© var d â‡” u âˆˆ ğ”»
    [d] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    [e] : âˆ€ {u} â†’ M , u âŠ© var e â‡” u âˆˆ ğ”¼
    [e] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    open Extended (dec Val) âˆˆS? âˆˆSV?
    wâŠ©RÂ² : M , w âŠ© var a â–· var b â† (â™¢ ((var d â–· var e) âˆ§ â™¢ (Â¬' (var d â–· Â¬' var c))) âˆ§
      (var e â–· var a)) â–· (var b âˆ§ â–¡ var c)
    wâŠ©RÂ² = âŠ©RÂ² Val w
    wâŠ©aâ–·b : M , w âŠ© var a â–· var b
    wâŠ©aâ–·b = [âŠ©â–·] [a] [b] ğ”¸â–·ğ”¹
    xâŠ©eâ–·a : M , x âŠ© var e â–· var a
    xâŠ©eâ–·a = [âŠ©â–·] [e] [a] ğ”¼â–·ğ”¸
    yâŠ©dâ–·e : M , y âŠ© var d â–· var e
    yâŠ©dâ–·e = [âŠ©â–·] [d] [e] ğ”»â–·ğ”¼
    zâŠ©Â¬dâ–·Â¬c : M , z âŠ© Â¬' (var d â–· Â¬' var c)
    zâŠ©Â¬dâ–·Â¬c = âŠ©â— â‡ (s â¸´ Rzs â¸´ var sâˆˆğ”» â¸´ Î» {SzsV â†’ case pâ„‚ SzsV of
      Î» { (s' â¸´ s'âˆˆV â¸´ s'âˆˆâ„‚) â†’ s' â¸´ s'âˆˆV â¸´ [c] â‡ s'âˆˆâ„‚}})
\end{spverbatim}
