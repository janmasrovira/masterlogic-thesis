\begin{spverbatim}
module GeneralizedVeltmanSemantics.Properties.Pâ‚€ where

open import Function.Equivalence using (_â‡”_; equivalence; module Equivalence)

open import Agda.Builtin.Nat using (Nat; suc; zero)
open import Agda.Builtin.Unit using (âŠ¤; tt)
open import Agda.Primitive using (Level; lzero; lsuc)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.Product using (Î£; projâ‚; projâ‚‚; _Ã—_) renaming (_,_ to _â¸´_)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚; [_,_])
open import Function using (_âˆ˜_; const; case_of_; id)
open import Function.Equality using (_âŸ¨$âŸ©_)
open import Relation.Binary using (REL; Rel; Transitive)
open import Relation.Nullary using (yes; no; Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; Satisfiable; _âŠ†_; _âˆ©_; ï½›_ï½)
open import Relation.Binary using (Irreflexive) renaming (Decidable to Decidableâ‚‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; subst; trans; sym)

open import Formula
open import GeneralizedVeltmanSemantics
open import Base
open import GeneralizedVeltmanSemantics.Properties
  using (module Extended; âŠ©Â¬; âŠ®Â¬; âŠ©â–¡; âŠ©â™¢; âŠ©MP; âŠ©âˆ§; âŠ©â†’Â¬âŠ®; âŠ®â†’Â¬âŠ©)
import Principles as P

private
  variable
    â„“W â„“R â„“S : Level

Pâ‚€-condition : âˆ€ {â„“Z} {W R S} â†’ FrameL {â„“W} {â„“R} {â„“S} W R S â†’ Set _
Pâ‚€-condition {â„“Z = â„“Z} {W = W} {R = R} {S = S} F = âˆ€ {w x y Y} â†’ R w x â†’ R x y â†’ S w y Y â†’
  (Z : Pred W â„“Z)
  â†’ (âˆ€ y' â†’ y' âˆˆ Y â†’ Satisfiable (Z âˆ© R y'))
  â†’ Î£ ğ• Î» Z' â†’ (Z' âŠ† Z) Ã— S x y Z'
  where open FrameL F

module Pâ‚€-soundness
  {W R S V}
  {M : Model {lzero} {lzero} {lzero} W R S V}
  (M,_*âŠ©?_ : MultiDecidableModel M)
  (âˆˆS? : Decidableâ‚ƒ S)
  (S? : S-decidable (Model.F M))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y) where

  open Model M
  open FrameL F
  open Extended M,_*âŠ©?_ âˆˆS? âˆˆSV?

  âŠ©Pâ‚€ : âˆ€ {w A B} â†’ Pâ‚€-condition F â†’ M , w âŠ© A â–· (â™¢ B) â† â–¡ (A â–· B)
  âŠ©Pâ‚€ {w} {A} {B} c-Pâ‚€ = âŠ©â† â‡ Î» Aâ–·â™¢B â†’ âŠ©â–¡ â‡ Î» {x} Rwx â†’ âŠ©â–· â‡ Î» {y} Rxy yA
    â†’ case (âŠ©â–· â‡’ Aâ–·â™¢B) (R-trans Rwx Rxy) yA of
    Î» { (Y â¸´ SwyY â¸´ snd) â†’ case c-Pâ‚€ Rwx Rxy SwyY (M ,_âŠ© B)
    (Î» y' y'âˆˆY â†’ case âŠ©â™¢ â‡’ snd y'âˆˆY of Î» { (z â¸´ Ry'z â¸´ zB) â†’ z â¸´ zB â¸´ Ry'z}) of
    Î» { (Z' â¸´ ZB â¸´ SxyZ') â†’ Z' â¸´ SxyZ' â¸´ Î» { w' â†’ ZB w'}}
    }

module Pâ‚€-completeness
  {W R S}
  {F : FrameL {lzero} {lzero} {lzero} W R S}
  (âˆˆS? : Decidableâ‚ƒ S)
  (dec : âˆ€ V â†’ MultiDecidableModel (model {V = V} F))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
  where
  open FrameL F

  *âŠ©Pâ‚€ : Setâ‚
  *âŠ©Pâ‚€ = P.Pâ‚€ (F *âŠ©_)

  pattern a = 0
  pattern b = 1

  âŠ©Pâ‚€â‡’Pâ‚€-condition : *âŠ©Pâ‚€ â†’ Pâ‚€-condition F
  âŠ©Pâ‚€â‡’Pâ‚€-condition âŠ©Pâ‚€ {w} {x} {y} {Y} Rwx Rxy SwyY Z p =
    case (âŠ©â–· â‡’ xâŠ©aâ–·b) Rxy ([a] â‡ refl) of
    Î» { (Z' â¸´ SxyZ' â¸´ Z'âŠ©b) â†’ Z' â¸´ (Î» {z â†’ [b] â‡’ (Z'âŠ©b z)}) â¸´ SxyZ'}
    where
    Val : Valuation F
    Val w a = w â‰¡ y
    Val w b = w âˆˆ Z
    Val w (suc (suc _)) = âŠ¥
    M = model {V = Val} F
    open Extended (dec Val) âˆˆS? âˆˆSV?
    [a] : âˆ€ {w} â†’ M , w âŠ© var a â‡” w â‰¡ y
    [a] = equivalence (Î» { (var x) â†’ x}) Î» {z â†’ var z}
    [b] : âˆ€ {w} â†’ M , w âŠ© var b â‡” w âˆˆ Z
    [b] = equivalence (Î» { (var x) â†’ x}) Î» {z â†’ var z}
    wâŠ©aâ–·â™¢b : M , w âŠ© var a â–· â™¢ var b
    wâŠ©aâ–·â™¢b = âŠ©â–· â‡ Î» { {u} Rwu uâŠ©a â†’ case [a] â‡’ uâŠ©a of
      Î» { refl â†’ Y â¸´ SwyY â¸´ Î» { {v} vâˆˆY â†’ case p v vâˆˆY of
      Î» { (fst â¸´ fstâ‚ â¸´ snd) â†’ âŠ©â™¢ â‡ (fst â¸´ (snd â¸´ ([b] â‡ fstâ‚)))}}}}
    wâŠ©â–¡aâ–·b : M , w âŠ© â–¡ (var a â–· var b)
    wâŠ©â–¡aâ–·b = âŠ©MP (âŠ©Pâ‚€ Val w) wâŠ©aâ–·â™¢b
    xâŠ©aâ–·b : M , x âŠ© var a â–· var b
    xâŠ©aâ–·b = (âŠ©â–¡ â‡’ wâŠ©â–¡aâ–·b) Rwx
\end{spverbatim}
