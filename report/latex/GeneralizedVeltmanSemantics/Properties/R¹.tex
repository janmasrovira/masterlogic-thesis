\begin{spverbatim}
module GeneralizedVeltmanSemantics.Properties.RÂ¹ where

open import Function.Equivalence using (_â‡”_; equivalence; module Equivalence)

open import Agda.Builtin.Nat using (Nat; suc; zero)
open import Agda.Builtin.Unit using (âŠ¤; tt)
open import Agda.Primitive using (Level; lzero; lsuc)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.Product using (Î£; projâ‚; projâ‚‚; _Ã—_) renaming (_,_ to _â¸´_)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚; [_,_])
open import Function using (_âˆ˜_; const; case_of_; id)
open import Function.Equality using (_âŸ¨$âŸ©_)
open import Relation.Binary using (REL; Rel; Transitive)
open import Relation.Nullary using (yes; no; Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; Satisfiable; _âŠ†_; _âˆ©_; ï½›_ï½)
open import Relation.Binary using () renaming (Decidable to Decidableâ‚‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; subst; trans; sym)

open import Formula
open import GeneralizedVeltmanSemantics
open import Base using (_â‡’_; _â‡_; Decidableâ‚ƒ)
open import GeneralizedVeltmanSemantics.Properties
  using (module Extended; âŠ©Â¬; âŠ®Â¬; âŠ©â–¡; âŠ©â™¢; âŠ©MP; âŠ©âˆ§; âŠ©â†’Â¬âŠ®; âŠ®â†’Â¬âŠ©)
open import GeneralizedFrame using (module Predicates)
import Principles as P

private
  variable
    â„“W â„“R â„“S : Level

RÂ¹-condition : âˆ€ {W R S} â†’ FrameL {lzero} {lzero} {lzero} W R S â†’ Set _
RÂ¹-condition {W = W} {R = R} {S = S} F = âˆ€ {w x y z} {ğ”¸ ğ”¹ â„‚ ğ”» : ğ•}
  â†’ R w x â†’ R x y â†’ R y z
  â†’ (âˆ€ {u} â†’ R w u â†’ u âˆˆ ğ”¸ â†’ Î£ ğ• Î» V â†’ S w u V Ã— V âŠ† ğ”¹)
  â†’ (âˆ€ {u} â†’ R x u â†’ u âˆˆ ğ”» â†’ Î£ ğ• Î» V â†’ S x u V Ã— V âŠ† ğ”¸)
  â†’ (âˆ€ {V} â†’ S y z V â†’ Î£ W Î» v â†’ v âˆˆ V Ã— v âˆˆ â„‚)
  â†’ z âˆˆ ğ”»
  â†’ Î£ ğ• Î» V â†’ V âŠ† ğ”¹ Ã— S w x V Ã— R[ V ] âŠ† â„‚
  where open FrameL F
        open Predicates F

module Râ‚-soundness
  {W R S V}
  {M : Model {lzero} {lzero} {lzero} W R S V}
  (M,_*âŠ©?_ : MultiDecidableModel M)
  (âˆˆS? : Decidableâ‚ƒ S)
  (S? : S-decidable (Model.F M))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y) where

  open Model M
  open FrameL F
  open Extended M,_*âŠ©?_ âˆˆS? âˆˆSV?

  âŠ©RÂ¹ : âˆ€ {w A B C D} â†’ RÂ¹-condition F
    â†’ M , w âŠ© A â–· B â† (â™¢ (D â— C) âˆ§ (D â–· A)) â–· (B âˆ§ â–¡ C)
  âŠ©RÂ¹ {w} {A} {B} {C} {D} c = âŠ©â† â‡ Î» wâŠ©Aâ–·B â†’ âŠ©â–· â‡ Î» { {x} Rwx xâŠ©âˆ§ â†’
    case âŠ©âˆ§ â‡’ xâŠ©âˆ§ of Î» { (xâŠ©â™¢Dâ—C â¸´ xâŠ©Dâ–·A) â†’ case âŠ©â™¢ â‡’ xâŠ©â™¢Dâ—C of
    Î» { (y â¸´ Rxy â¸´ yâŠ©Dâ—C) â†’ case âŠ©â— â‡’ yâŠ©Dâ—C of
    Î» { (z â¸´ Ryz â¸´ zâŠ©D â¸´ pz) â†’ case c {ğ”¸ = ğ”¸} {ğ”¹ = ğ”¹} {ğ”» = ğ”»} Rwx Rxy Ryz
    (Î» {u} Rwu uâˆˆğ”¸ â†’ case (âŠ©â–· â‡’ wâŠ©Aâ–·B) Rwu (âˆˆ[âŠ© A ] â‡’ uâˆˆğ”¸) of Î» { (V â¸´ SwuV â¸´ VâŠ©B)
      â†’ V â¸´ SwuV â¸´ Î» {z â†’ âˆˆ[âŠ© B ] â‡ VâŠ©B z}}) (Î» {u} Rxu uD â†’ case (âŠ©â–· â‡’ xâŠ©Dâ–·A) Rxu (âˆˆ[âŠ© D ] â‡’ uD) of
      Î» { (V â¸´ SxuV â¸´ VâŠ©A) â†’ V â¸´ SxuV â¸´ Î» {vâˆˆV â†’ âˆˆ[âŠ© A ] â‡ VâŠ©A vâˆˆV}}) (Î» { {V} SyzV â†’ case pz SyzV of
      Î» { (v â¸´ vâˆˆV â¸´ vC) â†’ v â¸´ vâˆˆV â¸´ (âˆˆK y z â‡ (V â¸´ SyzV â¸´ vâˆˆV â¸´ vC))}}) (âˆˆ[âŠ© D ] â‡ zâŠ©D) of
    Î» { (V â¸´ VâŠ†ğ”¹ â¸´ SwxV â¸´ R[V]âŠ†K) â†’ V â¸´ SwxV â¸´ Î» { {v} v' â†’ âŠ©âˆ§ â‡ (âˆˆ[âŠ© B ] â‡’ VâŠ†ğ”¹ v' â¸´ âŠ©â–¡ â‡
    Î» { {u} Rvu â†’ case âˆˆK y z â‡’ R[V]âŠ†K (v â¸´ v' â¸´ Rvu) of
    Î» { (_ â¸´ _ â¸´ _ â¸´ snd) â†’ snd}})}}}}}}
    where
    K : (y z : W) â†’ ğ•
    K y z u with S? y z u
    ... | injâ‚‚ _ = âŠ¥
    ... | injâ‚ _ with M, u âŠ©? C
    ... | injâ‚ _ = âŠ¤
    ... | injâ‚‚ _ = âŠ¥
    âˆˆK : âˆ€ y z {u} â†’ u âˆˆ (K y z) â‡” Î£ ğ• Î» V â†’ S y z V Ã— u âˆˆ V Ã— M , u âŠ© C
    âˆˆK y z {u} = equivalence â‡¨ â‡¦
      where
      â‡¨ : u âˆˆ (K y z) â†’ Î£ ğ• Î» V â†’ S y z V Ã— u âˆˆ V Ã— M , u âŠ© C
      â‡¨ x with S? y z u
      ... | injâ‚ (V â¸´ uV â¸´ SyzV) with M, u âŠ©? C
      ... | injâ‚ p = V â¸´ SyzV â¸´ uV â¸´ p
      ... | injâ‚‚ _ = âŠ¥-elim x
      â‡¦ : (Î£ ğ• Î» V â†’ S y z V Ã— u âˆˆ V Ã— M , u âŠ© C) â†’ u âˆˆ (K y z)
      â‡¦ (V â¸´ SyzV â¸´ uV) with S? y z u
      ... | injâ‚‚ p = p V SyzV (projâ‚ uV)
      ... | injâ‚ p with M, u âŠ©? C
      ... | injâ‚ p' = tt
      â‡¦ (V â¸´ SyzV â¸´ fst â¸´ snd) | injâ‚ p | injâ‚‚ p' = âŠ®â†’Â¬âŠ© p' snd
    Kâˆˆğ’ : {y z : W} â†’ R y z â†’ (âˆ€ {V} â†’ S y z V â†’ Î£ W (Î» b â†’ b âˆˆ V Ã— M , b âŠ© C)) â†’ IsChoiceSet (K y z) y z
    Kâˆˆğ’ {y} {z} Ryz p = Ryz â¸´ Î» { {Y} SyzY â†’ case p SyzY of Î» { (b â¸´ bâˆˆV â¸´ bC) â†’ b â¸´ bâˆˆV â¸´ âˆˆK y z â‡ (Y â¸´ SyzY â¸´ bâˆˆV â¸´ bC)}}
    ğ”¸ ğ”¹ ğ”» : ğ•
    ğ”¸ = [âŠ© A ]
    ğ”¹ = [âŠ© B ]
    ğ”» = [âŠ© D ]


module Râ‚-completeness
  {W R S}
  {F : FrameL {lzero} {lzero} {lzero} W R S}
  (âˆˆS? : Decidableâ‚ƒ S)
  (dec : âˆ€ V â†’ MultiDecidableModel (model {V = V} F))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
  where
  open FrameL F
  *âŠ©RÂ¹ : Setâ‚
  *âŠ©RÂ¹ = P.RÂ¹ (F *âŠ©_)

  pattern a = 0
  pattern b = 1
  pattern c = 2
  pattern d = 3


  âŠ©RÂ¹â‡’RÂ¹-condition : *âŠ©RÂ¹ â†’ RÂ¹-condition F
  âŠ©RÂ¹â‡’RÂ¹-condition âŠ©RÂ¹ {w} {x} {y} {z} {ğ”¸} {ğ”¹} {â„‚} {ğ”»}
    Rwx Rxy Ryz âˆˆğ”¸ âˆˆğ”» [dâ—c] zâˆˆğ”» = case (âŠ©â–· â‡’ âŠ©MP wâŠ©RÂ¹ wâŠ©aâ–·b) Rwx (âŠ©âˆ§ â‡ (xâŠ©â™¢dâ—c â¸´ xâŠ©dâ–·a)) of
    Î» { (V â¸´ SwxV â¸´ VâŠ©bâˆ§â–¡c) â†’ V â¸´ (Î» {p â†’ [b] â‡’ projâ‚ (âŠ©âˆ§ â‡’ VâŠ©bâˆ§â–¡c p)}) â¸´ SwxV â¸´
    Î» { {h} (v â¸´ vâˆˆV â¸´ Rv) â†’ [c] â‡’ (âŠ©â–¡ â‡’ projâ‚‚ (âŠ©âˆ§ â‡’ VâŠ©bâˆ§â–¡c vâˆˆV)) Rv}}
    where
    Val : Valuation F
    Val y a = y âˆˆ ğ”¸
    Val y b = y âˆˆ ğ”¹
    Val y c = y âˆˆ â„‚
    Val y d = y âˆˆ ğ”»
    Val y (suc (suc (suc (suc x)))) = âŠ¥
    M = model {V = Val} F
    [a] : âˆ€ {u} â†’ M , u âŠ© var a â‡” u âˆˆ ğ”¸
    [a] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    [b] : âˆ€ {u} â†’ M , u âŠ© var b â‡” u âˆˆ ğ”¹
    [b] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    [c] : âˆ€ {u} â†’ M , u âŠ© var c â‡” u âˆˆ â„‚
    [c] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    [d] : âˆ€ {u} â†’ M , u âŠ© var d â‡” u âˆˆ ğ”»
    [d] {u} = equivalence (Î» { (var x) â†’ x}) (Î» xâ‚ â†’ var xâ‚)
    open Extended (dec Val) âˆˆS? âˆˆSV?
    wâŠ©RÂ¹ : M , w âŠ© var a â–· var b â† (â™¢ (var d â— var c) âˆ§ (var d â–· var a)) â–· (var b âˆ§ â–¡ var c)
    wâŠ©RÂ¹ = âŠ©RÂ¹ Val w
    wâŠ©aâ–·b : M , w âŠ© var a â–· var b
    wâŠ©aâ–·b = âŠ©â–· â‡ Î» { {u} Rwu uâŠ©a â†’
      case âˆˆğ”¸ Rwu ([a] â‡’ uâŠ©a) of Î» { (V â¸´ SwuV â¸´ VâŠ†ğ”¹)
      â†’ V â¸´ SwuV â¸´ Î» {z â†’ [b] â‡ VâŠ†ğ”¹ z}}}
    yâŠ©dâ—c : M , y âŠ© var d â— var c
    yâŠ©dâ—c = âŠ©â— â‡ (z â¸´ Ryz â¸´ [d] â‡ zâˆˆğ”» â¸´ Î» { {V} SyzV â†’ case [dâ—c] SyzV of Î» { (v â¸´ vâˆˆV â¸´ vâˆˆâ„‚) â†’ v â¸´ vâˆˆV â¸´ [c] â‡ vâˆˆâ„‚}})
    xâŠ©dâ–·a : M , x âŠ© var d â–· var a
    xâŠ©dâ–·a = âŠ©â–· â‡ Î» { {u} Rxu ud â†’ case âˆˆğ”» Rxu ([d] â‡’ ud) of Î» { (V â¸´ SxuV â¸´ snd) â†’ V â¸´ SxuV â¸´ Î» {i â†’ [a] â‡ snd i}}}
    xâŠ©â™¢dâ—c : M , x âŠ© â™¢ (var d â— var c)
    xâŠ©â™¢dâ—c = âŠ©â™¢ â‡ (y â¸´ Rxy â¸´ yâŠ©dâ—c)
\end{spverbatim}
