\begin{spverbatim}
module GeneralizedVeltmanSemantics.Properties.Verbrugge where

open import Function.Equivalence using (_â‡”_; equivalence; module Equivalence)

open import Agda.Builtin.Nat using (Nat; suc; zero)
open import Agda.Builtin.Unit using (âŠ¤; tt)
open import Agda.Primitive using (Level; lzero; lsuc; _âŠ”_)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Function using (_$_)
open import Data.Product renaming (_,_ to _â¸´_)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚; [_,_])
open import Function using (_âˆ˜_; const; case_of_; id)
open import Function.Equality using (_âŸ¨$âŸ©_)
open import Relation.Binary using (REL; Rel; Transitive)
open import Relation.Nullary using (yes; no; Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; Satisfiable; _âŠ†_; _âˆ©_; ï½›_ï½; âˆ…)
open import Relation.Binary using (Irreflexive) renaming (Decidable to Decidableâ‚‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; subst; trans; sym; substâ‚‚)

open import Formula using (Fm; Var; _â†_; âŠ¥'; _â–·_; _â—_; var; âŠ¤'; Â¬'_; â–¡_; â™¢_; _âˆ§_; _âˆ¨_; car)
open import Base
open import GeneralizedVeltmanSemantics.Properties
  using (module SemanticsProperties-4;
    module SemanticsProperties-3;
    module SemanticsProperties-L; module PGeneric)
open import GeneralizedFrame
open import GeneralizedFrame.Properties
import OrdinaryFrame as O
import OrdinaryVeltmanSemantics as O
import OrdinaryVeltmanSemantics.Properties as O

private
  variable
    â„“W â„“R â„“S : Level

module OrdModel
  {â„“W â„“R â„“S}
  (T : âˆ€ {â„“W â„“S} â†’ (W : Set â„“W) â†’ RELâ‚ƒ W W (Pred W â„“W) â„“S â†’ Set (lsuc â„“W âŠ” â„“S))
  {W R S}
  (F : Frame {â„“W} {â„“R} {â„“S} W R S T)
  (V : W â†’ Pred Var lzero)
  where
  open Frame F
  open PGeneric T

  W' : Set _
  W' = âˆƒ[ x ]
       (Î£[ A âˆˆ (Pred (W Ã— W) (lsuc â„“W âŠ” â„“S âŠ” â„“R)) ]
       ((âˆ€ {u v} â†’ (u â¸´ v) âˆˆ A â†’ âˆƒ[ Y ] (S u x Y Ã— v âˆˆ Y))
       Ã— (âˆ€ {u V} â†’ S u x V â†’ âˆƒ[ v ] (v âˆˆ V Ã— (u â¸´ v) âˆˆ A))))

  Amax : W â†’ Pred (W Ã— W) _
  Amax x (w â¸´ v) = Î£ ğ• Î» C â†’ S w x C Ã— v âˆˆ C Ã— (âŠ¥ â†’ R v v)

  R' : Rel W' _
  R' (x â¸´ A â¸´ _) (y â¸´ B â¸´ _) = R x y Ã— (âˆ€ {w z} â†’ R w x â†’ (w â¸´ z) âˆˆ B â†’ (w â¸´ z) âˆˆ A)

  S' : Relâ‚ƒ W' _
  S' w'@(w â¸´ C â¸´ _) x'@(x â¸´ A â¸´ _) y'@(y â¸´ B â¸´ _) =
    R' w' x' Ã— R' w' y' Ã— (âˆ€ {v} â†’ (w â¸´ v) âˆˆ B â†’ (w â¸´ v) âˆˆ A)

  fmax : W â†’ W'
  fmax w = w â¸´ Amax w â¸´ (Î» { (C â¸´ SuwC â¸´ vâˆˆC â¸´ _) â†’ C â¸´ SuwC â¸´ vâˆˆC})
    â¸´ Î» {SuwV â†’ (projâ‚ (Swu-sat SuwV)) â¸´ ((projâ‚‚ (Swu-sat SuwV)) â¸´
    (_ â¸´ (SuwV â¸´ (projâ‚‚ (Swu-sat SuwV) â¸´ âŠ¥-elim))))}

  module W' where
    x : W' â†’ W
    x = projâ‚

    A : W' â†’ Pred (W Ã— W) _
    A = projâ‚ âˆ˜ projâ‚‚

    p1 : (w' : W')
       â†’ (âˆ€ {u v} â†’ (u â¸´ v) âˆˆ (A w') â†’ Î£ ğ• Î» Y â†’ S u (projâ‚ w') Y Ã— v âˆˆ Y)
    p1 = projâ‚ âˆ˜ projâ‚‚ âˆ˜ projâ‚‚

    p2 : (w' : W') â†’ âˆ€ {u V} â†’ S u (x w') V â†’ Î£ W Î» v â†’ v âˆˆ V Ã— (u â¸´ v) âˆˆ (A w')
    p2 = projâ‚‚ âˆ˜ projâ‚‚ âˆ˜ projâ‚‚

    xâˆ˜fâ‰¡id : âˆ€ w â†’ x (fmax w) â‰¡ w
    xâˆ˜fâ‰¡id w = refl

  V' : W' â†’ Pred Var lzero
  V' w' v = v âˆˆ V (W'.x w')

  f-chain : âˆ€ {a} â†’ InfiniteChain R' a â†’ InfiniteChain R _
  InfiniteChain.b (f-chain x) = W'.x (InfiniteChain.b x)
  InfiniteChain.a<b (f-chain x) = projâ‚ (InfiniteChain.a<b x)
  InfiniteChain.tail (f-chain x) = f-chain (InfiniteChain.tail x)

  R'-Noetherian : Noetherian R'
  R'-Noetherian i = R-noetherian (f-chain i)

  F' : O.Frame W' R' S'
  F' = O.frame
    (fmax witness)
    (Î» { {u} {v} (x â¸´ A) (y â¸´ B) â†’ R-trans x y â¸´
    Î» { {v1} {v2} Rwx wzâˆˆA â†’ A Rwx (B (R-trans Rwx x) wzâˆˆA)}})
    R'-Noetherian
    (Î» { (fst â¸´ fstâ‚ â¸´ snd) â†’ fst â¸´ fstâ‚})
    (Î» { {w} {z} (Rwz â¸´ snd) â†’
    (Rwz â¸´ Î» { {u} {v} Ruw W'Auv â†’ snd Ruw W'Auv}) â¸´ (Rwz â¸´ snd) â¸´ Î» z â†’ z})
    (Î» { ((Rwi â¸´ snd1) â¸´ _ â¸´ snd) (_ â¸´ (a â¸´ snd3))
      â†’ (Rwi â¸´
      Î» {x xâ‚ â†’ snd1 x xâ‚}) â¸´ a â¸´ Î» { x â†’ snd (snd3 x)}})
    Î» { (fst â¸´ snd) (fstâ‚ â¸´ B) â†’ (fst â¸´ snd) â¸´
    (R-trans fst fstâ‚ â¸´ Î» {x y â†’ snd x (B (R-trans x fst) y)}) â¸´ B fst}

  M' : O.Model W' R' S' V'
  M' = O.model F'

module PrefaceTheoremAll
  {â„“W â„“R â„“S}
  (T : âˆ€ {â„“W â„“S} â†’ (W : Set â„“W) â†’ RELâ‚ƒ W W (Pred W â„“W) â„“S â†’ Set (lsuc â„“W âŠ” â„“S))
  {W R S}
  (F : Frame {â„“W} {â„“R} {â„“S} W R S T)
  (V : W â†’ Pred Var lzero)
  where
  open OrdModel T F V
  open Frame F
  open PGeneric T

  M : Model W R S V
  M = model {V = V} F

  lemmaâ‡¨-type : Set _
  lemmaâ‡¨-type =
    âˆ€ {w x Y} â†’ S w x Y â†’
    Î£ _ Î» y â†’ y âˆˆ Y
    Ã— (âˆ€ {b V} â†’ S b y V
      â†’ Î£ _ Î» v â†’ v âˆˆ V
      -- (1)
      Ã— (b â‰¡ w â†’ S b x ï½› v ï½)
      -- (2)
      Ã— (R b w â†’ S b w ï½› v ï½))

  lemmaâ‡¦-type : Set _
  lemmaâ‡¦-type =
    âˆ€ {w b x V} â†’ R w x â†’ S b x V â†’
    Î£ _ Î» v â†’ v âˆˆ V
      -- (1)
      Ã— (b â‰¡ w â†’ S b x ï½› v ï½)
      -- (2)
      Ã— (R b w â†’ S b w ï½› v ï½)

  module Theorem
    (dec : MultiDecidableModel M)
    (dec' : O.DecidableModel M')
    (âˆˆS? : Decidableâ‚ƒ S)
    (âˆˆS'? : Decidableâ‚ƒ S')
    (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
    (lemmaâ‡¨ : lemmaâ‡¨-type)
    (lemmaâ‡¦ : lemmaâ‡¦-type)
    where

    private
      open Extended dec âˆˆS? âˆˆSV?
      module O' = O.Extended dec' âˆˆS'?

      thmâ‡¨ : âˆ€ {w C A} â†’ M , w âŠ© A â†’ M' O., w â¸´ C âŠ© A
      thmâ‡¦ : âˆ€ {w C A} â†’ M' O., w â¸´ C âŠ© A â†’ M , w âŠ© A
      thm'â‡¨ : âˆ€ {w C A} â†’ M , w âŠ® A â†’ M' O., w â¸´ C âŠ® A

      thmâ‡¦ x = âŠ©â‡”Â¬âŠ® â‡ Î» {y â†’ O.âŠ®â†’Â¬âŠ© (thm'â‡¨ y) x}

      thmâ‡¨ (var x) = O.var x
      thmâ‡¨ A@(impl _) = O'.âŠ©â† â‡ Î» {wA â†’ thmâ‡¨ ((âŠ©â† â‡’ A) (thmâ‡¦ wA))}
      thmâ‡¨ {w} {C'@(C â¸´ Cp1 â¸´ Cp2)} F@(rhd {D} {E} xl) = O'.âŠ©â–· â‡
        Î» { {xA} R'wx@(Rwx â¸´ Rwxâˆˆ) xâŠ©D
          â†’ case (âŠ©â–· â‡’ F) Rwx (thmâ‡¦ xâŠ©D) of
          Î» { (V â¸´ SwxV â¸´ VâŠ©E) â†’
          let
              l = lemmaâ‡¨ SwxV
              y = projâ‚ l
              yâˆˆV = (projâ‚ âˆ˜ projâ‚‚) l
              lemma2 = (projâ‚‚ âˆ˜ projâ‚‚) l
              x = W'.x xA
              Rwy : R w y
              Rwy = SwuYâŠ†Rw SwxV yâˆˆV
              A = W'.A xA
              B = Î» { (u â¸´ v) â†’ (Î£ _ Î» Y
                â†’ S u y Y Ã— v âˆˆ Y) Ã— (u â‰¡ w â†’ (w â¸´ v) âˆˆ A) Ã— (R u w â†’ (u â¸´ v) âˆˆ C) }
              yBâˆˆW' : W'
              yBâˆˆW' = y â¸´ B â¸´
                (Î» { {u} {v} ((Y â¸´ SuyY â¸´ vâˆˆY) â¸´ _) â†’ Y â¸´ SuyY â¸´ vâˆˆY}) â¸´
                Î» { {b} {V} SbyV â†’
                  let l2 = lemma2 SbyV
                      v = projâ‚ l2
                      vâˆˆV = (projâ‚ âˆ˜ projâ‚‚) l2
                      lemma-1 = (projâ‚ âˆ˜ projâ‚‚ âˆ˜ projâ‚‚) l2
                      lemma-2 = (projâ‚‚ âˆ˜ projâ‚‚ âˆ˜ projâ‚‚) l2
                  in _ â¸´ vâˆˆV â¸´ (_ â¸´ (SbyV â¸´ vâˆˆV))
                â¸´ (Î» { refl â†’ let
                        Swxv : S w x ï½› v ï½
                        Swxv = lemma-1 refl
                      in case W'.p2 xA Swxv of Î» { (_ â¸´ refl â¸´ snd) â†’ snd} })
                â¸´ Î» { Rbw â†’ let
                              Sbwz : S b w ï½› v ï½
                              Sbwz = lemma-2 Rbw
                              bvâˆˆC : (b â¸´ v) âˆˆ C
                              bvâˆˆC = case Cp2 Sbwz of
                                Î» { (_ â¸´ refl â¸´ snd) â†’ snd}
                            in bvâˆˆC} }
              l1 : âˆ€ {v} â†’ (w â¸´ v) âˆˆ B â†’ (w â¸´ v) âˆˆ A
              l1 wvâˆˆB = projâ‚ (projâ‚‚ wvâˆˆB) refl
              l2 : âˆ€ {b z} â†’ R b w â†’ (b â¸´ z) âˆˆ B â†’ (b â¸´ z) âˆˆ C
              l2 {b} {z} Rbw bzâˆˆB = (projâ‚‚ âˆ˜ projâ‚‚) bzâˆˆB Rbw
              R'wy : R' (w â¸´ C') yBâˆˆW'
              R'wy = Rwy â¸´ (Î» {Rbw âˆˆB â†’ l2 Rbw âˆˆB})
          in
            yBâˆˆW' â¸´ (R'wx â¸´ R'wy â¸´ Î» {z â†’ l1 z})
            â¸´ thmâ‡¨ (VâŠ©E yâˆˆV)
            }}

      thm'â‡¨ (var x) = O.var x
      thm'â‡¨ {w} {C} (impl {A} {B} a b) = O.impl (thmâ‡¨ a) (thm'â‡¨ b)
      thm'â‡¨ bot = O.bot
      thm'â‡¨ {w} {C'@(C â¸´ Cp1 â¸´ Cp2)} F@(rhd {D} {E} _) = case âŠ®â–· â‡’ F of
        Î» { (x â¸´ Rwx â¸´ xâŠ©D â¸´ px)
        â†’ let A = Î» { (u â¸´ v) â†’
                (Î£ _ Î» Y â†’ S u x Y Ã— v âˆˆ Y) Ã— (u â‰¡ w â†’ M , v âŠ® E) Ã— (R u w â†’ (u â¸´ v) âˆˆ C)}
              xAâˆˆW' : W'
              xAâˆˆW' = x â¸´ A â¸´
                (Î» { ((V â¸´ SuxV â¸´ vâˆˆV) â¸´ _) â†’ _ â¸´ SuxV â¸´ vâˆˆV}) â¸´
                Î» { {b} {V} SbxV â†’
                  let l = lemmaâ‡¦ Rwx SbxV
                      v = projâ‚ l
                      vâˆˆV : v âˆˆ V
                      vâˆˆV = projâ‚ âˆ˜ projâ‚‚ $ l
                      l1 = projâ‚ âˆ˜ projâ‚‚ âˆ˜ projâ‚‚ $ l
                      l2 = projâ‚‚ âˆ˜ projâ‚‚ âˆ˜ projâ‚‚ $ l
                  in
                  _ â¸´ (vâˆˆV â¸´ (_ â¸´ (SbxV â¸´ vâˆˆV))
                â¸´ (Î» { refl â†’
                let
                  Swxv : S b x ï½› v ï½
                  Swxv = l1 refl
                in case px _ (_ â¸´ refl) Swxv of
                  Î» { (_ â¸´ refl â¸´ l) â†’ l}
                }) â¸´ Î» { Rbw â†’
                  let
                    Suwv : S b w ï½› v ï½
                    Suwv = l2 Rbw
                    uvâˆˆC : (b â¸´ v) âˆˆ C
                    uvâˆˆC = case Cp2 Suwv of Î» { (_ â¸´ refl â¸´ p) â†’ p}
                  in uvâˆˆC} )}
              R'wx : R' (w â¸´ C') xAâˆˆW'
              R'wx = Rwx â¸´ (Î» { {b} Rbw bzâˆˆA â†’ (projâ‚‚ âˆ˜ projâ‚‚) bzâˆˆA Rbw})
          in O'.âŠ®â–· â‡ (xAâˆˆW' â¸´ R'wx â¸´ thmâ‡¨ xâŠ©D â¸´ Î» { {yB@(y â¸´ B â¸´ B1 â¸´ B2)}
            S'wxy â†’
            let
                Rwy : R w y
                Rwy = (projâ‚ âˆ˜ projâ‚ âˆ˜ projâ‚‚) S'wxy
                Swyy : S w y ï½› y ï½
                Swyy = S-quasirefl Rwy
                wyâˆˆB : (w â¸´ y) âˆˆ B
                wyâˆˆB = case B2 Swyy of
                  Î» { (_ â¸´ refl â¸´ snd) â†’ snd}
                wyâˆˆA : (w â¸´ y) âˆˆ A
                wyâˆˆA = (projâ‚‚ âˆ˜ projâ‚‚) S'wxy wyâˆˆB
            in thm'â‡¨ ((projâ‚ âˆ˜ projâ‚‚) wyâˆˆA refl)})}

    theorem : âˆ€ {w C A} â†’ M , w âŠ© A â‡” M' O., w â¸´ C âŠ© A
    theorem = equivalence thmâ‡¨ thmâ‡¦

module Theorem-4
  {W R S}
  (F : Frame4 {â„“W} {â„“R} {â„“S} W R S)
  (V : W â†’ Pred Var lzero)
  where
  open Frame4 F
  open SemanticsProperties-4

  open Trans-conditions using (Trans-4)
  open OrdModel {â„“W} {â„“R} {â„“S} Trans-4 F V
  open PrefaceTheoremAll Trans-4 F V

  lemmaâ‡¦ : lemmaâ‡¦-type
  lemmaâ‡¦ {w} {b} {x} {V} Rwx SbxV =
    let
      qt = quasitrans SbxV
      v = projâ‚ qt
      vâˆˆV = projâ‚ (projâ‚‚ qt)
      transv : âˆ€ {Y} â†’ S b v Y â†’ S b x Y
      transv = projâ‚‚ (projâ‚‚ qt)
    in v â¸´ vâˆˆV
      -- (1)
      â¸´ (
      let
        Rbv : R b v
        Rbv = SwuYâŠ†Rw SbxV vâˆˆV
        Swvv : S b v ï½› v ï½
        Swvv = S-quasirefl Rbv
        Swxv : S b x ï½› v ï½
        Swxv = transv Swvv
        in const Swxv)
      -- (2)
      â¸´ Î» { Rbw â†’
        let
          Ruv : R b v
          Ruv = SwuYâŠ†Rw SbxV vâˆˆV
          Suvv : S b v ï½› v ï½
          Suvv = S-quasirefl Ruv
          Suxv : S b x ï½› v ï½
          Suxv = transv Suvv
          Suwx : S b w ï½› x ï½
          Suwx = R-Sw-trans Rbw Rwx
          transx : âˆ€ {Y} â†’ S b x Y â†’ S b w Y
          transx {Y} = case quasitrans Suwx of
            Î» { (_ â¸´ refl â¸´ p) â†’ p}
          Sbwv : S b w ï½› v ï½
          Sbwv = transx Suxv
        in Sbwv}

  lemmaâ‡¨ : lemmaâ‡¨-type
  lemmaâ‡¨ {w} {x} {Y} SwxY =
    let
      qt = quasitrans SwxY
      y = projâ‚ qt
      yâˆˆV = (projâ‚ âˆ˜ projâ‚‚) qt
      Rwy : R w y
      Rwy = SwuYâŠ†Rw SwxY (projâ‚ (projâ‚‚ qt))
      transy : âˆ€ {V} â†’ S w y V â†’ S w x V
      transy = (projâ‚‚ âˆ˜ projâ‚‚) qt
    in y â¸´ yâˆˆV â¸´
      (Î» {b} {V} SbyV â†’
    let vâˆˆV = (projâ‚ âˆ˜ projâ‚‚) (quasitrans SbyV)
        v = projâ‚ (quasitrans SbyV)
        transv : âˆ€ {V} â†’ S b v V â†’ S b y V
        transv = (projâ‚‚ âˆ˜ projâ‚‚) (quasitrans SbyV)
    in v â¸´ vâˆˆV â¸´
      -- (1)
      (Î» {refl â†’
        let
            SwxV : S w x V
            SwxV = transy SbyV
            Rwv : R w v
            Rwv = SwuYâŠ†Rw SwxV vâˆˆV
            Swvv : S w v ï½› v ï½
            Swvv = S-quasirefl Rwv
            Swxv : S w x ï½› v ï½
            Swxv = (transy âˆ˜ transv) Swvv
        in Swxv
        })
      -- (2)
      â¸´ Î» { Rbw â†’
        let
          Sbyz : S b w ï½› y ï½
          Sbyz = R-Sw-trans Rbw Rwy
          transy : âˆ€ {Y} â†’ S b y Y â†’ S b w Y
          transy {Y} = case quasitrans Sbyz of
            Î» { (_ â¸´ refl â¸´ a) â†’ a {Y}  }
          SbwY : S b w V
          SbwY = transy SbyV
          transv : âˆ€ {V} â†’ S b v V â†’ S b y V
          transv = (projâ‚‚ âˆ˜ projâ‚‚) (quasitrans SbyV)
          Sbvv : S b v ï½› v ï½
          Sbvv = S-quasirefl (SwuYâŠ†Rw SbwY vâˆˆV)
          Sbwv : S b w ï½› v ï½
          Sbwv = (transy âˆ˜ transv) Sbvv
        in Sbwv
      })

  module _
    (dec : MultiDecidableModel M)
    (dec' : O.DecidableModel M')
    (âˆˆS? : Decidableâ‚ƒ S)
    (âˆˆS'? : Decidableâ‚ƒ S')
    (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
    where
    open Theorem dec dec' âˆˆS? âˆˆS'? âˆˆSV? lemmaâ‡¨ lemmaâ‡¦

-- module Theorem-L
--   {W R S}
--   (F : FrameL {â„“W} {â„“R} {â„“S} W R S)
--   (V : W â†’ Pred Var lzero)
--   where
--   open FrameL F
--   open SemanticsProperties-L

--   open Trans-conditions using (Trans-L)
--   open OrdModel {â„“W} {â„“R} {â„“S} Trans-L F V
--   open PrefaceTheoremAll Trans-L F V
--   open FrameLProperties F

--   lemmaâ‡¦ : lemmaâ‡¦-type
--   lemmaâ‡¦ {w} {b} {x} {V} Rwx SbxV = v â¸´ vâˆˆV â¸´ l1 â¸´ l2
--     where
--       v = projâ‚ (Swu-sat SbxV)
--       vâˆˆV = projâ‚‚ (Swu-sat SbxV)
--       transv = quasitrans SbxV
--       l1 : b â‰¡ w â†’ S b x ï½› v ï½
--       l1 refl = {!!}
--         where
--         RbV : âˆ€ {v} â†’ v âˆˆ V â†’ R b v
--         RbV vâˆˆV = SwuYâŠ†Rw SbxV vâˆˆV
--         Swvv : S b v ï½› v ï½
--         Swvv = S-quasirefl (RbV vâˆˆV)
--         Swxv : S b x ï½› v ï½
--         Swxv = case quasitrans SbxV
--           (Î» { {v'} v'âˆˆV â†’ ï½› v' ï½ â¸´ S-quasirefl (RbV v'âˆˆV)}) of
--           Î» { SbxV â†’ {!SbxV!} }
--       l2 : R b w â†’ S b w ï½› v ï½
--       l2 Rbw = S-trans Rbw Rwx Sbxv
--         where
--         Rbv : R b v
--         Rbv = SwuYâŠ†Rw SbxV vâˆˆV
--         Sbvv : S b v ï½› v ï½
--         Sbvv = S-quasirefl Rbv
--         Sbxv : S b x ï½› v ï½
--         Sbxv = {!S-trans!}

  -- lemmaâ‡¦ {w} {b} {x} {V} Rwx SbxV =
  --   let
  --     qt = quasitrans SbxV
  --     v = projâ‚ qt
  --     vâˆˆV = projâ‚ (projâ‚‚ qt)
  --     transv : âˆ€ {Y} â†’ S b v Y â†’ S b x Y
  --     transv = projâ‚‚ (projâ‚‚ qt)

        -- let
        --   Ruv : R b v
        --   Ruv = SwuYâŠ†Rw SbxV vâˆˆV
        --   Suvv : S b v ï½› v ï½
        --   Suvv = S-quasirefl Ruv
        --   Suxv : S b x ï½› v ï½
        --   Suxv = transv Suvv
        --   Suwx : S b w ï½› x ï½
        --   Suwx = R-Sw-trans Rbw Rwx
        --   transx : âˆ€ {Y} â†’ S b x Y â†’ S b w Y
        --   transx {Y} = case quasitrans Suwx of
        --     Î» { (_ â¸´ refl â¸´ p) â†’ p}
        --   Sbwv : S b w ï½› v ï½
        --   Sbwv = transx Suxv
        -- in Sbwv}


  -- lemmaâ‡¨ : lemmaâ‡¨-type
  -- lemmaâ‡¨ {w} {x} {Y} SwxY = y â¸´ yâˆˆY â¸´ l
  --   where
  --     y = projâ‚ (Swu-sat SwxY)
  --     yâˆˆY = projâ‚‚ (Swu-sat SwxY)
  --     l : âˆ€ {b V} â†’ S b y V â†’ Î£ W
  --       (Î» v â†’ V v Ã— (b â‰¡ w â†’ S b x ï½› v ï½) Ã— (R b w â†’ S b w ï½› v ï½))
  --     l {b} {V} SbyV = v â¸´ vâˆˆV â¸´ l1 â¸´ l2
  --       where
  --       v = projâ‚ $ Swu-sat SbyV
  --       vâˆˆV = projâ‚‚ $ Swu-sat SbyV
  --       l1 : b â‰¡ w â†’ S b x ï½› v ï½
  --       l1 refl = {!!}
  --       l2 : R b w â†’ S b w ï½› v ï½
  --       l2 Rbw = {!!}

  -- module _
  --   (dec : MultiDecidableModel M)
  --   (dec' : O.DecidableModel M')
  --   (âˆˆS? : Decidableâ‚ƒ S)
  --   (âˆˆS'? : Decidableâ‚ƒ S')
  --   (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
  --   where
  --   open Theorem dec dec' âˆˆS? âˆˆS'? âˆˆSV? lemmaâ‡¨ lemmaâ‡¦

module Theorem-3
  {W R S}
  (F : Frame3 {â„“W} {â„“R} {â„“S} W R S)
  (V : W â†’ Pred Var lzero)
  where
  open Frame3 F
  open SemanticsProperties-3

  open Trans-conditions using (Trans-3)
  open OrdModel {â„“W} {â„“R} {â„“S} Trans-3 F V
  open PrefaceTheoremAll Trans-3 F V
  open FrameProperties Trans-3 F

  lemmaâ‡¦ : lemmaâ‡¦-type
  lemmaâ‡¦ {w} {b} {x} {V} Rwx SbxV =
    let
      qt = quasitrans SbxV
      v = projâ‚ qt
      vâˆˆV = projâ‚ (projâ‚‚ qt)
      transv : âˆ€ {Y} â†’ S b v Y â†’ Î£ ğ• Î» V' â†’ V' âŠ† Y Ã— S b x V'
      transv = projâ‚‚ (projâ‚‚ qt)
    in v â¸´ vâˆˆV
      -- (1)
      â¸´ (
      let
        Rbv : R b v
        Rbv = SwuYâŠ†Rw SbxV vâˆˆV
        Swvv : S b v ï½› v ï½
        Swvv = S-quasirefl Rbv
        Swxv : S b x ï½› v ï½
        Swxv = case transv Swvv of
          Î» { (v' â¸´ v'âŠ†ï½›vï½ â¸´ l) â†’ S-ext l v'âŠ†ï½›vï½
          Î» { refl â†’ case Swu-sat l of
          Î» { (_ â¸´ snd) â†’ case v'âŠ†ï½›vï½ snd of Î» {refl â†’ snd}}}}
        in const Swxv)
      -- (2)
      â¸´ Î» { Rbw â†’
        let
          Ruv : R b v
          Ruv = SwuYâŠ†Rw SbxV vâˆˆV
          Suvv : S b v ï½› v ï½
          Suvv = S-quasirefl Ruv
          Suxv : S b x ï½› v ï½
          Suxv = uncurry SâŠ†ï½›vï½ (projâ‚‚ (transv Suvv))
          Suwx : S b w ï½› x ï½
          Suwx = R-Sw-trans Rbw Rwx
          transx : âˆ€ {Y} â†’ S b x Y â†’ Î£ ğ• Î» Y' â†’ Y' âŠ† Y Ã— S b w Y'
          transx {Y} = case quasitrans Suwx of
            Î» { (_ â¸´ refl â¸´ p) â†’ p}
          Sbwv : S b w ï½› v ï½
          Sbwv = uncurry SâŠ†ï½›vï½ (projâ‚‚ (transx Suxv))
        in Sbwv}

  lemmaâ‡¨ : lemmaâ‡¨-type
  lemmaâ‡¨ {w} {x} {Y} SwxY =
    let
      qt = quasitrans SwxY
      y = projâ‚ qt
      yâˆˆV = (projâ‚ âˆ˜ projâ‚‚) qt
      Rwy : R w y
      Rwy = SwuYâŠ†Rw SwxY (projâ‚ (projâ‚‚ qt))
      transy : âˆ€ {u} â†’ S w y ï½› u ï½ â†’ S w x ï½› u ï½
      transy Sbvy = uncurry SâŠ†ï½›vï½ âˆ˜ projâ‚‚ âˆ˜ (projâ‚‚ âˆ˜ projâ‚‚) qt $ Sbvy
    in y â¸´ yâˆˆV â¸´
      (Î» {b} {V} SbyV â†’
    let vâˆˆV = (projâ‚ âˆ˜ projâ‚‚) (quasitrans SbyV)
        v = projâ‚ (quasitrans SbyV)
        transv : âˆ€ {u} â†’ S b v ï½› u ï½ â†’ S b y ï½› u ï½
        transv Sbvy = uncurry SâŠ†ï½›vï½ âˆ˜ projâ‚‚ âˆ˜ (projâ‚‚ âˆ˜ projâ‚‚ $ quasitrans SbyV) $ Sbvy
    in v â¸´ vâˆˆV â¸´
      -- (1)
      (Î» {refl â†’
        let
            Rwv : R w v
            Rwv = SwuYâŠ†Rw SbyV vâˆˆV
            Swvv : S w v ï½› v ï½
            Swvv = S-quasirefl Rwv
            Swxv : S w x ï½› v ï½
            Swxv = (transy âˆ˜ transv) Swvv
        in Swxv
        })
      -- (2)
      â¸´ Î» { Rbw â†’
        let
          Sbyz : S b w ï½› y ï½
          Sbyz = R-Sw-trans Rbw Rwy
          transy : âˆ€ {u} â†’ S b y ï½› u ï½ â†’ S b w ï½› u ï½
          transy {Y} Sbyu = case quasitrans Sbyz of
            Î» { (_ â¸´ refl â¸´ a) â†’ uncurry SâŠ†ï½›vï½ âˆ˜ projâ‚‚ $ a Sbyu }
          Rbv : R b v
          Rbv = SwuYâŠ†Rw SbyV vâˆˆV
          Sbvv : S b v ï½› v ï½
          Sbvv = S-quasirefl Rbv
          Sbwv : S b w ï½› v ï½
          Sbwv = (transy âˆ˜ transv) Sbvv
        in Sbwv
      })

  module _
    (dec : MultiDecidableModel M)
    (dec' : O.DecidableModel M')
    (âˆˆS? : Decidableâ‚ƒ S)
    (âˆˆS'? : Decidableâ‚ƒ S')
    (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
    where
    open Theorem dec dec' âˆˆS? âˆˆS'? âˆˆSV? lemmaâ‡¨ lemmaâ‡¦
\end{spverbatim}
