\begin{spverbatim}
module GeneralizedVeltmanSemantics.Properties.R where

open import Function.Equivalence using (_â‡”_; equivalence; module Equivalence)

open import Agda.Builtin.Nat using (Nat; suc; zero)
open import Agda.Builtin.Unit using (âŠ¤; tt)
open import Agda.Primitive using (Level; lzero; lsuc)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.Product using (Î£; projâ‚; projâ‚‚; _Ã—_) renaming (_,_ to _â¸´_)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚; [_,_])
open import Function using (_âˆ˜_; const; case_of_; id)
open import Function.Equality using (_âŸ¨$âŸ©_)
open import Relation.Binary using (REL; Rel; Transitive)
open import Relation.Nullary using (yes; no; Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; Satisfiable; _âŠ†_; _âˆ©_; ï½›_ï½)
open import Relation.Binary using (Irreflexive) renaming (Decidable to Decidableâ‚‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; subst; trans; sym)

open import Formula
open import GeneralizedVeltmanSemantics
open import Base using (_â‡’_; _â‡_; Decidableâ‚ƒ)
open import GeneralizedVeltmanSemantics.Properties
  using (module Extended; âŠ©Â¬; âŠ®Â¬; âŠ©â–¡; âŠ©â™¢; âŠ©MP; âŠ©âˆ§; âŠ©â†’Â¬âŠ®; âŠ®â†’Â¬âŠ©)
import Principles as P

private
  variable
    â„“W â„“R â„“S : Level

R-condition : âˆ€ {W R S} â†’ FrameL {â„“W} {â„“R} {â„“S} W R S â†’ Set _
R-condition {W = W} {R = R} {S = S} F = âˆ€ {w x y Y â„‚} â†’ R w x â†’ R x y â†’ S w y Y â†’ IsChoiceSet â„‚ x y â†’ Decidable â„‚
  â†’ Î£ ğ• Î» Y' â†’ Y' âŠ† Y Ã— S w x Y' Ã— âˆ€ {y'} â†’ y' âˆˆ Y' â†’ âˆ€ {z} â†’ R y' z â†’ z âˆˆ â„‚
  where
  open FrameL F


module R-soundness
  {W R S V}
  {M : Model {lzero} {lzero} {lzero} W R S V}
  (M,_*âŠ©?_ : MultiDecidableModel M)
  (âˆˆS? : Decidableâ‚ƒ S)
  (S? : S-decidable (Model.F M))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y) where

  open Model M
  open FrameL F
  open Extended M,_*âŠ©?_ âˆˆS? âˆˆSV?

  âŠ©R : âˆ€ {w A B C} â†’ R-condition F â†’
    M , w âŠ© A â–· B â† (Â¬' (A â–· C) â–· (B âˆ§ (â–¡ (Â¬' C))))
  âŠ©R {w} {A} {B} {C} c = âŠ©â† â‡ Î» Aâ–·B â†’ âŠ©â–· â‡ Î» {x} Rwx tmp â†’ case âŠ©Â¬ â‡’ tmp of
    Î» { (rhd (y â¸´ Rxy â¸´ vA â¸´ snd)) â†’ case (âŠ©â–· â‡’ Aâ–·B) (R-trans Rwx Rxy) vA of
    Î» { (Y â¸´ SwxY â¸´ YB) â†’ case c Rwx Rxy SwxY (Rxy
     â¸´ Î» {Z} SxyZ â†’ case snd Z (Swu-sat SxyZ) of
     Î» { (injâ‚ p) â†’ âŠ¥-elim (p SxyZ)
     ; (injâ‚‚ (z â¸´ zZ â¸´ zÂ¬C)) â†’ z â¸´ zZ â¸´ aux x y â‡ (âŠ©Â¬ â‡ zÂ¬C â¸´ Z â¸´ zZ â¸´ SxyZ)}) (dec x y)
      of Î» { (Y' â¸´ Y'âŠ†Y â¸´ SwxY' â¸´ snd) â†’ Y' â¸´ SwxY' â¸´ Î» { {y'} y'âˆˆY'
      â†’ âŠ©âˆ§ â‡ (YB (Y'âŠ†Y y'âˆˆY') â¸´ âŠ©â–¡ â‡ Î» { {v} Ry'v â†’ projâ‚ (aux x y â‡’ snd y'âˆˆY' Ry'v)})}}}}
      where
      â„‚ : W â†’ W â†’ ğ•
      â„‚ x y g with M, g âŠ©? Â¬' C
      ... | injâ‚‚ _ = âŠ¥
      ... | injâ‚ _ with S? x y g
      ... | injâ‚ _  = âŠ¤
      ... | injâ‚‚ _ = âŠ¥
      dec : (x y : W) â†’ Decidable (â„‚ x y)
      dec x y g with M, g âŠ©? Â¬' C
      ... | injâ‚‚ _ = no Î» z â†’ z
      ... | injâ‚ _ with S? x y g
      ... | injâ‚ _  = yes tt
      ... | injâ‚‚ _ = no Î» z â†’ z
      aux : âˆ€ {g} x y â†’ g âˆˆ â„‚ x y â‡” (M , g âŠ© Â¬' C Ã— Î£ ğ• Î» U â†’ g âˆˆ U Ã— S x y U)
      aux {g} x y = equivalence â‡¨ â‡¦
        where â‡¨ : g âˆˆ â„‚ x y â†’ (M , g âŠ© Â¬' C Ã— Î£ ğ• Î» U â†’ g âˆˆ U Ã— S x y U)
              â‡¨ p with M, g âŠ©? Â¬' C
              ... | injâ‚‚ _ = âŠ¥-elim p
              ... | injâ‚ k with S? x y g
              ... | injâ‚‚ _ = âŠ¥-elim p
              ... | injâ‚ k' = k â¸´ k'
              â‡¦ : (M , g âŠ© Â¬' C Ã— Î£ ğ• Î» U â†’ g âˆˆ U Ã— S x y U) â†’ g âˆˆ â„‚ x y
              â‡¦ (p1 â¸´ p2) with M, g âŠ©? Â¬' C
              ... | injâ‚‚ m1 = âŠ®â†’Â¬âŠ© m1 p1
              ... | injâ‚ m1 with S? x y g
              ... | injâ‚ m2 = tt
              ... | injâ‚‚ m2 = case p2 of Î» { (Z â¸´ gZ â¸´ SxyZ) â†’ m2 Z SxyZ gZ}

module R-condition
  {W R S}
  {F : FrameL {lzero} {lzero} {lzero} W R S}
  (S? : Decidableâ‚ƒ S)
  (dec : âˆ€ V â†’ MultiDecidableModel (model {V = V} F))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
  where
  open FrameL F
  *âŠ©R : Setâ‚
  *âŠ©R = P.R (F *âŠ©_)

  pattern p = 0
  pattern q = 1
  pattern s = 2

  âŠ©Râ‡’R-condition : *âŠ©R â†’ R-condition F
  âŠ©Râ‡’R-condition âŠ©Ra {w} {x} {y} {Y} {â„‚} Rwx Rxy SwyY (_ â¸´ C) âˆˆâ„‚?
    = case (âŠ©â–· â‡’ wâŠ©G) Rwx (âŠ©Â¬ â‡ xâŠ®pâ–·s) of
      Î» { (Y' â¸´ SwxY' â¸´ snd) â†’ Y' â¸´ (Î» {v} vâˆˆ â†’ YâŠ©q â‡’ projâ‚ (âŠ©âˆ§ â‡’ (snd vâˆˆ))) â¸´ SwxY' â¸´
      Î» {y'} y'âˆˆ {z} Ry'z â†’ â„‚âŠ©Â¬s â‡’ ((âŠ©â–¡ â‡’ projâ‚‚ (âŠ©âˆ§ â‡’ (snd y'âˆˆ))) Ry'z)}
    where
    V : Valuation F
    V u p = u â‰¡ y
    V u q = u âˆˆ Y
    V u s = u âˆˆ â„‚
    V w (suc (suc (suc x))) = âŠ¥
    M = model {V = V} F
    open Extended (dec V) S? âˆˆSV?
    YâŠ©q : âˆ€ {w'} â†’ M , w' âŠ© var q â‡” w' âˆˆ Y
    YâŠ©q {w'} = equivalence â‡¨ â‡¦
      where
      â‡¨ : M , w' âŠ© var q â†’ Y w'
      â‡¨ (var x) = x
      â‡¦ : Y w' â†’ M , w' âŠ© var q
      â‡¦ x = var x
    â„‚âŠ©Â¬s : âˆ€ {w'} â†’ M , w' âŠ© var s â‡” w' âˆˆ â„‚
    â„‚âŠ©Â¬s {w'} = equivalence â‡¨ â‡¦
      where
      â‡¦ : â„‚ w' â†’ M , w' âŠ© var s
      â‡¦ x = var x
      â‡¨ : M , w' âŠ© var s â†’ â„‚ w'
      â‡¨ (var vr) with âˆˆâ„‚? w'
      ... | yes ans = ans
      ... | no z = vr
    yâŠ©p : âˆ€ {w'} â†’ M , w' âŠ© var p â‡” w' â‰¡ y
    yâŠ©p {w'} = equivalence â‡¨ â‡¦
      where â‡¨ : M , w' âŠ© var 0 â†’ w' â‰¡ y
            â‡¨ (var refl) = refl
            â‡¦ : w' â‰¡ y â†’ M , w' âŠ© var 0
            â‡¦ refl = var refl
    wâŠ©pâ–·q : M , w âŠ© var p â–· var q
    wâŠ©pâ–·q = âŠ©â–· â‡ Î» {w'} Rww' w'âŠ©p â†’ case yâŠ©p â‡’ w'âŠ©p of
      Î» {refl â†’ Y â¸´ SwyY â¸´ Î» {v'} xâ‚ â†’ var xâ‚}
    wâŠ©G : M , w âŠ© (Â¬' (var 0 â–· Â¬' (var 2))) â–· (var 1 âˆ§ (â–¡ (var 2)))
    wâŠ©G = âŠ©MP (âŠ©Ra V w) wâŠ©pâ–·q
    xâŠ®pâ–·s : M , x âŠ® var p â–· (Â¬' (var s))
    xâŠ®pâ–·s = rhd (y â¸´ Rxy â¸´ yâŠ©p â‡ refl â¸´ Î» {Y' sY' â†’ case S? x y Y' of
      Î» { (yes z) â†’ injâ‚‚ (case C z of (Î» { (y' â¸´ fst â¸´ snd) â†’ y' â¸´
        (fst â¸´ impl (var snd) bot)}));
      (no z) â†’ injâ‚ z}})
\end{spverbatim}
