\begin{spverbatim}
module GeneralizedVeltmanSemantics.Properties.Mâ‚€ where

open import Function.Equivalence using (_â‡”_; equivalence; module Equivalence)

open import Agda.Builtin.Nat using (Nat; suc; zero)
open import Agda.Builtin.Unit using (âŠ¤; tt)
open import Agda.Primitive using (Level; lzero; lsuc)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.Product using (Î£; projâ‚; projâ‚‚; _Ã—_) renaming (_,_ to _â¸´_)
open import Data.Sum using (_âŠ_; injâ‚; injâ‚‚; [_,_])
open import Function using (_âˆ˜_; const; case_of_; id)
open import Function.Equality using (_âŸ¨$âŸ©_)
open import Relation.Binary using (REL; Rel; Transitive)
open import Relation.Nullary using (yes; no; Â¬_)
open import Relation.Unary using (Pred; _âˆˆ_; _âˆ‰_; Decidable; Satisfiable; _âŠ†_; _âˆ©_; ï½›_ï½)
open import Relation.Binary using (Irreflexive) renaming (Decidable to Decidableâ‚‚)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl; subst; trans; sym)

open import Formula
open import GeneralizedVeltmanSemantics
open import Base
open import GeneralizedVeltmanSemantics.Properties
  using (module Extended; âŠ©Â¬; âŠ®Â¬; âŠ©â–¡; âŠ©â™¢; âŠ©MP; âŠ©âˆ§; âŠ©â†’Â¬âŠ®; âŠ®â†’Â¬âŠ©)
import Principles as P

private
  variable
    â„“W â„“R â„“S : Level

Mâ‚€-condition : âˆ€ {W R S} â†’ FrameL {â„“W} {â„“R} {â„“S} W R S â†’ Set _
Mâ‚€-condition {W = W} {R = R} {S = S} F = âˆ€ {w x y Y} â†’ R w x â†’ R x y â†’ S w y Y â†’ Î£ ğ• Î» Y'
  â†’ Y' âŠ† Y Ã— S w x Y' Ã— âˆ€ {y'} z â†’ y' âˆˆ Y' â†’ R y' z â†’ R x z
  where open FrameL F


module Mâ‚€-soundness
  {W R S V}
  {M : Model {lzero} {lzero} {lzero} W R S V}
  (M,_*âŠ©?_ : MultiDecidableModel M)
  (âˆˆS? : Decidableâ‚ƒ S)
  (S? : S-decidable (Model.F M))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y) where

  open Model M
  open FrameL F
  open Extended M,_*âŠ©?_ âˆˆS? âˆˆSV?

  âŠ©Mâ‚€ : âˆ€ {w A B C} â†’ Mâ‚€-condition F â†’ M , w âŠ© A â–· B â† (â™¢ A âˆ§ â–¡ C) â–· (B âˆ§ â–¡ C)
  âŠ©Mâ‚€ {w} {A} {B} {C} c = âŠ©â† â‡ Î» Aâ–·B â†’ âŠ©â–· â‡ Î» {u} Rwu a â†’ case âŠ©âˆ§ â‡’ a of
    Î» { (uâ™¢A â¸´ uâ–¡C) â†’ case âŠ©â™¢ â‡’ uâ™¢A of Î» { (v â¸´ Ruv â¸´ vA)
    â†’ case (âŠ©â–· â‡’ Aâ–·B) (R-trans Rwu Ruv) vA of Î» { (Y â¸´ SwvY â¸´ YB)
    â†’ case c Rwu Ruv SwvY of Î» { (Y' â¸´ Y'âŠ†Y â¸´ SwuY' â¸´ snd)
    â†’ Y' â¸´ SwuY' â¸´ Î» { {y'} y'âˆˆY' â†’ âŠ©âˆ§ â‡ (YB (Y'âŠ†Y y'âˆˆY') â¸´ (âŠ©â–¡ â‡ (Î» {z} Ry'z
    â†’ (âŠ©â–¡ â‡’ uâ–¡C) (snd z y'âˆˆY' Ry'z))))}}}}}

module Mâ‚€-completeness
  {W R S}
  {F : FrameL {lzero} {lzero} {lzero} W R S}
  (âˆˆS? : Decidableâ‚ƒ S)
  (dec : âˆ€ V â†’ MultiDecidableModel (model {V = V} F))
  (âˆˆSV? : âˆ€ {w u Y} â†’ S w u Y â†’ Decidable Y)
  where
  open FrameL F

  *âŠ©Mâ‚€ : Setâ‚
  *âŠ©Mâ‚€ = P.Mâ‚€ (F *âŠ©_)

  pattern a = 0
  pattern b = 1
  pattern c = 2

  âŠ©Mâ‚€â‡’Mâ‚€-condition : *âŠ©Mâ‚€ â†’ Mâ‚€-condition F
  âŠ©Mâ‚€â‡’Mâ‚€-condition âŠ©Mâ‚€ {w} {x} {y} {Y} Rwx Rxy SwyY
    = case (âŠ©â–· â‡’ âŠ©MP (âŠ©Mâ‚€ Val w) wâŠ©aâ–·b) Rwx xâŠ©â™¢aâˆ§â–¡c of
      Î» { (Y' â¸´ SwxY' â¸´ snd) â†’ Y' â¸´ (Î» {y â†’ [b] â‡’ projâ‚ (âŠ©âˆ§ â‡’ snd y)})
      â¸´ SwxY' â¸´ (Î» { {y'} z y'âˆˆY' Ry'z â†’ [c] â‡’ (âŠ©â–¡ â‡’ (projâ‚‚ (âŠ©âˆ§ â‡’ snd y'âˆˆY'))) Ry'z})}
    where
    Val : Valuation F
    Val w a = w â‰¡ y
    Val w b = w âˆˆ Y
    Val w c = R x w
    Val w (suc (suc (suc _))) = âŠ¥
    M = model {V = Val} F
    open Extended (dec Val) âˆˆS? âˆˆSV?
    [a] : âˆ€ {w} â†’ M , w âŠ© var a â‡” w â‰¡ y
    [a] = equivalence (Î» { (var x) â†’ x}) Î» {z â†’ var z}
    [b] : âˆ€ {w} â†’ M , w âŠ© var b â‡” w âˆˆ Y
    [b] = equivalence (Î» { (var x) â†’ x}) Î» {z â†’ var z}
    [c] : âˆ€ {w} â†’ M , w âŠ© var c â‡” R x w
    [c] = equivalence (Î» { (var x) â†’ x}) Î» {z â†’ var z}
    wâŠ©aâ–·b : M , w âŠ© var a â–· var b
    wâŠ©aâ–·b = âŠ©â–· â‡ Î» {Rwu ua â†’ case [a] â‡’ ua of Î» {refl â†’ Y â¸´ (SwyY â¸´ Î» {xâ‚ â†’ var xâ‚})}}
    xâŠ©â™¢aâˆ§â–¡c : M , x âŠ© â™¢ var a âˆ§ â–¡ var c
    xâŠ©â™¢aâˆ§â–¡c = âŠ©âˆ§ â‡ (âŠ©â™¢ â‡ (y â¸´ Rxy â¸´ [a] â‡ refl) â¸´ âŠ©â–¡ â‡ Î» {p â†’ [c] â‡ p})
\end{spverbatim}
